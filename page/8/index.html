<!DOCTYPE html><html lang="zh-CN"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=2"><meta name="theme-color" content="#222"><meta name="generator" content="Hexo 6.3.0"><link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png"><link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32.png"><link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16.png"><link rel="mask-icon" href="/images/logo.svg" color="#222"><link rel="stylesheet" href="/css/main.css"><link rel="stylesheet" href="/lib/font-awesome/css/all.min.css"><link rel="stylesheet" href="/lib/pace/pace-theme-material.min.css"><script src="/lib/pace/pace.min.js"></script><script id="hexo-configurations">var NexT=window.NexT||{},CONFIG={hostname:"example.com",root:"/",scheme:"Pisces",version:"7.8.0",exturl:!1,sidebar:{position:"left",display:"post",padding:18,offset:12,onmobile:!1},copycode:{enable:!1,show_result:!1,style:null},back2top:{enable:!0,sidebar:!1,scrollpercent:!1},bookmark:{enable:!1,color:"#222",save:"auto"},fancybox:!1,mediumzoom:!1,lazyload:!1,pangu:!1,comments:{style:"tabs",active:null,storage:!0,lazyload:!1,nav:null},algolia:{hits:{per_page:10},labels:{input_placeholder:"Search for Posts",hits_empty:"We didn't find any results for the search: ${query}",hits_stats:"${hits} results found in ${time} ms"}},localsearch:{enable:!1,trigger:"auto",top_n_per_article:1,unescape:!1,preload:!1},motion:{enable:!0,async:!1,transition:{post_block:"fadeIn",post_header:"slideDownIn",post_body:"slideDownIn",coll_header:"slideLeftIn",sidebar:"slideUpIn"}},path:"search.xml"}</script><meta name="description" content="在梦里啥都有"><meta property="og:type" content="website"><meta property="og:title" content="睡觉万岁"><meta property="og:url" content="http://example.com/page/8/index.html"><meta property="og:site_name" content="睡觉万岁"><meta property="og:description" content="在梦里啥都有"><meta property="og:locale" content="zh_CN"><meta property="article:author" content="毛"><meta name="twitter:card" content="summary"><link rel="canonical" href="http://example.com/page/8/"><script id="page-configurations">CONFIG.page={sidebar:"",isHome:!0,isPost:!1,lang:"zh-CN"}</script><title>睡觉万岁</title><noscript><style>.sidebar-inner,.use-motion .brand,.use-motion .collection-header,.use-motion .comments,.use-motion .menu-item,.use-motion .pagination,.use-motion .post-block,.use-motion .post-body,.use-motion .post-header{opacity:initial}.use-motion .site-subtitle,.use-motion .site-title{opacity:initial;top:initial}.use-motion .logo-line-before i{left:initial}.use-motion .logo-line-after i{right:initial}</style></noscript></head><script src="https://g.joyinshare.com/hc/ribbon.min.js" type="text/javascript"></script><body itemscope itemtype="http://schema.org/WebPage"><div class="container use-motion"><div class="headband"></div><a target="_blank" rel="noopener" href="https://github.com/maduit" class="github-corner" aria-label="View source on GitHub"><svg width="80" height="80" viewBox="0 0 250 250" style="fill:#64ceaa;color:#fff;position:absolute;top:0;border:0;left:0;transform:scale(-1,1)" aria-hidden="true"><path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"></path><path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2" fill="currentColor" style="transform-origin:130px 106px" class="octo-arm"></path><path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z" fill="currentColor" class="octo-body"></path></svg></a><style>.github-corner:hover .octo-arm{animation:octocat-wave 560ms ease-in-out}@keyframes octocat-wave{0%,100%{transform:rotate(0)}20%,60%{transform:rotate(-25deg)}40%,80%{transform:rotate(10deg)}}@media (max-width:500px){.github-corner:hover .octo-arm{animation:none}.github-corner .octo-arm{animation:octocat-wave 560ms ease-in-out}}</style><header class="header" itemscope itemtype="http://schema.org/WPHeader"><div class="header-inner"><div class="site-brand-container"><div class="site-nav-toggle"><div class="toggle" aria-label="切换导航栏"><span class="toggle-line toggle-line-first"></span> <span class="toggle-line toggle-line-middle"></span> <span class="toggle-line toggle-line-last"></span></div></div><div class="site-meta"><a href="/" class="brand" rel="start"><span class="logo-line-before"><i></i></span><h1 class="site-title">睡觉万岁</h1><span class="logo-line-after"><i></i></span></a></div><div class="site-nav-right"><div class="toggle popup-trigger"></div></div></div><nav class="site-nav"><ul id="menu" class="main-menu menu"><li class="menu-item menu-item-home"><a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a></li><li class="menu-item menu-item-about"><a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>关于</a></li><li class="menu-item menu-item-tags"><a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a></li><li class="menu-item menu-item-categories"><a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a></li><li class="menu-item menu-item-archives"><a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a></li><li class="menu-item menu-item-schedule"><a href="/schedule/" rel="section"><i class="fa fa-calendar fa-fw"></i>日程表</a></li></ul></nav></div></header><div class="back-to-top"><i class="fa fa-arrow-up"></i> <span>0%</span></div><main class="main"><div class="main-inner"><div class="content-wrap"><div class="content index posts-expand"><article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN"><link itemprop="mainEntityOfPage" href="http://example.com/2023/03/17/%E5%A6%82%E4%BD%95%E5%9C%A8Linux%E7%B3%BB%E7%BB%9F%E4%B8%8B%E7%BC%96%E8%AF%91C++/"><span hidden itemprop="author" itemscope itemtype="http://schema.org/Person"><meta itemprop="image" content="/images/xiao.png"><meta itemprop="name" content="毛"><meta itemprop="description" content="在梦里啥都有"></span><span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization"><meta itemprop="name" content="睡觉万岁"></span><header class="post-header"><h2 class="post-title" itemprop="name headline"><a href="/2023/03/17/%E5%A6%82%E4%BD%95%E5%9C%A8Linux%E7%B3%BB%E7%BB%9F%E4%B8%8B%E7%BC%96%E8%AF%91C++/" class="post-title-link" itemprop="url">如何在Linux系统下编译C++</a></h2><div class="post-meta"><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-calendar"></i> </span><span class="post-meta-item-text">发表于</span> <time title="创建时间：2023-03-17 21:50:45 / 修改时间：22:05:29" itemprop="dateCreated datePublished" datetime="2023-03-17T21:50:45+08:00">2023-03-17</time> </span><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-folder"></i> </span><span class="post-meta-item-text">分类于</span> <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/2023/" itemprop="url" rel="index"><span itemprop="name">2023</span></a></span></span></div></header><div class="post-body" itemprop="articleBody"><h1 id="如何在Linux系统下编译C"><a href="#如何在Linux系统下编译C" class="headerlink" title="如何在Linux系统下编译C++"></a>如何在Linux系统下编译C++</h1><h3 id="方法一"><a href="#方法一" class="headerlink" title="方法一:"></a>方法一:</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;hello_word&quot;</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/images/loading.gif" data-original="/images/NOI/1.png" alt="1679061064013"></p><p>编译</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gcc 1.cpp -lstdc++ </span><br></pre></td></tr></table></figure><p>生a.out文件</p><p><img src="/images/loading.gif" data-original="/images/NOI/2.png" alt="1679061165889"></p><p>运行a.out</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./a.out</span><br></pre></td></tr></table></figure><p><img src="/images/loading.gif" data-original="/images/NOI/3.png" alt="1679061280444"></p><h3 id="方法二"><a href="#方法二" class="headerlink" title="方法二:"></a>方法二:</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;hello_word222&quot;</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/images/loading.gif" data-original="/images/NOI/5.png" alt="1679061782953"></p><p>编译</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">g++ 2.cpp -o 2output</span><br></pre></td></tr></table></figure><p>运行2output</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./2output</span><br></pre></td></tr></table></figure></div><footer class="post-footer"><div class="post-eof"></div></footer></article><article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN"><link itemprop="mainEntityOfPage" href="http://example.com/2023/03/17/%E8%BF%9B%E7%A8%8B%E5%90%8C%E6%AD%A5/"><span hidden itemprop="author" itemscope itemtype="http://schema.org/Person"><meta itemprop="image" content="/images/xiao.png"><meta itemprop="name" content="毛"><meta itemprop="description" content="在梦里啥都有"></span><span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization"><meta itemprop="name" content="睡觉万岁"></span><header class="post-header"><h2 class="post-title" itemprop="name headline"><a href="/2023/03/17/%E8%BF%9B%E7%A8%8B%E5%90%8C%E6%AD%A5/" class="post-title-link" itemprop="url">操作系统——进程同步——生产者消费者问题</a></h2><div class="post-meta"><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-calendar"></i> </span><span class="post-meta-item-text">发表于</span> <time title="创建时间：2023-03-17 11:21:38" itemprop="dateCreated datePublished" datetime="2023-03-17T11:21:38+08:00">2023-03-17</time> </span><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-calendar-check"></i> </span><span class="post-meta-item-text">更新于</span> <time title="修改时间：2023-03-24 08:36:45" itemprop="dateModified" datetime="2023-03-24T08:36:45+08:00">2023-03-24</time> </span><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-folder"></i> </span><span class="post-meta-item-text">分类于</span> <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/2023/" itemprop="url" rel="index"><span itemprop="name">2023</span></a></span></span></div></header><div class="post-body" itemprop="articleBody"><h1 id="进程同步"><a href="#进程同步" class="headerlink" title="进程同步"></a>进程同步</h1><ul><li><p><strong>pv 操作 互斥锁</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">P --wait(信号量S)&#123;</span><br><span class="line">	S&lt;=0</span><br><span class="line">	S--			//上锁</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>成对出现</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">V --signal(信号量)&#123;</span><br><span class="line">	S++			//开锁</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>生产者</p></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">in</span><span class="params">()</span>,out</span>=();</span><br><span class="line">item butter[n];</span><br><span class="line">semaphore mutex=<span class="number">1</span>,empty=n,full=();<span class="comment">//mutex必须为1 ,empty空位置,full有多少个</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">proceducer</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="keyword">do</span>&#123;</span><br><span class="line">	producer an item nextp;</span><br><span class="line">	……</span><br><span class="line">	<span class="built_in">wait</span>(empty);       <span class="comment">//enpty--</span></span><br><span class="line">	<span class="built_in">wait</span>(mutex);	   <span class="comment">//上锁</span></span><br><span class="line">	butter[in]=nextp;  <span class="comment">//生产一个</span></span><br><span class="line">	in:=(in+<span class="number">1</span>)%n;      <span class="comment">// 生产一个</span></span><br><span class="line">	<span class="built_in">signal</span>(mutex);	   <span class="comment">//解锁</span></span><br><span class="line">	<span class="built_in">signal</span>(full);      <span class="comment">//full++</span></span><br><span class="line">	&#125;<span class="keyword">while</span>(TRUE)；</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>消费者</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">consumer</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="keyword">do</span>&#123;</span><br><span class="line">		<span class="built_in">wait</span>(full)；      	<span class="comment">//full-1</span></span><br><span class="line">		<span class="built_in">wait</span>(mutex);		<span class="comment">//上锁</span></span><br><span class="line">		nextc=butter[out];  <span class="comment">//消费一个</span></span><br><span class="line">		out=(out+<span class="number">1</span>)%n;		<span class="comment">//消费一个</span></span><br><span class="line">		<span class="built_in">signal</span>(mutex);  	<span class="comment">//解锁</span></span><br><span class="line">		<span class="built_in">signal</span>(empty); 		<span class="comment">//empty++</span></span><br><span class="line">		consumer the item in nextc;</span><br><span class="line">	&#125;<span class="keyword">while</span>(TRUE);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="function">cobegin</span></span><br><span class="line"><span class="function">		<span class="title">proceducer</span><span class="params">()</span></span>;<span class="built_in">consumer</span>();</span><br><span class="line">	coend</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/images/loading.gif" data-original="/images/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/1.png" alt="1679017003280"></p><h3 id="第1关：生产者消费者同步控制"><a href="#第1关：生产者消费者同步控制" class="headerlink" title="第1关：生产者消费者同步控制"></a>第1关：生产者消费者同步控制</h3><h4 id="任务描述"><a href="#任务描述" class="headerlink" title="任务描述"></a>任务描述</h4><p>本关任务：编写生产者消费者同步控制程序。</p><h4 id="相关知识"><a href="#相关知识" class="headerlink" title="相关知识"></a>相关知识</h4><p>为了完成本关任务，你需要掌握：1.理解生产者消费者同步问题，2.线程的编写方法，3.使用信号量实现线程间同步控制。</p><h5 id="线程并发引起的同步问题"><a href="#线程并发引起的同步问题" class="headerlink" title="线程并发引起的同步问题"></a>线程并发引起的同步问题</h5><p>线程以并发形式运行，当并发的线程间访问共享数据时，会发后争用现象，不进行同步控制的线程运行会造成不恰当的结果。</p><h5 id="生产者消费者同步问题"><a href="#生产者消费者同步问题" class="headerlink" title="生产者消费者同步问题"></a>生产者消费者同步问题</h5><p>生产者消费者是典型的同步问题，他们共享了一个缓冲池(全局变量数组)，当缓冲池有空位时生产者线程向缓冲池中依次赋值，如果缓冲池满则等待。当缓冲池中有数据时消费者线程从中取走数据，如果缓冲池空则等待。</p><h5 id="如何解决线程间访问共享变量的冲突问题"><a href="#如何解决线程间访问共享变量的冲突问题" class="headerlink" title="如何解决线程间访问共享变量的冲突问题"></a>如何解决线程间访问共享变量的冲突问题</h5><p>当多个线程访问同一个共享变量时，共享变量成为临界资源，它需要操作系统提供同步控制机制，以保证多个线程可以依序访问，当一个线程操作临界资源时其它线程不会中断其操作，因此对临界资源的操作是安全的。 下面是linux平台使用信号量的头文件和方法。 #include &lt;semaphore.h&gt; int sem_init(sem_t * sem, int pshared, unsigned int value);&#x2F;&#x2F;创建信号量变量，value是信号量的初值 int sem_destroy(sem_t *sem);&#x2F;&#x2F;销毁信号量 int sem_post(sem_t * sem); &#x2F;&#x2F;信号量值增加1，并激活处于等待状态的线程 int sem_wait(sem_t * sem); &#x2F;&#x2F;信号量值减少1 为0时将调用该方法的线程被OS阻塞</p><h4 id="编程要求"><a href="#编程要求" class="headerlink" title="编程要求"></a>编程要求</h4><p>主线程序启动生产者线程和消费者线程，并等待两个线程的结束。 两个线程使用三个信号量，其中生产者线程向全局变量进行十次赋值(代表生产)，每次赋值前都要检查是否有空位，有空位的情况下 需要获得互斥量sem_mutex，并对共享缓冲区进行赋值，然后释放互斥量以便消费者线程可以操作缓冲区临界资源。 消费者线程要从缓冲区取值，取值前先检查是否有可用数据，有可用数据的情况下再获得互斥量sem_mutex，再取出缓冲区的值。 要特别说明的是生产者和消费者线程工作的速率是不同的，但在同步信号控制下，两个线程节奏互相配合步调一致。在《计算机操作系统》 教材中使用了伪代码，并且循环体没有结束条件，在此用C语言改写原程序，生产者一共只生产十个数据。 ####测试说明 为简化数据操作，程序没有输入，主线程已经写好， void * producer(void * arg); void * consumer(void * arg); static sem_t sem_empty;&#x2F;&#x2F;空位个数 static sem_t sem_full; &#x2F;&#x2F;可用数据个数 static sem_t sem_mutex; &#x2F;&#x2F;互斥量，用于控制两个线程互斥访问缓冲区 static int buffer[]&#x3D;{0,0,0}; int main(int argc,char * argv[]) { pthread_t id_prod,id_consum; sem_init(&amp;sem_empty,0,3); &#x2F;&#x2F;初值为3，空位为3， sem_init(&amp;sem_full,0,0); &#x2F;&#x2F;初值为0，可用数据个数为0， sem_init(&amp;sem_mutex,0,1); &#x2F;&#x2F;初值为1，用于控制两个线程互斥访问缓冲区 pthread_create(&amp;id_prod, NULL,producer,NULL);&#x2F;&#x2F;创建生产者线程 pthread_create(&amp;id_consum,NULL,consumer,NULL);&#x2F;&#x2F;创建消费者线程</p><p>pthread_join(id_prod,NULL); &#x2F;&#x2F;主线程等待生产者线程结束 pthread_join(id_consum,NULL);&#x2F;&#x2F;主线程等待消费者线程结束 sem_destroy(&amp;sem_empty); sem_destroy(&amp;sem_full); sem_destroy(&amp;sem_mutex); return 0; } 学生需要补充producer线程与consumer中关于同步控制部分的程序。</p><p>输出：1至10 (需由学生根据程序生成正确结果) 开始你的任务吧，祝你成功！</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//stu001.c 生产者消费者同步控制，由学生完成缺失代码。 </span></span><br><span class="line"><span class="comment">//主线程序启动生产者线程和消费者线程，全局变量初值为0</span></span><br><span class="line"><span class="comment">//生产者线程向全局变量进行10次赋值(代表生产)，消费者线程从全局变量读取值，///并重新赋值0(代表消费了产品)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span> </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;semaphore.h&gt;</span> </span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> * <span class="title function_">producer</span><span class="params">(<span class="type">void</span> * arg)</span>;</span><br><span class="line"><span class="type">void</span> * <span class="title function_">consumer</span><span class="params">(<span class="type">void</span> * arg)</span>;</span><br><span class="line"><span class="type">static</span> <span class="type">sem_t</span> sem_empty;<span class="comment">//空位个数</span></span><br><span class="line"><span class="type">static</span> <span class="type">sem_t</span> sem_full; <span class="comment">//可用数据个数</span></span><br><span class="line"><span class="type">static</span> <span class="type">sem_t</span> sem_mutex; <span class="comment">//互斥量，用于控制两个线程互斥访问缓冲区</span></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> buffer[]=&#123;<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>&#125;;<span class="comment">//共享的缓冲区</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc,<span class="type">char</span> * argv[])</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">pthread_t</span> id_prod,id_consum;</span><br><span class="line">  sem_init(&amp;sem_empty,<span class="number">0</span>,<span class="number">3</span>); <span class="comment">//初值为3，空位为3，</span></span><br><span class="line">  sem_init(&amp;sem_full,<span class="number">0</span>,<span class="number">0</span>);  <span class="comment">//初值为0，可用数据个数为0，</span></span><br><span class="line">  sem_init(&amp;sem_mutex,<span class="number">0</span>,<span class="number">1</span>); <span class="comment">//初值为1，用于控制两个线程互斥访问缓冲区 </span></span><br><span class="line">  pthread_create(&amp;id_prod,  <span class="literal">NULL</span>,producer,<span class="literal">NULL</span>);<span class="comment">//创建生产者线程</span></span><br><span class="line">  pthread_create(&amp;id_consum,<span class="literal">NULL</span>,consumer,<span class="literal">NULL</span>);<span class="comment">//创建消费者线程</span></span><br><span class="line"></span><br><span class="line">  pthread_join(id_prod,<span class="literal">NULL</span>);  <span class="comment">//主线程等待生产者线程结束</span></span><br><span class="line">  pthread_join(id_consum,<span class="literal">NULL</span>);<span class="comment">//主线程等待消费者线程结束</span></span><br><span class="line">  sem_destroy(&amp;sem_empty);</span><br><span class="line">  sem_destroy(&amp;sem_full);</span><br><span class="line">  sem_destroy(&amp;sem_mutex);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> * <span class="title function_">producer</span><span class="params">(<span class="type">void</span> * arg)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">int</span> i,pIndex=<span class="number">0</span>; </span><br><span class="line">  <span class="keyword">for</span>(i=<span class="number">11</span>;i&lt;<span class="number">21</span>;i++)</span><br><span class="line">  &#123;</span><br><span class="line">	  <span class="comment">//请在begin end语句间补全程序语句实现生产者向缓冲区赋值操作 </span></span><br><span class="line">	  <span class="comment">/*  begin *******************程序代码约六行******************************* */</span></span><br><span class="line">	  sem_wait(&amp;sem_empty);<span class="comment">//empty--</span></span><br><span class="line">      sem_wait(&amp;sem_mutex); <span class="comment">//枷锁</span></span><br><span class="line">      buffer[pIndex]=i;   <span class="comment">//缓冲区只有三个位置</span></span><br><span class="line">      pIndex=(pIndex+<span class="number">1</span>)%<span class="number">3</span>;<span class="comment">// 11-- 0  12--1 13--2 14--0 15--1 16--2</span></span><br><span class="line">      sem_post(&amp;sem_mutex);<span class="comment">//解锁</span></span><br><span class="line">      sem_post(&amp;sem_full);<span class="comment">//full++</span></span><br><span class="line">	  <span class="comment">/*   end  ************************************************************** */</span> </span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> * <span class="title function_">consumer</span><span class="params">(<span class="type">void</span> *arg)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">int</span> i,cIndex=<span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span>(i=<span class="number">11</span>;i&lt;<span class="number">21</span>;i++)</span><br><span class="line">  &#123; </span><br><span class="line">	  <span class="comment">//请在begin end语句间补全程序语句实现扫描算法，算出总访问磁道数存入totaltracks变量 </span></span><br><span class="line">	  <span class="comment">/*  begin *******************程序代码约六行******************************* */</span> </span><br><span class="line">	    sem_wait(&amp;sem_full);<span class="comment">//full--</span></span><br><span class="line">    	sem_wait(&amp;sem_mutex);<span class="comment">//枷锁</span></span><br><span class="line">   	    <span class="built_in">printf</span>(<span class="string">&quot;%d,&quot;</span>,buffer[cIndex]);</span><br><span class="line">    	cIndex=(cIndex+<span class="number">1</span>)%<span class="number">3</span>;<span class="comment">//与上面对应</span></span><br><span class="line">    	sem_post(&amp;sem_mutex);<span class="comment">//解锁</span></span><br><span class="line">    	sem_post(&amp;sem_empty);<span class="comment">//empty++</span></span><br><span class="line">	  </span><br><span class="line">	  <span class="comment">/*   end  ************************************************************** */</span> </span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125; </span><br><span class="line"></span><br></pre></td></tr></table></figure><p>参考Linux下c++的东西</p><p><a target="_blank" rel="noopener" href="https://man7.org/linux/man-pages/man3/sem_wait.3.html">https://man7.org/linux/man-pages/man3/sem_wait.3.html</a></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">sem_wait是一个函数，也是一个原子操作，它的作用是从信号量的值减去一个“1”，但它永远会先等待该信号量为一个非零值才开始做减法。也就是说，如果你对一个值为2的信号量调用sem_wait()，线程将会继续执行，将信号量的值将减到1。</span><br><span class="line">如果对一个值为0的信号量调用sem_wait()，这个函数就会原地等待直到有其它线程增加了这个值使它不再是0为止。如果有两个线程都在sem_wait()中等待同一个信号量变成非零值，那么当它被第三个线程增加 一个“1”时，等待线程中只有一个能够对信号量做减法并继续执行，另一个还将处于等待状态。sem_trywait(sem_t *sem)是函数sem_wait的非阻塞版，它直接将信号量sem减1，同时返回错误代码。</span><br><span class="line">(不得不说，百度确实蛮会复制粘贴翻译的，只不过没有那个网站格式做的好hhh)</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sem_post是给信号量的值加上一个“1”，它是一个“原子操作”－－－即同时对同一个信号量做加“1”操作的两个线程是不会冲突的；而同 时对同一个文件进行读和写操作的两个程序就有可能会引起冲突。</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sem_t  C语言中，信号量的数据类型为结构sem_t，它本质上是一个长整型的数。</span><br></pre></td></tr></table></figure><p><a target="_blank" rel="noopener" href="https://blog.51cto.com/u_13999641/4314815">https://blog.51cto.com/u_13999641/4314815</a></p><p>没看完【argc，argv是什么】</p><p>真的忘的差不多了0.0</p><p><img src="/images/loading.gif" data-original="/images/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/2.png" alt="1679026388457"></p><p><img src="/images/loading.gif" data-original="/images/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/3.png" alt="1679026432795"></p></div><footer class="post-footer"><div class="post-eof"></div></footer></article><article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN"><link itemprop="mainEntityOfPage" href="http://example.com/2023/03/16/java%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/"><span hidden itemprop="author" itemscope itemtype="http://schema.org/Person"><meta itemprop="image" content="/images/xiao.png"><meta itemprop="name" content="毛"><meta itemprop="description" content="在梦里啥都有"></span><span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization"><meta itemprop="name" content="睡觉万岁"></span><header class="post-header"><h2 class="post-title" itemprop="name headline"><a href="/2023/03/16/java%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/" class="post-title-link" itemprop="url">java数据类型</a></h2><div class="post-meta"><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-calendar"></i> </span><span class="post-meta-item-text">发表于</span> <time title="创建时间：2023-03-16 22:06:57" itemprop="dateCreated datePublished" datetime="2023-03-16T22:06:57+08:00">2023-03-16</time> </span><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-calendar-check"></i> </span><span class="post-meta-item-text">更新于</span> <time title="修改时间：2023-03-20 15:57:15" itemprop="dateModified" datetime="2023-03-20T15:57:15+08:00">2023-03-20</time> </span><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-folder"></i> </span><span class="post-meta-item-text">分类于</span> <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/2023/" itemprop="url" rel="index"><span itemprop="name">2023</span></a></span></span></div></header><div class="post-body" itemprop="articleBody"><h1 id="Java数据类型"><a href="#Java数据类型" class="headerlink" title="Java数据类型"></a>Java数据类型</h1><h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><p>Java语言是强类型语言，对于每一种数据都定义了明确的具体的数据类型，在内存中分配了不同大小的内存空间。</p><h2 id="分类"><a href="#分类" class="headerlink" title="分类"></a>分类</h2><ul><li>基本数据类型<ul><li>数值型<ul><li>整数类型(byte,short,int,long)</li><li>浮点类型(float,double)</li></ul></li><li>字符型(char)</li><li>布尔型(boolean)</li></ul></li><li>引用数据类型<ul><li>类(class)</li><li>接口(interface)</li><li>数组([])</li></ul></li></ul><h2 id="计算机存储单元"><a href="#计算机存储单元" class="headerlink" title="计算机存储单元"></a>计算机存储单元</h2><ul><li>定义：变量是内存中的小容器，用来存储数据。那么计算机内存是怎么存储数据的呢？无论是内存还是硬盘，计算机存储设备的最小信息单元叫“位（bit）”，我们又称之为“比特位”，通常用小写的字母b表示。而计算机最小的存储单元叫“字节（byte）”，通常用大写字母B表示，字节是由连续的8个位组成。</li><li>常用存储单元关系<ul><li>1B&#x3D; 8b<br>1KB &#x3D; 1024B<br>1MB &#x3D; 1024KB<br>1GB &#x3D; 1024MB<br>1TB &#x3D; 1024GB</li></ul></li></ul><h2 id="Java基本数据类型图"><a href="#Java基本数据类型图" class="headerlink" title="Java基本数据类型图"></a>Java基本数据类型图</h2><p><img src="/images/loading.gif" data-original="/images/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/9.png" alt="1678974709618"></p><ul><li><p>定义</p><ul><li>数据类型的转换是在所赋值的数值类型和被变量接收的数据类型不一致时发生的，它需要从一种数据类型转换成另一种数据类型。</li></ul></li><li><p>分类</p><ul><li><p>隐式转换</p><ul><li><p>定义</p><ul><li>在运算过程中，由于不同的数据类型会转换成同一种数据类型，所以整型、浮点型以及字符型都可以参与混合运算。自动转换的规则是从低级类型数据转换成高级类型数据。</li></ul></li><li><p>转换规则</p><ul><li>数值型数据的转换：byte→short→int→long→float→double。</li><li>字符型转换为整型：char→int。</li></ul></li><li><p>转换条件</p><ul><li>自动类型转换的实现需要同时满足两个条件：①两种数据类型彼此兼容，②目标类型的取值范围大于源数据类型（低级类型数据转换成高级类型数据）。例如 byte 类型向 short 类型转换时，由于 short 类型的取值范围较大，会自动将 byte 转换为 short 类型。</li></ul></li></ul></li><li><p>显式转换</p><ul><li>定义<ul><li>当两种数据类型不兼容，或目标类型的取值范围小于源类型时，自动转换将无法进行，这时就需要进行强制类型转换。</li><li>语法格式<ul><li>目标类型 变量名 &#x3D; (目标类型) (被转换的数据);<br>举例：int b &#x3D; (byte)(a + b);</li></ul></li><li>注意<ul><li>如果超出了被赋值的数据类型的取值范围得到的结果会与你期望的结果不同</li><li>不建议强制转换，因为会有精度的损失。</li></ul></li></ul></li></ul></li></ul></li></ul></div><footer class="post-footer"><div class="post-eof"></div></footer></article><article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN"><link itemprop="mainEntityOfPage" href="http://example.com/2023/03/15/3-15-2023/"><span hidden itemprop="author" itemscope itemtype="http://schema.org/Person"><meta itemprop="image" content="/images/xiao.png"><meta itemprop="name" content="毛"><meta itemprop="description" content="在梦里啥都有"></span><span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization"><meta itemprop="name" content="睡觉万岁"></span><header class="post-header"><h2 class="post-title" itemprop="name headline"><a href="/2023/03/15/3-15-2023/" class="post-title-link" itemprop="url">3-15-2023</a></h2><div class="post-meta"><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-calendar"></i> </span><span class="post-meta-item-text">发表于</span> <time title="创建时间：2023-03-15 22:51:14 / 修改时间：22:59:29" itemprop="dateCreated datePublished" datetime="2023-03-15T22:51:14+08:00">2023-03-15</time> </span><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-folder"></i> </span><span class="post-meta-item-text">分类于</span> <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/2023/" itemprop="url" rel="index"><span itemprop="name">2023</span></a></span></span></div></header><div class="post-body" itemprop="articleBody"><h3 id="三月中自我崩溃"><a href="#三月中自我崩溃" class="headerlink" title="三月中自我崩溃"></a>三月中自我崩溃</h3><div class="post-button"><a class="btn" href="/2023/03/15/3-15-2023/#more" rel="contents">阅读全文 &raquo;</a></div></div><footer class="post-footer"><div class="post-eof"></div></footer></article><article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN"><link itemprop="mainEntityOfPage" href="http://example.com/2023/03/15/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8Fhomework(1)/"><span hidden itemprop="author" itemscope itemtype="http://schema.org/Person"><meta itemprop="image" content="/images/xiao.png"><meta itemprop="name" content="毛"><meta itemprop="description" content="在梦里啥都有"></span><span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization"><meta itemprop="name" content="睡觉万岁"></span><header class="post-header"><h2 class="post-title" itemprop="name headline"><a href="/2023/03/15/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8Fhomework(1)/" class="post-title-link" itemprop="url">设计模式homework(1)</a></h2><div class="post-meta"><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-calendar"></i> </span><span class="post-meta-item-text">发表于</span> <time title="创建时间：2023-03-15 17:56:02" itemprop="dateCreated datePublished" datetime="2023-03-15T17:56:02+08:00">2023-03-15</time> </span><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-calendar-check"></i> </span><span class="post-meta-item-text">更新于</span> <time title="修改时间：2023-03-20 15:53:52" itemprop="dateModified" datetime="2023-03-20T15:53:52+08:00">2023-03-20</time> </span><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-folder"></i> </span><span class="post-meta-item-text">分类于</span> <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/2023/" itemprop="url" rel="index"><span itemprop="name">2023</span></a></span></span></div></header><div class="post-body" itemprop="articleBody"><h2 id="2023-Week1-Exp-Upload"><a href="#2023-Week1-Exp-Upload" class="headerlink" title="2023_Week1_Exp_Upload"></a>2023_Week1_Exp_Upload</h2><h3 id="1-简答题-用-UMLet-工具对下面代码绘制类图"><a href="#1-简答题-用-UMLet-工具对下面代码绘制类图" class="headerlink" title="1. (简答题)用 UMLet 工具对下面代码绘制类图"></a>1. (简答题)用 UMLet 工具对下面代码绘制类图</h3><p><img src="/images/loading.gif" data-original="/images/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/10.png" alt="img"></p><p><img src="/images/loading.gif" data-original="/images/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/5.png" alt="img"></p><p><img src="/images/loading.gif" data-original="/images/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/11.png" alt="1678972004441"></p><p><img src="/images/loading.gif" data-original="/images/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/6.png" alt="1678972695825"></p><p>【关联关系】：是一种拥有的关系，它使一个类知道另一个类的属性和方法</p><p>【代码体现】：成员变量</p><p>【箭头及指向】：带普通箭头的实心线，指向被拥有者</p><p>1.上图中，课程与学生是双向关联，课程有多名学生，学生也可能有多个课程。</p><p>2.但学生与成绩间的关系为单向关联，一名学生可能要有多门成绩，成绩有学生信息，但学生类不拥有成绩变量</p><p><img src="/images/loading.gif" data-original="/images/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/7.png" alt="1678972739648"></p><p>3.【组合关系】：是整体与部分的关系，但部分不能离开整体而单独存在。如公司和部门是整体和部分的关系，没有公司就不存在部门。</p><p>组合关系是关联关系的一种，是比聚合关系还要强的关系，它要求普通的聚合关系中代表整体的对象负责代表部分的对象的生命周期。</p><p>【代码体现】：成员变量</p><p>【箭头及指向】：带实心菱形的实线，菱形指向整体</p><p>上图中课程为整体，成绩没有课程就不存在。</p><p><img src="/images/loading.gif" data-original="/images/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/8.png" alt="1678973083372"></p><p>4.【依赖关系】：是一种使用的关系，即一个类的实现需要另一个类的协助，所以要尽量不使用双向的互相依赖.</p><p>【代码表现】：局部变量、方法的参数或者对静态方法的调用</p><p>【箭头及指向】：带箭头的虚线，指向被使用者</p><p>一个宿舍类的实现需要另一个学生类的协助，宿舍是被使用者</p></div><footer class="post-footer"><div class="post-eof"></div></footer></article><article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN"><link itemprop="mainEntityOfPage" href="http://example.com/2023/03/15/UML%E7%B1%BB%E5%9B%BE&&%E5%8E%9F%E5%88%99%E6%A6%82%E8%BF%B0/"><span hidden itemprop="author" itemscope itemtype="http://schema.org/Person"><meta itemprop="image" content="/images/xiao.png"><meta itemprop="name" content="毛"><meta itemprop="description" content="在梦里啥都有"></span><span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization"><meta itemprop="name" content="睡觉万岁"></span><header class="post-header"><h2 class="post-title" itemprop="name headline"><a href="/2023/03/15/UML%E7%B1%BB%E5%9B%BE&&%E5%8E%9F%E5%88%99%E6%A6%82%E8%BF%B0/" class="post-title-link" itemprop="url">UML&&面向对象设计原则</a></h2><div class="post-meta"><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-calendar"></i> </span><span class="post-meta-item-text">发表于</span> <time title="创建时间：2023-03-15 17:32:42 / 修改时间：17:33:49" itemprop="dateCreated datePublished" datetime="2023-03-15T17:32:42+08:00">2023-03-15</time> </span><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-folder"></i> </span><span class="post-meta-item-text">分类于</span> <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/2023/" itemprop="url" rel="index"><span itemprop="name">2023</span></a></span></span></div></header><div class="post-body" itemprop="articleBody"><h3 id="一、单一职责原则"><a href="#一、单一职责原则" class="headerlink" title="一、单一职责原则**"></a>一、单一职责原则**</h3><p>就一个类而言，应该仅有一个引起它变化的原因。</p><p>如果一个类承担的职责过多，就等于把这些职责耦合在一起，一个职责的变化可能会削弱或者抑制这个类完成其他职责的能力。这种耦合会导致脆弱他的设计，当变化发生时，设计会遭受到意想不到的破坏；软件设计真正要做的许多内容就是发现职责并把那些职责相互分离。</p><h3 id="二、开放-封闭原则"><a href="#二、开放-封闭原则" class="headerlink" title="二、开放-封闭原则"></a><strong>二、开放-封闭原则</strong></h3><p>软件实体应该可以扩展，但不可修改。该原则是面向对象设计的核心所在，遵循这个原则可以带来面向对象技术所声称的可维护、可扩展、可复用、灵活性好。</p><p>设计人员必须对于他设计的模块应该对哪种变化封闭做出选择，必须先猜测出最有可能发生的变化种类，然后构造抽象来隔离那些变化。最初编写程序时假设变化不会发生，当变化发生时，就创建抽象来隔离以后发生的同类变化，拒绝不成熟的抽象。</p><h3 id="三、里氏代换原则"><a href="#三、里氏代换原则" class="headerlink" title="三、里氏代换原则"></a><strong>三、里氏代换原则</strong></h3><p>子类型必须能够替换掉它们的父类型。由于子类型的可替换性才使得使用父类类型的模块在无需修改的情况下就可以扩展。</p><h3 id="四、依赖倒转原则"><a href="#四、依赖倒转原则" class="headerlink" title="四、依赖倒转原则"></a><strong>四、依赖倒转原则</strong></h3><p>高层模块不应该依赖低层模块，两个都应该依赖抽象；抽象不应该依赖细节，细节应该依赖抽象。</p><p>要针对接口编程，不要针对实现编程。该原则可以说是面向对象设计的标志，编写时考虑的是如何对抽象编程而不是针对细节编程，即程序中所有的依赖关系都是终止于抽象类或者接口。</p><h3 id="五、迪迷特原则（最少知识原则）"><a href="#五、迪迷特原则（最少知识原则）" class="headerlink" title="五、迪迷特原则（最少知识原则）"></a><strong>五、迪迷特原则（最少知识原则）</strong></h3><p>如果两个类不必彼此直接通信，那么这两个类就不应当发生直接的相互作用；如果其中一个类需要调用另一个类的某一个方法的话，可以通过第三者转发这个调用。</p><p>该原则其根本思想，是强调了类之间的松耦合；类之间的耦合越弱，越利于复用，一个处在弱耦合的类被修改，不会对有关系的类造成波及。在类的结构设计上，每一个类都应当尽量降低成员的访问权限。</p><h3 id="六、合成-x2F-聚合复用原则"><a href="#六、合成-x2F-聚合复用原则" class="headerlink" title="六、合成&#x2F;聚合复用原则"></a><strong>六、合成&#x2F;聚合复用原则</strong></h3><p>尽量使用合成&#x2F;聚合，尽量不要使用类继承。</p><p>聚合表示一种弱的“拥有”关系，体现的是A对象可以包含B对象，但B对象不是A对象的一部分；合成则是一种强的“拥有”关系，体现了严格的部分和整体的关系，部分和整体的生命周期一样。</p><p>优先使用对象的合成&#x2F;聚合将有助于你保持每个类被封装，并被击中在单个任务上，这样类和类继承层次会保持较小规模，并且不太可能增长为不可控制的庞然大物。</p><h3 id="七、UML例图"><a href="#七、UML例图" class="headerlink" title="七、UML例图"></a><strong>七、UML例图</strong></h3><p>‘+’表示public，‘-’表示private，‘#’表示protected；</p><p>接口顶端有《interface》显示，只有两行；同时另一个表示方法为棒棒糖表示法；</p><p>聚合表示一种弱的’拥有’关系，体现的是A对象可以包含B对象，但B对象不是A对象的一部分；</p><p>合成是一种强的’拥有’关系，体现了严格的部分和整体的关系，部分和整体的生命周期一样；</p><p><img src="/images/loading.gif" data-original="https://pic2.zhimg.com/80/v2-2a5e007cbbf020df430358e56cc37501_1440w.webp" alt="img"></p><p>在UML类图中，常见的有以下几种关系: 泛化（Generalization）, 实现（Realization），关联（Association)，聚合（Aggregation），组合(Composition)，依赖(Dependency)</p><h3 id="1-泛化（Generalization）"><a href="#1-泛化（Generalization）" class="headerlink" title="1. 泛化（Generalization）"></a><strong>1. 泛化（Generalization）</strong></h3><p>【泛化关系】：是一种继承关系，表示一般与特殊的关系，它指定了子类如何特化父类的所有特征和行为。例如：老虎是动物的一种，即有老虎的特性也有动物的共性。</p><p>【箭头指向】：带三角箭头的实线，箭头指向父类</p><p><img src="/images/loading.gif" data-original="https://pic4.zhimg.com/80/v2-2111f42427a07f8270f76c1e41b91127_1440w.webp" alt="img"></p><h3 id="2-实现（Realization）"><a href="#2-实现（Realization）" class="headerlink" title="2. 实现（Realization）"></a><strong>2. 实现（Realization）</strong></h3><p>【实现关系】：是一种类与接口的关系，表示类是接口所有特征和行为的实现.</p><p>【箭头指向】：带三角箭头的虚线，箭头指向接口</p><p><img src="/images/loading.gif" data-original="https://pic2.zhimg.com/80/v2-b02e9f6289d1f6ba0e5511e66315368d_1440w.webp" alt="img"></p><h3 id="3-关联（Association"><a href="#3-关联（Association" class="headerlink" title="3. 关联（Association)"></a><strong>3. 关联（Association)</strong></h3><p>【关联关系】：是一种拥有的关系，它使一个类知道另一个类的属性和方法；如：老师与学生，丈夫与妻子关联可以是双向的，也可以是单向的。双向的关联可以有两个箭头或者没有箭头，单向的关联有一个箭头。</p><p>【代码体现】：成员变量</p><p>【箭头及指向】：带普通箭头的实心线，指向被拥有者</p><p><img src="/images/loading.gif" data-original="https://pic3.zhimg.com/80/v2-b8a99595152fe8f15587f87e1e15e4ae_1440w.webp" alt="img"></p><p>上图中，老师与学生是双向关联，老师有多名学生，学生也可能有多名老师。但学生与某课程间的关系为单向关联，一名学生可能要上多门课程，课程是个抽象的东西他不拥有学生。</p><p>下图为自身关联：</p><p><img src="/images/loading.gif" data-original="https://pic1.zhimg.com/80/v2-07a309a7b5e45179fccbd48f1c76b16c_1440w.webp" alt="img"></p><h3 id="4-聚合（Aggregation）"><a href="#4-聚合（Aggregation）" class="headerlink" title="4. 聚合（Aggregation）"></a><strong>4. 聚合（Aggregation）</strong></h3><p>【聚合关系】：是整体与部分的关系，且部分可以离开整体而单独存在。如车和轮胎是整体和部分的关系，轮胎离开车仍然可以存在。</p><p>聚合关系是关联关系的一种，是强的关联关系；关联和聚合在语法上无法区分，必须考察具体的逻辑关系。</p><p>【代码体现】：成员变量</p><p>【箭头及指向】：带空心菱形的实心线，菱形指向整体</p><p><img src="/images/loading.gif" data-original="https://pic3.zhimg.com/80/v2-44cad250f321a597839e05c437e0112a_1440w.webp" alt="img"></p><h3 id="5-组合-Composition"><a href="#5-组合-Composition" class="headerlink" title="5. 组合(Composition)"></a><strong>5. 组合(Composition)</strong></h3><p>【组合关系】：是整体与部分的关系，但部分不能离开整体而单独存在。如公司和部门是整体和部分的关系，没有公司就不存在部门。</p><p>组合关系是关联关系的一种，是比聚合关系还要强的关系，它要求普通的聚合关系中代表整体的对象负责代表部分的对象的生命周期。</p><p>【代码体现】：成员变量</p><p>【箭头及指向】：带实心菱形的实线，菱形指向整体</p><p><img src="/images/loading.gif" data-original="https://pic3.zhimg.com/80/v2-7f0849545b8f89914f327c63677587d6_1440w.webp" alt="img"></p><h3 id="6-依赖-Dependency"><a href="#6-依赖-Dependency" class="headerlink" title="6. 依赖(Dependency)"></a><strong>6. 依赖(Dependency)</strong></h3><p>【依赖关系】：是一种使用的关系，即一个类的实现需要另一个类的协助，所以要尽量不使用双向的互相依赖.</p><p>【代码表现】：局部变量、方法的参数或者对静态方法的调用</p><p>【箭头及指向】：带箭头的虚线，指向被使用者</p><p><img src="/images/loading.gif" data-original="https://pic3.zhimg.com/80/v2-6651fe1f4705d9bd32cedda210ace8b6_1440w.webp" alt="img"></p><p>各种关系的强弱顺序：</p><blockquote><p>泛化 &#x3D; 实现 &gt; 组合 &gt; 聚合 &gt; 关联 &gt; 依赖</p></blockquote><p>下面这张UML图，比较形象地展示了各种类图关系：</p><p><img src="/images/loading.gif" data-original="https://pic1.zhimg.com/80/v2-064242574ba428a2330bf41e069a0f88_1440w.webp" alt="img"></p><h2 id="创建型"><a href="#创建型" class="headerlink" title="创建型"></a>创建型</h2><h3 id="1-Factory-Method（工厂方法）"><a href="#1-Factory-Method（工厂方法）" class="headerlink" title="1. Factory Method（工厂方法）"></a><strong>1. Factory Method（工厂方法）</strong></h3><p><img src="/images/loading.gif" data-original="https://pic2.zhimg.com/80/v2-8f3b98dadbc5d9cf9469dcc99ee20991_1440w.webp" alt="img"></p><p><strong>意图：</strong></p><p>定义一个用于创建对象的接口，让子类决定实例化哪一个类。Factory Method 使一个类的实例化延迟到其子类。</p><p><strong>适用性：</strong></p><p>当一个类不知道它所必须创建的对象的类的时候。</p><p>当一个类希望由它的子类来指定它所创建的对象的时候。</p><p>当类将创建对象的职责委托给多个帮助子类中的某一个，并且你希望将哪一个帮助子类是代理者这一信息局部化的时候。</p><p>详解：<a href="https://link.zhihu.com/?target=http://mp.weixin.qq.com/s?__biz=MzI4Njc5NjM1NQ==&mid=2247487170&idx=2&sn=34b135090c064c1ca202d629a4beab52&chksm=ebd631eedca1b8f85e444f7544c2cbe696b253fe3916f17dbcfbab49b6b74653126c230fdc39&scene=21%23wechat_redirect">设计模式是什么鬼（工厂方法）</a></p><h3 id="2-Abstract-Factory（抽象工厂）"><a href="#2-Abstract-Factory（抽象工厂）" class="headerlink" title="2. Abstract Factory（抽象工厂）"></a><strong>2. Abstract Factory（抽象工厂）</strong></h3><p><img src="/images/loading.gif" data-original="https://pic2.zhimg.com/80/v2-1436a190dde8067b8d461ace42c7e4a9_1440w.webp" alt="img"></p><p><strong>意图：</strong></p><p>提供一个创建一系列相关或相互依赖对象的接口，而无需指定它们具体的类。</p><p><strong>适用性：</strong></p><p>一个系统要独立于它的产品的创建、组合和表示时。</p><p>一个系统要由多个产品系列中的一个来配置时。</p><p>当你要强调一系列相关的产品对象的设计以便进行联合使用时。</p><p>当你提供一个产品类库，而只想显示它们的接口而不是实现时。</p><p>详解：<a href="https://link.zhihu.com/?target=http://mp.weixin.qq.com/s?__biz=MzI4Njc5NjM1NQ==&mid=2247487234&idx=2&sn=1dca994fb989ca55ec311cae187805f2&chksm=ebd6302edca1b938f0b8107d129652d9bc2e1e72d37ce1d6dfd188294a93a62cdbec5ddd91bb&scene=21%23wechat_redirect">设计模式是什么鬼（抽象工厂）</a></p><h3 id="3-Builder（建造者）"><a href="#3-Builder（建造者）" class="headerlink" title="3. Builder（建造者）"></a><strong>3. Builder（建造者）</strong></h3><p><img src="/images/loading.gif" data-original="https://pic3.zhimg.com/80/v2-48835219bebcd3b23e9548ae17f80f86_1440w.webp" alt="img"></p><p><strong>意图：</strong></p><p>将一个复杂对象的构建与它的表示分离，使得同样的构建过程可以创建不同的表示。</p><p><strong>适用性：</strong></p><p>当创建复杂对象的算法应该独立于该对象的组成部分以及它们的装配方式时。</p><p>当构造过程必须允许被构造的对象有不同的表示时。</p><p>详解：<a href="https://link.zhihu.com/?target=http://mp.weixin.qq.com/s?__biz=MzI4Njc5NjM1NQ==&mid=2247487258&idx=2&sn=cee8a48b247ec1fb2fb1a45396c0a04e&chksm=ebd63036dca1b920246061b0287c6f29040a338c46094c8b8eeff03ea068de03180fa48aa2b2&scene=21%23wechat_redirect">设计模式是什么鬼（建造者）</a></p><h3 id="4-Prototype（原型）"><a href="#4-Prototype（原型）" class="headerlink" title="4. Prototype（原型）"></a><strong>4. Prototype（原型）</strong></h3><p><img src="/images/loading.gif" data-original="https://pic1.zhimg.com/80/v2-cbd77b435c3c2c6624413b698a2ae4f8_1440w.webp" alt="img"></p><p><strong>意图：</strong></p><p>用原型实例指定创建对象的种类，并且通过拷贝这些原型创建新的对象。</p><p><strong>适用性：</strong></p><p>当要实例化的类是在运行时刻指定时，例如，通过动态装载；或者</p><p>为了避免创建一个与产品类层次平行的工厂类层次时；或者</p><p>当一个类的实例只能有几个不同状态组合中的一种时。建立相应数目的原型并克隆它们可能比每次用合适的状态手工实例化该类更方便一些。</p><p>详解：<a href="https://link.zhihu.com/?target=http://mp.weixin.qq.com/s?__biz=MzI4Njc5NjM1NQ==&mid=2247485830&idx=1&sn=a3164e131d4ed08cc6cfcdaec4425ff4&chksm=ebd636aadca1bfbcd1df059f9795350157c600f37238ba2f334e03064e25e8359b0acfc177b4&scene=21%23wechat_redirect">设计模式是什么鬼（原型）</a></p><h3 id="5-Singleton（单例）"><a href="#5-Singleton（单例）" class="headerlink" title="5. Singleton（单例）"></a><strong>5. Singleton（单例）</strong></h3><p><img src="/images/loading.gif" data-original="https://pic4.zhimg.com/80/v2-4fd103fadf7d58b90c355bf91139e307_1440w.webp" alt="img"></p><p><strong>意图：</strong></p><p>保证一个类仅有一个实例，并提供一个访问它的全局访问点。</p><p><strong>适用性：</strong></p><p>当类只能有一个实例而且客户可以从一个众所周知的访问点访问它时。</p><p>当这个唯一实例应该是通过子类化可扩展的，并且客户应该无需更改代码就能使用一个扩展的实例时。</p><p>详解：<a href="https://link.zhihu.com/?target=http://mp.weixin.qq.com/s?__biz=MzI4Njc5NjM1NQ==&mid=2247485826&idx=2&sn=e21d6188ea07a992f1eb9a6671ae7485&chksm=ebd636aedca1bfb8ff0ad69343ab40e87cd65ec41e2dfc54d761e97e9058effe6bd2eac28486&scene=21%23wechat_redirect">设计模式是什么鬼（单例）</a></p><h2 id="结构型"><a href="#结构型" class="headerlink" title="结构型"></a>结构型</h2><h3 id="6-Adapter-Class-x2F-Object（适配器）"><a href="#6-Adapter-Class-x2F-Object（适配器）" class="headerlink" title="6. Adapter Class&#x2F;Object（适配器）"></a><strong>6. Adapter Class&#x2F;Object（适配器）</strong></h3><p><img src="/images/loading.gif" data-original="https://pic3.zhimg.com/80/v2-5c8c31d37a74ba8901028488fcada606_1440w.webp" alt="img"></p><p><strong>意图：</strong></p><p>将一个类的接口转换成客户希望的另外一个接口。Adapter 模式使得原本由于接口不兼容而不能一起工作的那些类可以一起工作。</p><p><strong>适用性：</strong></p><p>你想使用一个已经存在的类，而它的接口不符合你的需求。</p><p>你想创建一个可以复用的类，该类可以与其他不相关的类或不可预见的类（即那些接口可能不一定兼容的类）协同工作。</p><p>（仅适用于对象Adapter ）你想使用一些已经存在的子类，但是不可能对每一个都进行子类化以匹配它们的接口。对象适配器可以适配它的父类接口。</p><p>详解：<a href="https://link.zhihu.com/?target=http://mp.weixin.qq.com/s?__biz=MzI4Njc5NjM1NQ==&mid=2247485849&idx=2&sn=79922e3fe8278d01e3fab1870ed824bc&chksm=ebd636b5dca1bfa3c83c3d2d740e25553bc1ba686b2ea6de46acc14d9ea547eb636e24ac7db0&scene=21%23wechat_redirect">设计模式是什么鬼（适配器）</a></p><h3 id="7-Bridge（桥接）"><a href="#7-Bridge（桥接）" class="headerlink" title="7. Bridge（桥接）"></a><strong>7. Bridge（桥接）</strong></h3><p><img src="/images/loading.gif" data-original="https://pic2.zhimg.com/80/v2-e36ccde15c056c60e0a2b4e719c3afa9_1440w.webp" alt="img"></p><p><strong>意图：</strong></p><p>将抽象部分与它的实现部分分离，使它们都可以独立地变化。</p><p><strong>适用性：</strong></p><p>你不希望在抽象和它的实现部分之间有一个固定的绑定关系。例如这种情况可能是因为，在程序运行时刻实现部分应可以被选择或者切换。</p><p>类的抽象以及它的实现都应该可以通过生成子类的方法加以扩充。这时Bridge 模式使你可以对不同的抽象接口和实现部分进行组合，并分别对它们进行扩充。</p><p>对一个抽象的实现部分的修改应对客户不产生影响，即客户的代码不必重新编译。</p><p>（C++）你想对客户完全隐藏抽象的实现部分。在C++中，类的表示在类接口中是可见的。</p><p>有许多类要生成。这样一种类层次结构说明你必须将一个对象分解成两个部分。Rumbaugh 称这种类层次结构为“嵌套的普化”（nested generalizations ）。</p><p>你想在多个对象间共享实现（可能使用引用计数），但同时要求客户并不知道这一点。一个简单的例子便是Coplien 的String 类[ Cop92 ]，在这个类中多个对象可以共享同一个字符串表示（StringRep ）。</p><p>详解：<a href="https://link.zhihu.com/?target=http://mp.weixin.qq.com/s?__biz=MzI4Njc5NjM1NQ==&mid=2247487099&idx=2&sn=457440878204cf39ade08d1643aa6375&chksm=ebd63157dca1b841e4a09c32e7ed7bd28988cc54d08d4e03eb7bbc25dc50c1acd8938fae155c&scene=21%23wechat_redirect">设计模式是什么鬼（桥接）</a></p><h3 id="8-Composite（组合）"><a href="#8-Composite（组合）" class="headerlink" title="8. Composite（组合）"></a><strong>8. Composite（组合）</strong></h3><p><img src="/images/loading.gif" data-original="https://pic4.zhimg.com/80/v2-75d82d38597a3c79e0c19665bc816487_1440w.webp" alt="img"></p><p><strong>意图：</strong></p><p>将对象组合成树形结构以表示“部分-整体”的层次结构。C o m p o s i t e 使得用户对单个对象和组合对象的使用具有一致性。</p><p><strong>适用性：</strong></p><p>你想表示对象的部分-整体层次结构。</p><p>你希望用户忽略组合对象与单个对象的不同，用户将统一地使用组合结构中的所有对象。</p><p>详解：<a href="https://link.zhihu.com/?target=http://mp.weixin.qq.com/s?__biz=MzI4Njc5NjM1NQ==&mid=2247486525&idx=2&sn=a2059bcf272a82f5a98cbd9f22349a96&chksm=ebd63311dca1ba071022d396a12eca74d58be8164713fe90f42aa1a7376db77bd6d97755bde8&scene=21%23wechat_redirect">设计模式是什么鬼（组合）</a></p><h3 id="9-Decorator（装饰）"><a href="#9-Decorator（装饰）" class="headerlink" title="9. Decorator（装饰）"></a><strong>9. Decorator（装饰）</strong></h3><p><img src="/images/loading.gif" data-original="https://pic3.zhimg.com/80/v2-20f4f4c4eb272b615394cea73450ca76_1440w.webp" alt="img"></p><p><strong>意图：</strong></p><p>动态地给一个对象添加一些额外的职责。就增加功能来说，Decorator 模式相比生成子类更为灵活。</p><p><strong>适用性：</strong></p><p>在不影响其他对象的情况下，以动态、透明的方式给单个对象添加职责。</p><p>处理那些可以撤消的职责。</p><p>当不能采用生成子类的方法进行扩充时。一种情况是，可能有大量独立的扩展，为支持每一种组合将产生大量的子类，使得子类数目呈爆炸性增长。另一种情况可能是因为类定义被隐藏，或类定义不能用于生成子类。</p><p>详解：<a href="https://link.zhihu.com/?target=http://mp.weixin.qq.com/s?__biz=MzI4Njc5NjM1NQ==&mid=2247486377&idx=2&sn=e88370d32c36b19ac89189341cbaf03b&chksm=ebd63485dca1bd93fd46ce901b8ed5adaa0f1f5db15b8a19902bef66a05bd38ed420e26f7f5e&scene=21%23wechat_redirect">设计模式是什么鬼（装饰）</a></p><h3 id="10-Facade（外观）"><a href="#10-Facade（外观）" class="headerlink" title="10. Facade（外观）"></a><strong>10. Facade（外观）</strong></h3><p><img src="/images/loading.gif" data-original="https://pic2.zhimg.com/80/v2-aa585c0b4be937d5a1ee0d9fb5683aa1_1440w.webp" alt="img"></p><p><strong>意图：</strong></p><p>为子系统中的一组接口提供一个一致的界面，Facade模式定义了一个高层接口，这个接口使得这一子系统更加容易使用。</p><p><strong>适用性：</strong></p><p>当你要为一个复杂子系统提供一个简单接口时。子系统往往因为不断演化而变得越来越复杂。大多数模式使用时都会产生更多更小的类。这使得子系统更具可重用性，也更容易对子系统进行定制，但这也给那些不需要定制子系统的用户带来一些使用上的困难。Facade 可以提供一个简单的缺省视图，这一视图对大多数用户来说已经足够，而那些需要更多的可定制性的用户可以越过facade层。</p><p>客户程序与抽象类的实现部分之间存在着很大的依赖性。引入facade 将这个子系统与客户以及其他的子系统分离，可以提高子系统的独立性和可移植性。</p><p>当你需要构建一个层次结构的子系统时，使用facade模式定义子系统中每层的入口点。如果子系统之间是相互依赖的，你可以让它们仅通过facade进行通讯，从而简化了它们之间的依赖关系。</p><p>详解：<a href="https://link.zhihu.com/?target=http://mp.weixin.qq.com/s?__biz=MzI4Njc5NjM1NQ==&mid=2247486253&idx=2&sn=60b15886f8230ee17067d48d8a273329&chksm=ebd63401dca1bd17a26acf0f139f01feebde6071646bfad60c2ca2773fd1f593955aa2efe992&scene=21%23wechat_redirect">设计模式是什么鬼（门面）</a></p><h3 id="11-Flyweight（享元）"><a href="#11-Flyweight（享元）" class="headerlink" title="11. Flyweight（享元）"></a><strong>11. Flyweight（享元）</strong></h3><p><img src="/images/loading.gif" data-original="https://pic4.zhimg.com/80/v2-2753d0d9328f08928db006313e08bd43_1440w.webp" alt="img"></p><p><strong>意图：</strong></p><p>运用共享技术有效地支持大量细粒度的对象。</p><p><strong>适用性：</strong></p><p>一个应用程序使用了大量的对象。</p><p>完全由于使用大量的对象，造成很大的存储开销。</p><p>对象的大多数状态都可变为外部状态。</p><p>如果删除对象的外部状态，那么可以用相对较少的共享对象取代很多组对象。</p><p>应用程序不依赖于对象标识。由于Flyweight 对象可以被共享，对于概念上明显有别的对象，标识测试将返回真值。</p><p>详解：<a href="https://link.zhihu.com/?target=http://mp.weixin.qq.com/s?__biz=MzI4Njc5NjM1NQ==&mid=2247486986&idx=2&sn=0956b282423ac82a64bad9d4b75bd63d&chksm=ebd63126dca1b830bdb1464ec0d2957a63e19956e657673af192d514088a7bef569741656d42&scene=21%23wechat_redirect">设计模式是什么鬼（享元）</a></p><h3 id="12-Proxy（代理）"><a href="#12-Proxy（代理）" class="headerlink" title="12. Proxy（代理）"></a><strong>12. Proxy（代理）</strong></h3><p><img src="/images/loading.gif" data-original="https://pic4.zhimg.com/80/v2-6e64b84a618958acae36cb537c70c583_1440w.webp" alt="img"></p><p><strong>意图：</strong></p><p>为其他对象提供一种代理以控制对这个对象的访问。</p><p><strong>适用性：</strong></p><p>在需要用比较通用和复杂的对象指针代替简单的指针的时候，使用Proxy模式。下面是一 些可以使用Proxy 模式常见情况：</p><ul><li>远程代理（Remote Proxy ）为一个对象在不同的地址空间提供局部代表。NEXTSTEP[Add94] 使用NXProxy 类实现了这一目的。Coplien[Cop92] 称这种代理为“大使” （Ambassador ）。</li><li>虚代理（Virtual Proxy ）根据需要创建开销很大的对象。在动机一节描述的ImageProxy 就是这样一种代理的例子。</li><li>保护代理（Protection Proxy ）控制对原始对象的访问。保护代理用于对象应该有不同 的访问权限的时候。例如，在Choices 操作系统[ CIRM93]中KemelProxies为操作系统对象提供 了访问保护。</li><li>智能指引（Smart Reference ）取代了简单的指针，它在访问对象时执行一些附加操作。它的典型用途包括：</li></ul><p>对指向实际对象的引用计数，这样当该对象没有引用时，可以自动释放它(也称为SmartPointers[Ede92 ] )。</p><p>当第一次引用一个持久对象时，将它装入内存。</p><p>在访问一个实际对象前，检查是否已经锁定了它，以确保其他对象不能改变它。</p><p>详解：<a href="https://link.zhihu.com/?target=http://mp.weixin.qq.com/s?__biz=MzI4Njc5NjM1NQ==&mid=2247487054&idx=2&sn=489695986c038525e25c017c217b72fb&chksm=ebd63162dca1b874edcaa30680e1da4d3a02c9b0011cb5c60c22d2b9ebea9169022813810bd5&scene=21%23wechat_redirect">设计模式是什么鬼（代理）</a></p><h2 id="行为型"><a href="#行为型" class="headerlink" title="行为型"></a>行为型</h2><h3 id="13-Interpreter（解释器）"><a href="#13-Interpreter（解释器）" class="headerlink" title="13. Interpreter（解释器）"></a><strong>13. Interpreter（解释器）</strong></h3><p><img src="/images/loading.gif" data-original="https://pic4.zhimg.com/80/v2-1c7090078bc60481325e481502a7074f_1440w.webp" alt="img"></p><p><strong>意图：</strong></p><p>给定一个语言，定义它的文法的一种表示，并定义一个解释器，这个解释器使用该表示来解释语言中的句子。</p><p><strong>适用性：</strong></p><p>当有一个语言需要解释执行, 并且你可将该语言中的句子表示为一个抽象语法树时，可使用解释器模式。而当存在以下情况时该模式效果最好：</p><p>该文法简单对于复杂的文法, 文法的类层次变得庞大而无法管理。此时语法分析程序生成器这样的工具是更好的选择。它们无需构建抽象语法树即可解释表达式, 这样可以节省空间而且还可能节省时间。</p><p>效率不是一个关键问题最高效的解释器通常不是通过直接解释语法分析树实现的, 而是首先将它们转换成另一种形式。例如，正则表达式通常被转换成状态机。但即使在这种情况下, 转换器仍可用解释器模式实现, 该模式仍是有用的。</p><p>详解：<a href="https://link.zhihu.com/?target=http://mp.weixin.qq.com/s?__biz=MzI4Njc5NjM1NQ==&mid=2247487345&idx=2&sn=1ee3aa645b265c55de74a1d2567c7e89&chksm=ebd6305ddca1b94b7ac2b713c5d439c031765e24315653ae2f728a3de3f10d03ba554c1ab872&scene=21%23wechat_redirect">设计模式是什么鬼（解释器）</a></p><h3 id="14-Template-Method（模板方法）"><a href="#14-Template-Method（模板方法）" class="headerlink" title="14. Template Method（模板方法）"></a><strong>14. Template Method（模板方法）</strong></h3><p><img src="/images/loading.gif" data-original="https://pic1.zhimg.com/80/v2-a232d4224c19e0c44d0f5a70a1d74728_1440w.webp" alt="img"></p><p><strong>意图：</strong></p><p>定义一个操作中的算法的骨架，而将一些步骤延迟到子类中。TemplateMethod 使得子类可以不改变一个算法的结构即可重定义该算法的某些特定步骤。</p><p><strong>适用性：</strong></p><p>一次性实现一个算法的不变的部分，并将可变的行为留给子类来实现。</p><p>各子类中公共的行为应被提取出来并集中到一个公共父类中以避免代码重复。这是Opdyke 和Johnson 所描述过的“重分解以一般化”的一个很好的例子[ OJ93 ]。首先识别现有代码中的不同之处，并且将不同之处分离为新的操作。最后，用一个调用这些新的操作的模板方法来替换这些不同的代码。</p><p>控制子类扩展。模板方法只在特定点调用“hook ”操作（参见效果一节），这样就只允许在这些点进行扩展。</p><p>详解：<a href="https://link.zhihu.com/?target=http://mp.weixin.qq.com/s?__biz=MzI4Njc5NjM1NQ==&mid=2247486148&idx=1&sn=601fa38aee0aa27137341ce9a2624fec&chksm=ebd635e8dca1bcfe8da575478244414d13620010cd0d9823f423af8d2457ad1bb65a17d6a940&scene=21%23wechat_redirect">设计模式是什么鬼（模板方法）</a></p><h3 id="15-Chain-of-Responsibility（责任链）"><a href="#15-Chain-of-Responsibility（责任链）" class="headerlink" title="15. Chain of Responsibility（责任链）"></a><strong>15. Chain of Responsibility（责任链）</strong></h3><p><img src="/images/loading.gif" data-original="https://pic4.zhimg.com/80/v2-84c0347f8d4e33bde0a1eaaaebbd347f_1440w.webp" alt="img"></p><p><strong>意图：</strong></p><p>使多个对象都有机会处理请求，从而避免请求的发送者和接收者之间的耦合关系。将这些对象连成一条链，并沿着这条链传递该请求，直到有一个对象处理它为止。</p><p><strong>适用性：</strong></p><p>有多个的对象可以处理一个请求，哪个对象处理该请求运行时刻自动确定。</p><p>你想在不明确指定接收者的情况下，向多个对象中的一个提交一个请求。</p><p>可处理一个请求的对象集合应被动态指定。</p><p>详解：<a href="https://link.zhihu.com/?target=http://mp.weixin.qq.com/s?__biz=MzI4Njc5NjM1NQ==&mid=2247486851&idx=2&sn=e5eb6b74336f0148e8c3e3043e613e87&chksm=ebd632afdca1bbb9d8a54555ed67e248fed58ebc1991cae9961c4d22e226b04369295cc49877&scene=21%23wechat_redirect">设计模式是什么鬼（责任链）</a></p><h3 id="16-Command（命令）"><a href="#16-Command（命令）" class="headerlink" title="16. Command（命令）"></a><strong>16. Command（命令）</strong></h3><p><img src="/images/loading.gif" data-original="https://pic3.zhimg.com/80/v2-eeb21ebeb421049703255e00065feb26_1440w.webp" alt="img"></p><p><strong>意图：</strong></p><p>将一个请求封装为一个对象，从而使你可用不同的请求对客户进行参数化；对请求排队或记录请求日志，以及支持可撤消的操作。</p><p><strong>适用性：</strong></p><p>抽象出待执行的动作以参数化某对象，你可用过程语言中的回调（call back）函数表达这种参数化机制。所谓回调函数是指函数先在某处注册，而它将在稍后某个需要的时候被调用。Command 模式是回调机制的一个面向对象的替代品。</p><p>在不同的时刻指定、排列和执行请求。一个Command对象可以有一个与初始请求无关的生存期。如果一个请求的接收者可用一种与地址空间无关的方式表达，那么就可将负责该请求的命令对象传送给另一个不同的进程并在那儿实现该请求。</p><p>支持取消操作。Command的Excute 操作可在实施操作前将状态存储起来，在取消操作时这个状态用来消除该操作的影响。Command 接口必须添加一个Unexecute操作，该操作取消上一次Execute调用的效果。执行的命令被存储在一个历史列表中。可通过向后和向前遍历这一列表并分别调用Unexecute和Execute来实现重数不限的“取消”和“重做”。</p><p>支持修改日志，这样当系统崩溃时，这些修改可以被重做一遍。在Command接口中添加装载操作和存储操作，可以用来保持变动的一个一致的修改日志。从崩溃中恢复的过程包括从磁盘中重新读入记录下来的命令并用Execute操作重新执行它们。</p><p>用构建在原语操作上的高层操作构造一个系统。这样一种结构在支持事务( transaction)的信息系统中很常见。一个事务封装了对数据的一组变动。Command模式提供了对事务进行建模的方法。Command有一个公共的接口，使得你可以用同一种方式调用所有的事务。同时使用该模式也易于添加新事务以扩展系统。</p><p>详解：<a href="https://link.zhihu.com/?target=http://mp.weixin.qq.com/s?__biz=MzI4Njc5NjM1NQ==&mid=2247487282&idx=2&sn=875f2c0a1ea711dca843c80c7bb6f34a&chksm=ebd6301edca1b908026c18897d07dbe426cb80bf7788f2d1f8b28e6d0ade726d68d99cfc7739&scene=21%23wechat_redirect">设计模式是什么鬼（命令模式）</a></p><h3 id="17-Iterator（迭代器）"><a href="#17-Iterator（迭代器）" class="headerlink" title="17. Iterator（迭代器）"></a><strong>17. Iterator（迭代器）</strong></h3><p><img src="/images/loading.gif" data-original="https://pic3.zhimg.com/80/v2-cd8dac7ccac2eb57e3e56571269867e2_1440w.webp" alt="img"></p><p><strong>意图：</strong></p><p>提供一种方法顺序访问一个聚合对象中各个元素, 而又不需暴露该对象的内部表示。</p><p><strong>适用性：</strong></p><p>访问一个聚合对象的内容而无需暴露它的内部表示。</p><p>支持对聚合对象的多种遍历。</p><p>为遍历不同的聚合结构提供一个统一的接口(即, 支持多态迭代)。</p><p>详解：<a href="https://link.zhihu.com/?target=http://mp.weixin.qq.com/s?__biz=MzI4Njc5NjM1NQ==&mid=2247486776&idx=2&sn=0f4773ca76d325e51bb358325d312642&chksm=ebd63214dca1bb02dc73c0c58f334076226d13e00499c42cad5ff79422c29af44b28e827e77c&scene=21%23wechat_redirect">设计模式是什么鬼（迭代器）</a></p><h3 id="18-Mediator（中介者）"><a href="#18-Mediator（中介者）" class="headerlink" title="18. Mediator（中介者）"></a><strong>18. Mediator（中介者）</strong></h3><p><img src="/images/loading.gif" data-original="https://pic1.zhimg.com/80/v2-4246996c655cd30e5a68cedfb587439c_1440w.webp" alt="img"></p><p><strong>意图：</strong></p><p>用一个中介对象来封装一系列的对象交互。中介者使各对象不需要显式地相互引用，从而使其耦合松散，而且可以独立地改变它们之间的交互。</p><p><strong>适用性：</strong></p><p>一组对象以定义良好但是复杂的方式进行通信。产生的相互依赖关系结构混乱且难以理解。</p><p>一个对象引用其他很多对象并且直接与这些对象通信,导致难以复用该对象。</p><p>想定制一个分布在多个类中的行为，而又不想生成太多的子类。</p><p>详解：<a href="https://link.zhihu.com/?target=http://mp.weixin.qq.com/s?__biz=MzI4Njc5NjM1NQ==&mid=2247486616&idx=1&sn=e18c5f52fc01187b56a7f579f51878a0&chksm=ebd633b4dca1baa21a87516923460a0a598bf35114fcbd4c73e1f42ff5a7693adab540c401a9&scene=21%23wechat_redirect">设计模式是什么鬼（中介）</a></p><h3 id="19-Memento（备忘录）"><a href="#19-Memento（备忘录）" class="headerlink" title="19. Memento（备忘录）"></a><strong>19. Memento（备忘录）</strong></h3><p><img src="/images/loading.gif" data-original="https://pic4.zhimg.com/80/v2-c03892a81c777cc4967136b65d24edbb_1440w.webp" alt="img"></p><p><strong>意图：</strong></p><p>在不破坏封装性的前提下，捕获一个对象的内部状态，并在该对象之外保存这个状态。这样以后就可将该对象恢复到原先保存的状态。</p><p><strong>适用性：</strong></p><p>必须保存一个对象在某一个时刻的(部分)状态, 这样以后需要时它才能恢复到先前的状态。</p><p>如果一个用接口来让其它对象直接得到这些状态，将会暴露对象的实现细节并破坏对象的封装性。</p><p>详解：<a href="https://link.zhihu.com/?target=http://mp.weixin.qq.com/s?__biz=MzI4Njc5NjM1NQ==&mid=2247486709&idx=2&sn=a3cd99b7c0e7f7953bd5bf44cbbccf87&chksm=ebd633d9dca1bacf94451863de6982593ac15a11f15611de1d3aba9ada3244b5fda6a1bc093e&scene=21%23wechat_redirect">设计模式是什么鬼（备忘录）</a></p><h3 id="20-Observer（观察者）"><a href="#20-Observer（观察者）" class="headerlink" title="20. Observer（观察者）"></a><strong>20. Observer（观察者）</strong></h3><p><img src="/images/loading.gif" data-original="https://pic1.zhimg.com/80/v2-18916c491a66e507eb9fd0442da74c50_1440w.webp" alt="img"></p><p><strong>意图：</strong></p><p>定义对象间的一种一对多的依赖关系,当一个对象的状态发生改变时, 所有依赖于它的对象都得到通知并被自动更新。</p><p><strong>适用性：</strong></p><p>当一个抽象模型有两个方面, 其中一个方面依赖于另一方面。将这二者封装在独立的对象中以使它们可以各自独立地改变和复用。</p><p>当对一个对象的改变需要同时改变其它对象, 而不知道具体有多少对象有待改变。</p><p>当一个对象必须通知其它对象，而它又不能假定其它对象是谁。换言之, 你不希望这些对象是紧密耦合的。</p><p>详解：<a href="https://link.zhihu.com/?target=https://mp.weixin.qq.com/s?__biz=MzI4Njc5NjM1NQ==&mid=2247486897&idx=2&sn=927e4dd95695163fa250447ea88e12e8&scene=21%23wechat_redirect">设计模式是什么鬼（观察者）</a></p><h3 id="21-State（状态）"><a href="#21-State（状态）" class="headerlink" title="21. State（状态）"></a><strong>21. State（状态）</strong></h3><p><img src="/images/loading.gif" data-original="https://pic1.zhimg.com/80/v2-bea873507272a679e4dba7ddea2d6edc_1440w.webp" alt="img"></p><p><strong>意图：</strong></p><p>允许一个对象在其内部状态改变时改变它的行为。对象看起来似乎修改了它的类。</p><p><strong>适用性：</strong></p><p>一个对象的行为取决于它的状态, 并且它必须在运行时刻根据状态改变它的行为。</p><p>一个操作中含有庞大的多分支的条件语句，且这些分支依赖于该对象的状态。这个状态通常用一个或多个枚举常量表示。通常, 有多个操作包含这一相同的条件结构。State模式将每一个条件分支放入一个独立的类中。这使得你可以根据对象自身的情况将对象的状态作为一个对象，这一对象可以不依赖于其他对象而独立变化。</p><p>详解：<a href="https://link.zhihu.com/?target=http://mp.weixin.qq.com/s?__biz=MzI4Njc5NjM1NQ==&mid=2247485989&idx=1&sn=7d6967a19531190fb55085e1db559ec1&chksm=ebd63509dca1bc1f710b9df5607a999f68493460e7b610668276009bcd546213500968891f64&scene=21%23wechat_redirect">设计模式是什么鬼（状态）</a></p><h3 id="22-Strategy（策略）"><a href="#22-Strategy（策略）" class="headerlink" title="22. Strategy（策略）"></a><strong>22. Strategy（策略）</strong></h3><p><img src="/images/loading.gif" data-original="https://pic3.zhimg.com/80/v2-40ff8a46922f467bba253a34ce20f89a_1440w.webp" alt="img"></p><p><strong>意图：</strong></p><p>定义一系列的算法,把它们一个个封装起来, 并且使它们可相互替换。本模式使得算法可独立于使用它的客户而变化。</p><p><strong>适用性：</strong></p><p>许多相关的类仅仅是行为有异。“策略”提供了一种用多个行为中的一个行为来配置一个类的方法。</p><p>需要使用一个算法的不同变体。例如，你可能会定义一些反映不同的空间&#x2F;时间权衡的算法。当这些变体实现为一个算法的类层次时[H087] ,可以使用策略模式。</p><p>算法使用客户不应该知道的数据。可使用策略模式以避免暴露复杂的、与算法相关的数据结构。</p><p>一个类定义了多种行为, 并且这些行为在这个类的操作中以多个条件语句的形式出现。将相关的条件分支移入它们各自的Strategy类中以代替这些条件语句。</p><p>详解：<a href="https://link.zhihu.com/?target=http://mp.weixin.qq.com/s?__biz=MzI4Njc5NjM1NQ==&mid=2247485903&idx=1&sn=172401bccf663455fd90c55aa957db18&chksm=ebd636e3dca1bff544c671c9f8de3a6e8d40049ab7cea3d750d03ed00ef6e6c4fae376333de1&scene=21%23wechat_redirect">设计模式是什么鬼（策略）</a></p><h3 id="23-Visitor（访问者）"><a href="#23-Visitor（访问者）" class="headerlink" title="23. Visitor（访问者）"></a><strong>23. Visitor（访问者）</strong></h3><p><img src="/images/loading.gif" data-original="https://pic2.zhimg.com/80/v2-99fb72f8ca261dc1cbd99f0c5203f7f5_1440w.webp" alt="img"></p><p><strong>意图：</strong></p><p>定义一个操作中的算法的骨架，而将一些步骤延迟到子类中。TemplateMethod 使得子类可以不改变一个算法的结构即可重定义该算法的某些特定步骤。</p><p><strong>适用性：</strong></p><p>一次性实现一个算法的不变的部分，并将可变的行为留给子类来实现。</p><p>各子类中公共的行为应被提取出来并集中到一个公共父类中以避免代码重复。这是Opdyke和Johnson所描述过的“重分解以一般化”的一个很好的例子[OJ93]。首先识别现有代码中的不同之处，并且将不同之处分离为新的操作。最后，用一个调用这些新的操作的模板方法来替换这些不同的代码。</p><p>控制子类扩展。模板方法只在特定点调用“hook ”操作（参见效果一节），这样就只允许在这些点进行扩展。</p><p>详解：<a href="https://link.zhihu.com/?target=http://mp.weixin.qq.com/s?__biz=MzI4Njc5NjM1NQ==&mid=2247487316&idx=2&sn=068c3ef1e11722a0220dea7fc2c28dd6&chksm=ebd63078dca1b96ed3048bc390c97700cbcfff3c0f18425a862de768ee3489b76b15598b56db&scene=21%23wechat_redirect">设计模式是什么鬼（访问者）</a></p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">来源：blog.csdn.net/zsjlovesm521/article/details/94382666</span><br></pre></td></tr></table></figure></div><footer class="post-footer"><div class="post-eof"></div></footer></article><article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN"><link itemprop="mainEntityOfPage" href="http://example.com/2023/03/15/%E8%BD%AF%E4%BB%B6%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84/"><span hidden itemprop="author" itemscope itemtype="http://schema.org/Person"><meta itemprop="image" content="/images/xiao.png"><meta itemprop="name" content="毛"><meta itemprop="description" content="在梦里啥都有"></span><span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization"><meta itemprop="name" content="睡觉万岁"></span><header class="post-header"><h2 class="post-title" itemprop="name headline"><a href="/2023/03/15/%E8%BD%AF%E4%BB%B6%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84/" class="post-title-link" itemprop="url">软件体系结构</a></h2><div class="post-meta"><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-calendar"></i> </span><span class="post-meta-item-text">发表于</span> <time title="创建时间：2023-03-15 17:24:47 / 修改时间：18:50:24" itemprop="dateCreated datePublished" datetime="2023-03-15T17:24:47+08:00">2023-03-15</time> </span><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-folder"></i> </span><span class="post-meta-item-text">分类于</span> <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/2023/" itemprop="url" rel="index"><span itemprop="name">2023</span></a></span></span></div></header><div class="post-body" itemprop="articleBody"><h2 id="软件体系结构"><a href="#软件体系结构" class="headerlink" title="软件体系结构"></a>软件体系结构</h2><p>​ 软件体系结构是有关软件系统如何组织的描述。体系结构影响了系统的性能、安全性和可用性。软件工程师可以在给定的体系结构类型中使用不同的体系结构风格和模式，而不同的模式描述了不同的系统类别、构建、连接件及约束。</p><p>​ 软件体系结构脱胎于软件工程．但其形成同时借鉴了计算机体系结构和网络体系结构中很多宝贵的思想和方法。最近几年软件体系结构研究完全独立于软件工程的研究，成为计算机科学的一个最新的研究方向和独立学科分支。</p><p>软件体系结构是对系统的高层设计，是从一个较高的层次来考虑组成系统的构建、构建之间的连接关系，以及系统需满足的约束等。设计模式可以用于软件体系结构的设计，以实现体系结构级的设计复用。用于软件体系结构的设计模式通常称为架构模式（Architectural Pattern）或体系机构风格（Architectural Style）。</p><p>在《Pattern - Oriented Software Architecture》第一卷中，Buschmann等人根据问题的规模或抽象层次将软件设计模式分为三个层次：架构模式（Architectural Patterns）、设计模式（Design Patterns）和习惯用法（Idioms）。</p><p>（1）架构模式</p><p>架构模式是一种高层模式，用于描述系统级的结构组成、相互关系及相关约束。对架构模式的选择是最基本的设计决策，将决定系统的基本架构，并决定后续的设计及开发活动。</p><p>例如，模型 - 视图 - 控制器（Model - View - Controller，MVC）即是一种架构模式，该模式给出了一种交互式系统的架构设计，该模式的主要思想式实现业务逻辑、用户界面的分离。</p><p>（2）设计模式</p><p>设计模式是中层模式，是针对系统局部设计问题给出的解决方案。一般情况下，人们所讲的设计模式都是指中层模式。设计模式的选择对系统的基本架构没有影响，但在实现架构模式时，则可能采用多种设计模式。</p><p>例如，在实现MVC架构模式时，采用的主要设计模式有观察者模式、组合模式和策略模式等。</p><p>（3）习惯用法</p><p>架构模式和设计模式被认为是与具体编程语言无关的，而习惯用法则通常被认为是与具体编程语言相关的一种低层模式。习惯用法给出的解决方案通常与具体编程语言的某种语法机制相关。</p><p>本课程中，软件体系结构就是指架构模式，可以认为是：软件体系结构 &#x3D; 构件 + 连接件 + 约束 。</p><p><img src="/images/loading.gif" data-original="https://pic4.zhimg.com/v2-8c98ec4b5d9d5283ff4d1ad92766de57_r.jpg" alt="preview"></p><p>构件</p><p>构件是具有某种功能的可复用的软件结构单元，表示系统中主要的计算元素 和 数据存储。</p><p>构件是一个抽象的概念，在程序中可以指程序函数、模块、对象、类等。</p><p><img src="/images/loading.gif" data-original="https://pic2.zhimg.com/80/v2-b666558008dc4ff3329ca63e35a6e225_720w.jpg" alt="img"></p><p>连接件</p><p>连接是构件间建立和维护行为关联与信息传递的途径。连接包含下面两种要素：</p><p>其中，机制指的实际中的消息传递方式。</p><p>而协议则决定了 消息的语义理解。</p><p><img src="/images/loading.gif" data-original="https://pic2.zhimg.com/80/v2-1bb5a6d90757c84a0b4009b3f955fd8d_720w.jpg" alt="img"></p><p>连接件表示构件之间的交互并实现构件之间的连接。</p><p><img src="/images/loading.gif" data-original="https://pic4.zhimg.com/80/v2-17f01a5446ba515aca87b563de50f7cb_720w.jpg" alt="img"></p><h2 id="软件体系结构目标"><a href="#软件体系结构目标" class="headerlink" title="软件体系结构目标"></a>软件体系结构目标</h2><p>为了更好理解后面的软件体系结构涉及的原则和体系结构风格，请牢记这些目标，时不时的对照后面的内容回顾这些目标。</p><p>所有的设计原则等理论基本上都可以映射到下面一个或几个目标上。</p><p><img src="/images/loading.gif" data-original="https://pic4.zhimg.com/80/v2-97de430bbe1b18afbc7dd681c511ba33_720w.jpg" alt="img"></p><h2 id="体系结构的发展"><a href="#体系结构的发展" class="headerlink" title="体系结构的发展"></a>体系结构的发展</h2><p>现在软件的复杂性及多变性，导致了软件粒度越来越粗，越来越开放。</p><p><img src="/images/loading.gif" data-original="https://pic3.zhimg.com/80/v2-d6fe8623f78de2cb0ec0d98660466a52_720w.jpg" alt="img"></p><h2 id="下面是常见的软件体系结构"><a href="#下面是常见的软件体系结构" class="headerlink" title="下面是常见的软件体系结构"></a>下面是常见的软件体系结构</h2><p><img src="/images/loading.gif" data-original="/images/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/3.png" alt="11.png"></p><h2 id="软件体系结构与软件设计模式的区别"><a href="#软件体系结构与软件设计模式的区别" class="headerlink" title="软件体系结构与软件设计模式的区别"></a>软件体系结构与软件设计模式的区别</h2><p><img src="/images/loading.gif" data-original="/images/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/4.png" alt="Design-vs-Patterns-SAP.png"></p></div><footer class="post-footer"><div class="post-eof"></div></footer></article><article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN"><link itemprop="mainEntityOfPage" href="http://example.com/2023/03/15/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F(1)/"><span hidden itemprop="author" itemscope itemtype="http://schema.org/Person"><meta itemprop="image" content="/images/xiao.png"><meta itemprop="name" content="毛"><meta itemprop="description" content="在梦里啥都有"></span><span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization"><meta itemprop="name" content="睡觉万岁"></span><header class="post-header"><h2 class="post-title" itemprop="name headline"><a href="/2023/03/15/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F(1)/" class="post-title-link" itemprop="url">设计模式概述</a></h2><div class="post-meta"><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-calendar"></i> </span><span class="post-meta-item-text">发表于</span> <time title="创建时间：2023-03-15 17:18:35" itemprop="dateCreated datePublished" datetime="2023-03-15T17:18:35+08:00">2023-03-15</time> </span><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-calendar-check"></i> </span><span class="post-meta-item-text">更新于</span> <time title="修改时间：2023-03-20 21:02:46" itemprop="dateModified" datetime="2023-03-20T21:02:46+08:00">2023-03-20</time> </span><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-folder"></i> </span><span class="post-meta-item-text">分类于</span> <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/2023/" itemprop="url" rel="index"><span itemprop="name">2023</span></a></span></span></div></header><div class="post-body" itemprop="articleBody"><h1 id="设计模式概述（1）"><a href="#设计模式概述（1）" class="headerlink" title="设计模式概述（1）"></a>设计模式概述（1）</h1><h3 id="1-1-软件设计模式的产生背景"><a href="#1-1-软件设计模式的产生背景" class="headerlink" title="1.1 软件设计模式的产生背景"></a>1.1 软件设计模式的产生背景</h3><p>“设计模式”最初并不是出现在软件设计中，而是被用于建筑领域的设计中。</p><p>1977年美国著名建筑大师、加利福尼亚大学伯克利分校环境结构中心主任<code>克里斯托夫·亚历山大（Christopher Alexander）</code>在他的著作《建筑模式语言：城镇、建筑、构造》（A Pattern Language: Towns Building Construction）中描述了一些常见的建筑设计问题，并提出了 253 种关于对城镇、邻里、住宅、花园和房间等进行设计的基本模式。</p><p>1979 年他的另一部经典著作《建筑的永恒之道》（The Timeless Way of Building）进一步强化了设计模式的思想，为后来的建筑设计指明了方向。</p><p>1987 年，肯特·贝克（Kent Beck）和沃德·坎宁安（Ward Cunningham）首先将克里斯托夫·亚历山大的模式思想应用在 Smalltalk 中的图形用户接口的生成中，但没有引起软件界的关注。</p><p>1990年软件工程界开始研讨设计模式的话题，后来召开了多次关于设计模式的研讨会。直到1995 年，艾瑞克·伽马（ErichGamma）、理査德·海尔姆（Richard Helm）、拉尔夫·约翰森（Ralph Johnson）、约翰·威利斯迪斯（John Vlissides）等 4 位作者合作出版了《设计模式：可复用面向对象软件的基础》一书，在此书中收录了 23 个设计模式，这是设计模式领域里程碑的事件，导致了软件设计模式的突破。这 4 位作者在软件开发领域里也以他们的“四人组”（Gang of Four，GoF）著称。</p><h3 id="1-2-软件设计模式的概念"><a href="#1-2-软件设计模式的概念" class="headerlink" title="1.2 软件设计模式的概念"></a>1.2 软件设计模式的概念</h3><p>软件设计模式（Software Design Pattern），又称设计模式，“解决如下的在特定的环境中反复出现的设计问题，并且为其提供了解决方案”(Buschmann, et. al. 1996)，是一套被反复使用、多数人知晓的、经过分类编目的、代码设计经验的总结。它描述了在软件设计过程中的一些不断重复发生的问题，以及该问题的解决方案。也就是说，它是解决特定问题的一系列套路，是前辈们的代码设计经验的总结，具有一定的普遍性，可以反复使用。</p><h3 id="1-3-学习设计模式的必要性"><a href="#1-3-学习设计模式的必要性" class="headerlink" title="1.3 学习设计模式的必要性"></a>1.3 学习设计模式的必要性</h3><p>设计模式的本质是面向对象设计原则的实际运用，是对类的封装性、继承性和多态性以及类的关联关系和组合关系的充分理解。</p><p>正确使用设计模式具有以下优点。</p><ol><li>可以提高程序员的思维能力、编程能力和设计能力。</li><li>使程序设计更加标准化、代码编制更加工程化，使软件开发效率大大提高，从而缩短软件的开发周期。</li><li>使设计的代码可重用性高、可读性强、可靠性高、灵活性好、可维护性强。</li><li>成为优秀的软件工程师。</li></ol><p>当然，软件设计模式只是一个引导。在具体的软件幵发中，必须根据设计的应用系统的特点和要求来恰当选择。对于简单的程序开发，苛能写一个简单的算法要比引入某种设计模式更加容易。但对大项目的开发或者框架设计，用设计模式来组织代码显然更好。</p><h3 id="1-4-软件设计模式的基本要素"><a href="#1-4-软件设计模式的基本要素" class="headerlink" title="1.4 软件设计模式的基本要素"></a>1.4 软件设计模式的基本要素</h3><p>软件设计模式使人们可以更加简单方便地复用成功的设计和体系结构，它通常包含以下几个基本要素：模式名称、别名、动机、问题、解决方案、效果、结构、模式角色、合作关系、实现方法、适用性、已知应用、例程、模式扩展和相关模式等，其中最关键的元素包括以下 4 个主要部分。</p><ol><li>模式名称</li></ol><p>每一个模式都有自己的名字，通常用一两个词来描述，可以根据模式的问题、特点、解决方案、功能和效果来命名。模式名称（PatternName）有助于我们理解和记忆该模式，也方便我们来讨论自己的设计。</p><ol start="2"><li>问题</li></ol><p>问题（Problem）描述了该模式的应用环境，即何时使用该模式。它解释了设计问题和问题存在的前因后果，以及必须满足的一系列先决条件。</p><ol start="3"><li>解决方案</li></ol><p>模式问题的解决方案（Solution）包括设计的组成成分、它们之间的相互关系及各自的职责和协作方式。因为模式就像一个模板，可应用于多种不同场合，所以解决方案并不描述一个特定而具体的设计或实现，而是提供设计问题的抽象描述和怎样用一个具有一般意义的元素组合（类或对象的 组合）来解决这个问题。</p><ol start="4"><li>效果</li></ol><p>描述了模式的应用效果以及使用该模式应该权衡的问题，即模式的优缺点。主要是对时间和空间的衡量，以及该模式对系统的灵活性、扩充性、可移植性的影响，也考虑其实现问题。显式地列出这些效果（Consequence）对理解和评价这些模式有很大的帮助。</p><h3 id="1-5-根据目的分类"><a href="#1-5-根据目的分类" class="headerlink" title="1.5 根据目的分类"></a>1.5 根据目的分类</h3><ul><li><p><strong>创建型模式</strong></p><p>用于描述“怎样创建对象”，它的主要特点是“将对象的创建与使用分离”。GoF（四人组）书中提供了单例、原型、工厂方法、抽象工厂、建造者等 5 种创建型模式。</p></li><li><p><strong>结构型模式</strong></p><p>用于描述如何将类或对象按某种布局组成更大的结构，GoF（四人组）书中提供了代理、适配器、桥接、装饰、外观、享元、组合等 7 种结构型模式。</p></li><li><p><strong>行为型模式</strong></p><p>用于描述类或对象之间怎样相互协作共同完成单个对象无法单独完成的任务，以及怎样分配职责。GoF（四人组）书中提供了模板方法、策略、命令、职责链、状态、观察者、中介者、迭代器、访问者、备忘录、解释器等 11 种行为型模式。</p></li></ul><p><img src="/images/loading.gif" data-original="https://rajneekanth.files.wordpress.com/2014/04/alldesignpatterns.png" alt="What are Design Patterns? – Rajani Kanth"></p><h3 id="1-6-根据作用范围来分"><a href="#1-6-根据作用范围来分" class="headerlink" title="1.6 根据作用范围来分"></a>1.6 根据作用范围来分</h3><p>根据模式是主要用于类上还是主要用于对象上来分，这种方式可分为类模式和对象模式两种。</p><ol><li>类模式：用于处理类与子类之间的关系，这些关系通过继承来建立，是静态的，在编译时刻便确定下来了。GoF中的工厂方法、（类）适配器、模板方法、解释器属于该模式。</li><li>对象模式：用于处理对象之间的关系，这些关系可以通过组合或聚合来实现，在运行时刻是可以变化的，更具动态性。GoF 中除了以上 4 种，其他的都是对象模式。</li></ol><p><img src="/images/loading.gif" data-original="/images/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/2.png" alt="img"></p><h3 id="1-7-GoF的23种设计模式的功能简介"><a href="#1-7-GoF的23种设计模式的功能简介" class="headerlink" title="1.7. GoF的23种设计模式的功能简介"></a>1.7. GoF的23种设计模式的功能简介</h3><p>前面说明了 GoF 的 23 种设计模式的分类，现在对各个模式的功能进行介绍。</p><ol><li>单例（Singleton）模式：某个类只能生成一个实例，该类提供了一个全局访问点供外部获取该实例，其拓展是有限多例模式。</li><li>原型（Prototype）模式：将一个对象作为原型，通过对其进行复制而克隆出多个和原型类似的新实例。</li><li>工厂方法（Factory Method）模式：定义一个用于创建产品的接口，由子类决定生产什么产品。</li><li>抽象工厂（AbstractFactory）模式：提供一个创建产品族的接口，其每个子类可以生产一系列相关的产品。</li><li>建造者（Builder）模式：将一个复杂对象分解成多个相对简单的部分，然后根据不同需要分别创建它们，最后构建成该复杂对象。</li><li>代理（Proxy）模式：为某对象提供一种代理以控制对该对象的访问。即客户端通过代理间接地访问该对象，从而限制、增强或修改该对象的一些特性。</li><li>适配器（Adapter）模式：将一个类的接口转换成客户希望的另外一个接口，使得原本由于接口不兼容而不能一起工作的那些类能一起工作。</li><li>桥接（Bridge）模式：将抽象与实现分离，使它们可以独立变化。它是用组合关系代替继承关系来实现，从而降低了抽象和实现这两个可变维度的耦合度。</li><li>装饰（Decorator）模式：动态的给对象增加一些职责，即增加其额外的功能。</li><li>外观（Facade）模式：为多个复杂的子系统提供一个一致的接口，使这些子系统更加容易被访问。</li><li>享元（Flyweight）模式：运用共享技术来有效地支持大量细粒度对象的复用。</li><li>组合（Composite）模式：将对象组合成树状层次结构，使用户对单个对象和组合对象具有一致的访问性。</li><li>模板方法（TemplateMethod）模式：定义一个操作中的算法骨架，而将算法的一些步骤延迟到子类中，使得子类可以不改变该算法结构的情况下重定义该算法的某些特定步骤。</li><li>策略（Strategy）模式：定义了一系列算法，并将每个算法封装起来，使它们可以相互替换，且算法的改变不会影响使用算法的客户。</li><li>命令（Command）模式：将一个请求封装为一个对象，使发出请求的责任和执行请求的责任分割开。</li><li>职责链（Chain of Responsibility）模式：把请求从链中的一个对象传到下一个对象，直到请求被响应为止。通过这种方式去除对象之间的耦合。</li><li>状态（State）模式：允许一个对象在其内部状态发生改变时改变其行为能力。</li><li>观察者（Observer）模式：多个对象间存在一对多关系，当一个对象发生改变时，把这种改变通知给其他多个对象，从而影响其他对象的行为。</li><li>中介者（Mediator）模式：定义一个中介对象来简化原有对象之间的交互关系，降低系统中对象间的耦合度，使原有对象之间不必相互了解。</li><li>迭代器（Iterator）模式：提供一种方法来顺序访问聚合对象中的一系列数据，而不暴露聚合对象的内部表示。</li><li>访问者（Visitor）模式：在不改变集合元素的前提下，为一个集合中的每个元素提供多种访问方式，即每个元素有多个访问者对象访问。</li><li>备忘录（Memento）模式：在不破坏封装性的前提下，获取并保存一个对象的内部状态，以便以后恢复它。</li><li>解释器（Interpreter）模式：提供如何定义语言的文法，以及对语言句子的解释方法，即解释器。</li></ol><p>必须指出，这 23 种设计模式不是孤立存在的，很多模式之间存在一定的关联关系，在大的系统开发中常常同时使用多种设计模式。</p><p><img src="/images/loading.gif" data-original="https://s3.ananas.chaoxing.com/sv-w6/doc/81/1a/9b/044fa8cabde2944e50aa2661f8755299/thumb/1.png" alt="img"></p><p><img src="/images/loading.gif" data-original="https://s3.ananas.chaoxing.com/sv-w6/doc/81/1a/9b/044fa8cabde2944e50aa2661f8755299/thumb/2.png" alt="img"></p></div><footer class="post-footer"><div class="post-eof"></div></footer></article><article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN"><link itemprop="mainEntityOfPage" href="http://example.com/2023/03/14/%E8%99%9A%E6%8B%9F%E6%9C%BA%E5%92%8C%E4%B8%BB%E6%9C%BA%E5%8F%8C%E5%90%91%E5%A4%8D%E5%88%B6/"><span hidden itemprop="author" itemscope itemtype="http://schema.org/Person"><meta itemprop="image" content="/images/xiao.png"><meta itemprop="name" content="毛"><meta itemprop="description" content="在梦里啥都有"></span><span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization"><meta itemprop="name" content="睡觉万岁"></span><header class="post-header"><h2 class="post-title" itemprop="name headline"><a href="/2023/03/14/%E8%99%9A%E6%8B%9F%E6%9C%BA%E5%92%8C%E4%B8%BB%E6%9C%BA%E5%8F%8C%E5%90%91%E5%A4%8D%E5%88%B6/" class="post-title-link" itemprop="url">虚拟机和主机双向复制</a></h2><div class="post-meta"><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-calendar"></i> </span><span class="post-meta-item-text">发表于</span> <time title="创建时间：2023-03-14 00:19:02 / 修改时间：01:01:33" itemprop="dateCreated datePublished" datetime="2023-03-14T00:19:02+08:00">2023-03-14</time> </span><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-folder"></i> </span><span class="post-meta-item-text">分类于</span> <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/2023/" itemprop="url" rel="index"><span itemprop="name">2023</span></a></span></span></div></header><div class="post-body" itemprop="articleBody"><h1 id="虚拟机和主机双向复制"><a href="#虚拟机和主机双向复制" class="headerlink" title="虚拟机和主机双向复制"></a>虚拟机和主机双向复制</h1><div class="post-button"><a class="btn" href="/2023/03/14/%E8%99%9A%E6%8B%9F%E6%9C%BA%E5%92%8C%E4%B8%BB%E6%9C%BA%E5%8F%8C%E5%90%91%E5%A4%8D%E5%88%B6/#more" rel="contents">阅读全文 &raquo;</a></div></div><footer class="post-footer"><div class="post-eof"></div></footer></article><article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN"><link itemprop="mainEntityOfPage" href="http://example.com/2023/03/13/sparkRDD%E7%BC%96%E7%A8%8B/"><span hidden itemprop="author" itemscope itemtype="http://schema.org/Person"><meta itemprop="image" content="/images/xiao.png"><meta itemprop="name" content="毛"><meta itemprop="description" content="在梦里啥都有"></span><span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization"><meta itemprop="name" content="睡觉万岁"></span><header class="post-header"><h2 class="post-title" itemprop="name headline"><a href="/2023/03/13/sparkRDD%E7%BC%96%E7%A8%8B/" class="post-title-link" itemprop="url">Spark入门：RDD编程</a></h2><div class="post-meta"><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-calendar"></i> </span><span class="post-meta-item-text">发表于</span> <time title="创建时间：2023-03-13 21:47:53" itemprop="dateCreated datePublished" datetime="2023-03-13T21:47:53+08:00">2023-03-13</time> </span><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-calendar-check"></i> </span><span class="post-meta-item-text">更新于</span> <time title="修改时间：2023-04-07 14:53:47" itemprop="dateModified" datetime="2023-04-07T14:53:47+08:00">2023-04-07</time> </span><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-folder"></i> </span><span class="post-meta-item-text">分类于</span> <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/2023/" itemprop="url" rel="index"><span itemprop="name">2023</span></a></span></span></div></header><div class="post-body" itemprop="articleBody"><h1 id="Spark入门：RDD编程"><a href="#Spark入门：RDD编程" class="headerlink" title="Spark入门：RDD编程"></a>Spark入门：RDD编程</h1><div class="post-button"><a class="btn" href="/2023/03/13/sparkRDD%E7%BC%96%E7%A8%8B/#more" rel="contents">阅读全文 &raquo;</a></div></div><footer class="post-footer"><div class="post-eof"></div></footer></article><nav class="pagination"><a class="extend prev" rel="prev" href="/page/7/"><i class="fa fa-angle-left" aria-label="上一页"></i></a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/7/">7</a><span class="page-number current">8</span><a class="page-number" href="/page/9/">9</a><span class="space">&hellip;</span><a class="page-number" href="/page/11/">11</a><a class="extend next" rel="next" href="/page/9/"><i class="fa fa-angle-right" aria-label="下一页"></i></a></nav></div><script>window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }</script></div><div class="toggle sidebar-toggle"><span class="toggle-line toggle-line-first"></span> <span class="toggle-line toggle-line-middle"></span> <span class="toggle-line toggle-line-last"></span></div><aside class="sidebar"><div class="sidebar-inner"><ul class="sidebar-nav motion-element"><li class="sidebar-nav-toc">文章目录</li><li class="sidebar-nav-overview">站点概览</li></ul><div class="post-toc-wrap sidebar-panel"></div><div class="site-overview-wrap sidebar-panel"><div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person"><img class="site-author-image" itemprop="image" alt="毛" src="/images/xiao.png"><p class="site-author-name" itemprop="name">毛</p><div class="site-description" itemprop="description">在梦里啥都有</div></div><div class="site-state-wrap motion-element"><nav class="site-state"><div class="site-state-item site-state-posts"><a href="/archives/"><span class="site-state-item-count">103</span> <span class="site-state-item-name">日志</span></a></div><div class="site-state-item site-state-categories"><a href="/categories/"><span class="site-state-item-count">3</span> <span class="site-state-item-name">分类</span></a></div><div class="site-state-item site-state-tags"><a href="/tags/"><span class="site-state-item-count">34</span> <span class="site-state-item-name">标签</span></a></div></nav></div><div class="links-of-author motion-element"><span class="links-of-author-item"><a href="https://github.com/maduit" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;maduit" rel="noopener" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a> </span><span class="links-of-author-item"><a href="mailto:825577940@qq.com" title="E-Mail → mailto:825577940@qq.com" rel="noopener" target="_blank"><i class="fa fa-envelope fa-fw"></i>E-Mail</a> </span><span class="links-of-author-item"><a href="https://blog.csdn.net/maduit?spm=1000.2115.3001.5343" title="CSDN → https:&#x2F;&#x2F;blog.csdn.net&#x2F;maduit?spm&#x3D;1000.2115.3001.5343" rel="noopener" target="_blank"><i class="codiepie fa-fw"></i>CSDN</a></span></div><div class="links-of-blogroll motion-element"><div class="links-of-blogroll-title"><i class="fa fa-envelope fa-fw"></i> links_settings</div><ul class="links-of-blogroll-list"><li class="links-of-blogroll-item"><a href="https://github.com/" title="https:&#x2F;&#x2F;github.com&#x2F;" rel="noopener" target="_blank">推荐阅读</a></li></ul></div></div></div></aside><div id="sidebar-dimmer"></div></div></main><footer class="footer"><div class="footer-inner"><div class="copyright">&copy; 2022-09 – <span itemprop="copyrightYear">2023</span> <span class="with-love"><i class="fa fa-heart"></i> </span><span class="author" itemprop="copyrightHolder">毛</span></div><div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://pisces.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Pisces</a> 强力驱动</div><div class="theme-info"><div class="powered-by"></div><span class="post-count">博客全站共77.1k字</span></div><script async src="//dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js"></script><span id="busuanzi_container_site_pv">总访问量<span id="busuanzi_value_site_pv"></span>次</span> <span class="post-meta-divider">|</span> <span id="busuanzi_container_site_uv">总访客数<span id="busuanzi_value_site_uv"></span>人</span> <span class="post-meta-divider">|</span><script>$(document).ready(function(){var e=setInterval(function(){"none"!=document.getElementById("busuanzi_container_site_pv").style.display&&($("#busuanzi_value_site_pv").html(parseInt($("#busuanzi_value_site_pv").html())+n),clearInterval(e));"none"!=$("#busuanzi_container_site_pv").css("display")&&($("#busuanzi_value_site_uv").html(parseInt($("#busuanzi_value_site_uv").html())+n),clearInterval(e))},50),n=2e4})</script><div class="busuanzi-count"><script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><span class="post-meta-item" id="busuanzi_container_site_uv" style="display:none"><span class="post-meta-item-icon"><i class="fa fa-user"></i> </span><span class="site-uv" title="总访客量"><span id="busuanzi_value_site_uv"></span> </span></span><span class="post-meta-divider">|</span> <span class="post-meta-item" id="busuanzi_container_site_pv" style="display:none"><span class="post-meta-item-icon"><i class="fa fa-eye"></i> </span><span class="site-pv" title="总访问量"><span id="busuanzi_value_site_pv"></span></span></span></div></div></footer></div><script color="0,0,255" opacity="0.5" zindex="-1" count="99" src="/lib/canvas-nest/canvas-nest.min.js"></script><script size="300" alpha="0.6" zindex="-1" src="/lib/canvas-ribbon/canvas-ribbon.js"></script><script src="/lib/anime.min.js"></script><script src="/lib/velocity/velocity.min.js"></script><script src="/lib/velocity/velocity.ui.min.js"></script><script src="/js/utils.js"></script><script src="/js/motion.js"></script><script src="/js/schemes/pisces.js"></script><script src="/js/next-boot.js"></script><script defer src="/lib/three/three.min.js"></script><script defer src="/lib/three/three-waves.min.js"></script><script src="/live2dw/lib/L2Dwidget.min.js?094cbace49a39548bed64abff5988b05"></script><script>L2Dwidget.init({model:{jsonPath:"/live2dw/assets/koharu.model.json"},display:{position:"right",width:150,height:300},mobile:{show:!1},log:!1,pluginJsPath:"lib/",pluginModelPath:"assets/",pluginRootPath:"live2dw/",tagMode:!1})</script><style>[bg-lazy]{background-image:none!important;background-color:#eee!important}</style><script>window.imageLazyLoadSetting={isSPA:!1,preloadRatio:1,processImages:null}</script><script>window.addEventListener("load",function(){var t=/\.(gif|jpg|jpeg|tiff|png)$/i,r=/^data:image\/[a-z]+;base64,/;Array.prototype.slice.call(document.querySelectorAll("img[data-original]")).forEach(function(a){var e=a.parentNode;"A"===e.tagName&&(e.href.match(t)||e.href.match(r))&&(e.href=a.dataset.original)})})</script><script>!function(a){a.imageLazyLoadSetting.processImages=t;var e=a.imageLazyLoadSetting.isSPA,i=a.imageLazyLoadSetting.preloadRatio||1,o=r();function r(){var t=Array.prototype.slice.call(document.querySelectorAll("img[data-original]")),e=Array.prototype.slice.call(document.querySelectorAll("[bg-lazy]"));return t.concat(e)}function t(){e&&(o=r());for(var t,n=0;n<o.length;n++)0<=(t=o[n].getBoundingClientRect()).bottom&&0<=t.left&&t.top<=(a.innerHeight*i||document.documentElement.clientHeight*i)&&function(){var e=o[n];!function(t,e){if(t.hasAttribute("bg-lazy"))return t.removeAttribute("bg-lazy"),e();var n=new Image,a=t.getAttribute("data-original");n.onload=function(){t.src=a,t.removeAttribute("data-original"),e()},t.src!==a&&(n.src=a)}(e,function(){o=o.filter(function(t){return e!==t}),a.imageLazyLoadSetting.onImageLoaded&&a.imageLazyLoadSetting.onImageLoaded(e)})}()}function n(){clearTimeout(t.tId),t.tId=setTimeout(t,500)}t(),document.addEventListener("scroll",n),a.addEventListener("resize",n),a.addEventListener("orientationchange",n)}(this)</script></body></html><script type="text/javascript" src="/js/love.js"></script><canvas class="fireworks" style="position:fixed;left:0;top:0;z-index:1;pointer-events:none"></canvas><script type="text/javascript" src="//cdn.bootcss.com/animejs/2.2.0/anime.min.js"></script><script type="text/javascript" src="/js/fireworks.js"></script><script type="text/javascript" src="\js\snow.js"></script><script type="text/javascript" src="http://libs.baidu.com/jquery/1.8.3/jquery.js"></script><script type="text/javascript" src="http://libs.baidu.com/jquery/1.8.3/jquery.min.js"></script>