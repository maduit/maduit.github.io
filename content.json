{"meta":{"title":"睡觉万岁","subtitle":"","description":"在梦里啥都有","author":"毛","url":"http://example.com","root":"/"},"pages":[{"title":"about","date":"2022-12-31T14:33:19.000Z","updated":"2023-03-13T16:54:43.311Z","comments":true,"path":"about/index.html","permalink":"http://example.com/about/index.html","excerpt":"","text":"欠的债迟早都要还的！~！~！~！~！"},{"title":"分类","date":"2022-12-31T14:33:04.000Z","updated":"2022-12-31T14:36:05.876Z","comments":false,"path":"categories/index.html","permalink":"http://example.com/categories/index.html","excerpt":"","text":""},{"title":"资源","date":"2022-12-31T14:33:21.000Z","updated":"2022-12-31T14:37:12.176Z","comments":false,"path":"resources/index.html","permalink":"http://example.com/resources/index.html","excerpt":"","text":""},{"title":"标签","date":"2022-12-31T14:33:16.000Z","updated":"2022-12-31T14:36:40.295Z","comments":false,"path":"tags/index.html","permalink":"http://example.com/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"软件体系结构","slug":"软件体系结构","date":"2023-03-15T09:24:47.975Z","updated":"2023-03-15T09:24:47.975Z","comments":true,"path":"2023/03/15/软件体系结构/","link":"","permalink":"http://example.com/2023/03/15/%E8%BD%AF%E4%BB%B6%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84/","excerpt":"","text":"软件体系结构​ 软件体系结构是有关软件系统如何组织的描述。体系结构影响了系统的性能、安全性和可用性。软件工程师可以在给定的体系结构类型中使用不同的体系结构风格和模式，而不同的模式描述了不同的系统类别、构建、连接件及约束。 ​ 软件体系结构脱胎于软件工程．但其形成同时借鉴了计算机体系结构和网络体系结构中很多宝贵的思想和方法。最近几年软件体系结构研究完全独立于软件工程的研究，成为计算机科学的一个最新的研究方向和独立学科分支。 软件体系结构是对系统的高层设计，是从一个较高的层次来考虑组成系统的构建、构建之间的连接关系，以及系统需满足的约束等。设计模式可以用于软件体系结构的设计，以实现体系结构级的设计复用。用于软件体系结构的设计模式通常称为架构模式（Architectural Pattern）或体系机构风格（Architectural Style）。 在《Pattern - Oriented Software Architecture》第一卷中，Buschmann等人根据问题的规模或抽象层次将软件设计模式分为三个层次：架构模式（Architectural Patterns）、设计模式（Design Patterns）和习惯用法（Idioms）。 （1）架构模式 架构模式是一种高层模式，用于描述系统级的结构组成、相互关系及相关约束。对架构模式的选择是最基本的设计决策，将决定系统的基本架构，并决定后续的设计及开发活动。 例如，模型 - 视图 - 控制器（Model - View - Controller，MVC）即是一种架构模式，该模式给出了一种交互式系统的架构设计，该模式的主要思想式实现业务逻辑、用户界面的分离。 （2）设计模式 设计模式是中层模式，是针对系统局部设计问题给出的解决方案。一般情况下，人们所讲的设计模式都是指中层模式。设计模式的选择对系统的基本架构没有影响，但在实现架构模式时，则可能采用多种设计模式。 例如，在实现MVC架构模式时，采用的主要设计模式有观察者模式、组合模式和策略模式等。 （3）习惯用法 架构模式和设计模式被认为是与具体编程语言无关的，而习惯用法则通常被认为是与具体编程语言相关的一种低层模式。习惯用法给出的解决方案通常与具体编程语言的某种语法机制相关。 本课程中，软件体系结构就是指架构模式，可以认为是：软件体系结构 &#x3D; 构件 + 连接件 + 约束 。 构件 构件是具有某种功能的可复用的软件结构单元，表示系统中主要的计算元素 和 数据存储。 构件是一个抽象的概念，在程序中可以指程序函数、模块、对象、类等。 连接件 连接是构件间建立和维护行为关联与信息传递的途径。连接包含下面两种要素： 其中，机制指的实际中的消息传递方式。 而协议则决定了 消息的语义理解。 连接件表示构件之间的交互并实现构件之间的连接。 软件体系结构目标为了更好理解后面的软件体系结构涉及的原则和体系结构风格，请牢记这些目标，时不时的对照后面的内容回顾这些目标。 所有的设计原则等理论基本上都可以映射到下面一个或几个目标上。 体系结构的发展现在软件的复杂性及多变性，导致了软件粒度越来越粗，越来越开放。 下面是常见的软件体系结构 软件体系结构与软件设计模式的区别","categories":[{"name":"2023","slug":"2023","permalink":"http://example.com/categories/2023/"}],"tags":[{"name":"设计模式","slug":"设计模式","permalink":"http://example.com/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"}]},{"title":"设计模式概述","slug":"设计模式(1)","date":"2023-03-15T09:18:35.137Z","updated":"2023-03-15T09:22:53.577Z","comments":true,"path":"2023/03/15/设计模式(1)/","link":"","permalink":"http://example.com/2023/03/15/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F(1)/","excerpt":"","text":"设计模式概述（1）1.1 软件设计模式的产生背景“设计模式”最初并不是出现在软件设计中，而是被用于建筑领域的设计中。 1977年美国著名建筑大师、加利福尼亚大学伯克利分校环境结构中心主任克里斯托夫·亚历山大（Christopher Alexander）在他的著作《建筑模式语言：城镇、建筑、构造》（A Pattern Language: Towns Building Construction）中描述了一些常见的建筑设计问题，并提出了 253 种关于对城镇、邻里、住宅、花园和房间等进行设计的基本模式。 1979 年他的另一部经典著作《建筑的永恒之道》（The Timeless Way of Building）进一步强化了设计模式的思想，为后来的建筑设计指明了方向。 1987 年，肯特·贝克（Kent Beck）和沃德·坎宁安（Ward Cunningham）首先将克里斯托夫·亚历山大的模式思想应用在 Smalltalk 中的图形用户接口的生成中，但没有引起软件界的关注。 1990年软件工程界开始研讨设计模式的话题，后来召开了多次关于设计模式的研讨会。直到1995 年，艾瑞克·伽马（ErichGamma）、理査德·海尔姆（Richard Helm）、拉尔夫·约翰森（Ralph Johnson）、约翰·威利斯迪斯（John Vlissides）等 4 位作者合作出版了《设计模式：可复用面向对象软件的基础》一书，在此书中收录了 23 个设计模式，这是设计模式领域里程碑的事件，导致了软件设计模式的突破。这 4 位作者在软件开发领域里也以他们的“四人组”（Gang of Four，GoF）著称。 1.2 软件设计模式的概念软件设计模式（Software Design Pattern），又称设计模式，“解决如下的在特定的环境中反复出现的设计问题，并且为其提供了解决方案”(Buschmann, et. al. 1996)，是一套被反复使用、多数人知晓的、经过分类编目的、代码设计经验的总结。它描述了在软件设计过程中的一些不断重复发生的问题，以及该问题的解决方案。也就是说，它是解决特定问题的一系列套路，是前辈们的代码设计经验的总结，具有一定的普遍性，可以反复使用。 1.3 学习设计模式的必要性设计模式的本质是面向对象设计原则的实际运用，是对类的封装性、继承性和多态性以及类的关联关系和组合关系的充分理解。 正确使用设计模式具有以下优点。 可以提高程序员的思维能力、编程能力和设计能力。 使程序设计更加标准化、代码编制更加工程化，使软件开发效率大大提高，从而缩短软件的开发周期。 使设计的代码可重用性高、可读性强、可靠性高、灵活性好、可维护性强。 成为优秀的软件工程师。 当然，软件设计模式只是一个引导。在具体的软件幵发中，必须根据设计的应用系统的特点和要求来恰当选择。对于简单的程序开发，苛能写一个简单的算法要比引入某种设计模式更加容易。但对大项目的开发或者框架设计，用设计模式来组织代码显然更好。 1.4 软件设计模式的基本要素软件设计模式使人们可以更加简单方便地复用成功的设计和体系结构，它通常包含以下几个基本要素：模式名称、别名、动机、问题、解决方案、效果、结构、模式角色、合作关系、实现方法、适用性、已知应用、例程、模式扩展和相关模式等，其中最关键的元素包括以下 4 个主要部分。 \\1. 模式名称 每一个模式都有自己的名字，通常用一两个词来描述，可以根据模式的问题、特点、解决方案、功能和效果来命名。模式名称（PatternName）有助于我们理解和记忆该模式，也方便我们来讨论自己的设计。 \\2. 问题 问题（Problem）描述了该模式的应用环境，即何时使用该模式。它解释了设计问题和问题存在的前因后果，以及必须满足的一系列先决条件。 \\3. 解决方案 模式问题的解决方案（Solution）包括设计的组成成分、它们之间的相互关系及各自的职责和协作方式。因为模式就像一个模板，可应用于多种不同场合，所以解决方案并不描述一个特定而具体的设计或实现，而是提供设计问题的抽象描述和怎样用一个具有一般意义的元素组合（类或对象的 组合）来解决这个问题。 \\4. 效果 描述了模式的应用效果以及使用该模式应该权衡的问题，即模式的优缺点。主要是对时间和空间的衡量，以及该模式对系统的灵活性、扩充性、可移植性的影响，也考虑其实现问题。显式地列出这些效果（Consequence）对理解和评价这些模式有很大的帮助。 1.5 根据目的分类 创建型模式 用于描述“怎样创建对象”，它的主要特点是“将对象的创建与使用分离”。GoF（四人组）书中提供了单例、原型、工厂方法、抽象工厂、建造者等 5 种创建型模式。 结构型模式 用于描述如何将类或对象按某种布局组成更大的结构，GoF（四人组）书中提供了代理、适配器、桥接、装饰、外观、享元、组合等 7 种结构型模式。 行为型模式 用于描述类或对象之间怎样相互协作共同完成单个对象无法单独完成的任务，以及怎样分配职责。GoF（四人组）书中提供了模板方法、策略、命令、职责链、状态、观察者、中介者、迭代器、访问者、备忘录、解释器等 11 种行为型模式。 1.6 根据作用范围来分根据模式是主要用于类上还是主要用于对象上来分，这种方式可分为类模式和对象模式两种。 类模式：用于处理类与子类之间的关系，这些关系通过继承来建立，是静态的，在编译时刻便确定下来了。GoF中的工厂方法、（类）适配器、模板方法、解释器属于该模式。 对象模式：用于处理对象之间的关系，这些关系可以通过组合或聚合来实现，在运行时刻是可以变化的，更具动态性。GoF 中除了以上 4 种，其他的都是对象模式。 1.7. GoF的23种设计模式的功能简介前面说明了 GoF 的 23 种设计模式的分类，现在对各个模式的功能进行介绍。 单例（Singleton）模式：某个类只能生成一个实例，该类提供了一个全局访问点供外部获取该实例，其拓展是有限多例模式。 原型（Prototype）模式：将一个对象作为原型，通过对其进行复制而克隆出多个和原型类似的新实例。 工厂方法（Factory Method）模式：定义一个用于创建产品的接口，由子类决定生产什么产品。 抽象工厂（AbstractFactory）模式：提供一个创建产品族的接口，其每个子类可以生产一系列相关的产品。 建造者（Builder）模式：将一个复杂对象分解成多个相对简单的部分，然后根据不同需要分别创建它们，最后构建成该复杂对象。 代理（Proxy）模式：为某对象提供一种代理以控制对该对象的访问。即客户端通过代理间接地访问该对象，从而限制、增强或修改该对象的一些特性。 适配器（Adapter）模式：将一个类的接口转换成客户希望的另外一个接口，使得原本由于接口不兼容而不能一起工作的那些类能一起工作。 桥接（Bridge）模式：将抽象与实现分离，使它们可以独立变化。它是用组合关系代替继承关系来实现，从而降低了抽象和实现这两个可变维度的耦合度。 装饰（Decorator）模式：动态的给对象增加一些职责，即增加其额外的功能。 外观（Facade）模式：为多个复杂的子系统提供一个一致的接口，使这些子系统更加容易被访问。 享元（Flyweight）模式：运用共享技术来有效地支持大量细粒度对象的复用。 组合（Composite）模式：将对象组合成树状层次结构，使用户对单个对象和组合对象具有一致的访问性。 模板方法（TemplateMethod）模式：定义一个操作中的算法骨架，而将算法的一些步骤延迟到子类中，使得子类可以不改变该算法结构的情况下重定义该算法的某些特定步骤。 策略（Strategy）模式：定义了一系列算法，并将每个算法封装起来，使它们可以相互替换，且算法的改变不会影响使用算法的客户。 命令（Command）模式：将一个请求封装为一个对象，使发出请求的责任和执行请求的责任分割开。 职责链（Chain of Responsibility）模式：把请求从链中的一个对象传到下一个对象，直到请求被响应为止。通过这种方式去除对象之间的耦合。 状态（State）模式：允许一个对象在其内部状态发生改变时改变其行为能力。 观察者（Observer）模式：多个对象间存在一对多关系，当一个对象发生改变时，把这种改变通知给其他多个对象，从而影响其他对象的行为。 中介者（Mediator）模式：定义一个中介对象来简化原有对象之间的交互关系，降低系统中对象间的耦合度，使原有对象之间不必相互了解。 迭代器（Iterator）模式：提供一种方法来顺序访问聚合对象中的一系列数据，而不暴露聚合对象的内部表示。 访问者（Visitor）模式：在不改变集合元素的前提下，为一个集合中的每个元素提供多种访问方式，即每个元素有多个访问者对象访问。 备忘录（Memento）模式：在不破坏封装性的前提下，获取并保存一个对象的内部状态，以便以后恢复它。 解释器（Interpreter）模式：提供如何定义语言的文法，以及对语言句子的解释方法，即解释器。 必须指出，这 23 种设计模式不是孤立存在的，很多模式之间存在一定的关联关系，在大的系统开发中常常同时使用多种设计模式。","categories":[{"name":"2023","slug":"2023","permalink":"http://example.com/categories/2023/"}],"tags":[{"name":"设计模式","slug":"设计模式","permalink":"http://example.com/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"}]},{"title":"虚拟机和主机双向复制","slug":"虚拟机和主机双向复制","date":"2023-03-13T16:19:02.512Z","updated":"2023-03-13T17:01:33.362Z","comments":true,"path":"2023/03/14/虚拟机和主机双向复制/","link":"","permalink":"http://example.com/2023/03/14/%E8%99%9A%E6%8B%9F%E6%9C%BA%E5%92%8C%E4%B8%BB%E6%9C%BA%E5%8F%8C%E5%90%91%E5%A4%8D%E5%88%B6/","excerpt":"虚拟机和主机双向复制","text":"虚拟机和主机双向复制 vmware tools黑了 http://www.360doc.com/content/22/1205/19/81029453_1059073619.shtml 试试这个吧 手工安装Vmware tools方法 这种方法是通过Ubuntu的安装命令直接从网上进行安装，打开终端窗口直接执行下列命令即可，安装之前要保证虚拟机可以连接外网，要能连上软件更新服务器，该服务器有可能在国外（根据你自己的设置）。命令如下： 1234sudo apt-get autoremove open-vm-toolssudo apt-get install open-vm-toolssudo apt-get install open-vm-tools-desktop 安装完之后最好重启一下虚拟机。安装完Vmware tools并正确配置后就可以实现主机和虚拟机双向内容复制、粘贴，包括文件的拷贝。","categories":[{"name":"2023","slug":"2023","permalink":"http://example.com/categories/2023/"}],"tags":[{"name":"vmware","slug":"vmware","permalink":"http://example.com/tags/vmware/"}]},{"title":"Spark入门：RDD编程","slug":"spark","date":"2023-03-13T13:47:53.892Z","updated":"2023-03-13T17:00:55.622Z","comments":true,"path":"2023/03/13/spark/","link":"","permalink":"http://example.com/2023/03/13/spark/","excerpt":"Spark入门：RDD编程","text":"Spark入门：RDD编程 RDD创建RDD可以通过两种方式创建： 第一种：读取一个外部数据集。比如，从本地文件加载数据集，或者从HDFS文件系统、HBase、Cassandra、Amazon S3等外部数据源中加载数据集。Spark可以支持文本文件、SequenceFile文件（Hadoop提供的 SequenceFile是一个由二进制序列化过的key&#x2F;value的字节流组成的文本存储文件）和其他符合Hadoop InputFormat格式的文件。 第二种：调用SparkContext的parallelize方法，在Driver中一个已经存在的集合（数组）上创建 在即将进行相关的实践操作之前，我们首先要登录Linux系统（本教程统一采用hadoop用户登录），然后，打开命令行“终端”，请按照下面的命令启动Hadoop中的HDFS组件： 创建RDD之前的准备工作在即将进行相关的实践操作之前，我们首先要登录Linux系统（本教程统一采用hadoop用户登录），然后，打开命令行“终端”，请按照下面的命令启动Hadoop中的HDFS组件： 12cd /usr/local/hadoop./sbin/start-dfs.sh 然后，我们按照下面命令启动spark-shell： 12cd /usr/local/spark./bin/pyspark 然后，新建第二个“终端”，方法是，在前面已经建设的第一个终端窗口的左上方，点击“终端”菜单，在弹出的子菜单中选择“新建终端”，就可以打开第二个终端窗口，现在，我们切换到第二个终端窗口，在第二个终端窗口中，执行以下命令，进入之前已经创建好的“&#x2F;usr&#x2F;local&#x2F;spark&#x2F;mycode&#x2F;”目录，在这个目录下新建rdd子目录，用来存放本章的代码和相关文件： 12cd usr/local/spark/mycode/mkdir rdd 然后，使用vim编辑器，在rdd目录下新建一个word.txt文件，你可以在文件里面随便输入几行英文语句用来测试。 经过上面的准备工作以后，我们就可以开始创建RDD了。 从文件系统中加载数据创建RDDSpark采用textFile()方法来从文件系统中加载数据创建RDD，该方法把文件的URI作为参数，这个URI可以是本地文件系统的地址，或者是分布式文件系统HDFS的地址，或者是Amazon S3的地址等等。下面请切换回spark-shell窗口，看一下如何从本地文件系统中加载数据： 12&gt;&gt;&gt;lines = sc.textFile(&quot;file:///usr/local/spark/mycode/rdd/word.txt&quot;) 1&gt;&gt;&gt;lines.foreach(print) 加载HDFS中的文件为了能够读取HDFS中的文件，请首先启动Hadoop中的HDFS组件。注意，之前我们在“Spark安装”这章内容已经介绍了如何安装Hadoop和Spark，所以，这里我们可以使用以下命令直接启动Hadoop中的HDFS组件（由于用不到MapReduce组件，所以，不需要启动MapReduce或者YARN）。请到第二个终端窗口，使用Linux Shell命令提示符状态，然后输入下面命令： 12cd /usr/local/hadoop./sbin/start-dfs.sh 启动结束后，HDFS开始进入可用状态。如果你在HDFS文件系统中，还没有为当前Linux登录用户创建目录(本教程统一使用用户名hadoop登录Linux系统)，请使用下面命令创建： 1./bin/hdfs dfs -mkdir -p /user/hadoop 也就是说，HDFS文件系统为Linux登录用户开辟的默认目录是“&#x2F;user&#x2F;用户名”（注意：是user，不是usr），本教程统一使用用户名hadoop登录Linux系统，所以，上面创建了“&#x2F;user&#x2F;hadoop”目录，再次强调，这个目录是在HDFS文件系统中，不在本地文件系统中。创建好以后，下面我们使用命令查看一下HDFS文件系统中的目录和文件： 1./bin/hdfs dfs -ls . ** 但这个命令我搞不出来，显示的是这个 – 上面命令中，最后一个点号“.”，表示要查看Linux当前登录用户hadoop在HDFS文件系统中与hadoop对应的目录下的文件，也就是查看HDFS文件系统中“&#x2F;user&#x2F;hadoop&#x2F;”目录下的文件，所以，下面两条命令是等价的： – 12./bin/hdfs dfs -ls ../bin/hdfs dfs -ls /user/hadoop 你自己可以试一试，只有第二个可以用 如果要查看HDFS文件系统根目录下的内容，需要使用下面命令： 1./bin/hdfs dfs -ls / 然后输出的东西见上面那个图，有一个items 下面，我们把本地文件系统中的“&#x2F;usr&#x2F;local&#x2F;spark&#x2F;mycode&#x2F;rdd&#x2F;word.txt”上传到分布式文件系统HDFS中（放到hadoop用户目录下）： 1./bin/hdfs dfs -put /usr/local/spark/mycode/rdd/word.txt /user/hadoop 然后，用命令查看一下HDFS的hadoop用户目录下是否多了word.txt文件，可以使用下面命令列出hadoop目录下的内容： 1./bin/hdfs dfs -ls / 可以看到，确实多了一个word.txt文件，我们使用cat命令查看一个HDFS中的word.txt文件的内容，命令如下： 1./bin/hdfs dfs -cat ./word.txt 上面命令执行后，就会看到HDFS中word.txt的内容了。 现在，让我们切换回到spark-shell窗口，编写语句从HDFS中加载word.txt文件，并显示第一行文本内容： 12&gt;&gt;&gt;lines= sc.textFile(&quot;hdfs://localhost:9000/user/hadoop/word.txt&quot;)&gt;&gt;&gt;lines=sc.foreach(print) 注意，上面三条命令是完全等价的命令，只不过使用了不同的目录形式，你可以使用其中任意一条命令完成数据加载操作。 在使用Spark读取文件时，需要说明以下几点：（1）如果使用了本地文件系统的路径，那么，必须要保证在所有的worker节点上，也都能够采用相同的路径访问到该文件，比如，可以把该文件拷贝到每个worker节点上，或者也可以使用网络挂载共享文件系统。（2）textFile()方法的输入参数，可以是文件名，也可以是目录，也可以是压缩文件等。比如，textFile(“&#x2F;my&#x2F;directory”), textFile(“&#x2F;my&#x2F;directory&#x2F;.txt”), and textFile(“&#x2F;my&#x2F;directory&#x2F;.gz”).（3）textFile()方法也可以接受第2个输入参数（可选），用来指定分区的数目。默认情况下，Spark会为HDFS的每个block创建一个分区（HDFS中每个block默认是128MB）。你也可以提供一个比block数量更大的值作为分区数目，但是，你不能提供一个小于block数量的值作为分区数目。 通过并行集合（数组）创建RDD可以调用SparkContext的parallelize方法，在Driver中一个已经存在的集合（数组）上创建。下面请在spark-shell中操作： 123&gt;&gt;&gt;array = [1,2,3,4,5]&gt;&gt;&gt;rdd = sc.parallelize(array)&gt;&gt;&gt;rdd.foreach(print) RDD操作RDD被创建好以后，在后续使用过程中一般会发生两种操作：*  转换（Transformation）： 基于现有的数据集创建一个新的数据集。*  行动（Action）：在数据集上进行运算，返回计算值。 转换操作对于RDD而言，每一次转换操作都会产生不同的RDD，供给下一个“转换”使用。转换得到的RDD是惰性求值的，也就是说，整个转换过程只是记录了转换的轨迹，并不会发生真正的计算，只有遇到行动操作时，才会发生真正的计算，开始从血缘关系源头开始，进行物理的转换操作。下面列出一些常见的转换操作（Transformation API）：* filter(func)：筛选出满足函数func的元素，并返回一个新的数据集* map(func)：将每个元素传递到函数func中，并将结果返回为一个新的数据集* flatMap(func)：与map()相似，但每个输入元素都可以映射到0或多个输出结果* groupByKey()：应用于(K,V)键值对的数据集时，返回一个新的(K, Iterable)形式的数据集* reduceByKey(func)：应用于(K,V)键值对的数据集时，返回一个新的(K, V)形式的数据集，其中的每个值是将每个key传递到函数func中进行聚合 1.filter(func) 好吧，这个书上说要把word.txt写成 12345Hadoop is goodSpark is fastSpark is better 那我们就 1cd /usr/local/spark/mycode/rdd 1gedit word.txt 然后再 123&gt;&gt;&gt;lines=sc.textFile(&quot;file:///usr/local/spark/mycode/rdd/word.txt&quot;)&gt;&gt;&gt;linesWithSpark = lines.filter(lambda line: &quot;Spark&quot; in line)&gt;&gt;&gt;linesWithSpark.foreach(print) 上面的代码中，lines就是一个RDD。lines.filter()会遍历lines中的每行文本，并对每行文本执行括号中的匿名函数，也就是执行Lamda表达式：line &#x3D;&gt; line.contains(“Spark”)，在执行Lamda表达式时，会把当前遍历到的这行文本内容赋值给参数line，然后，执行处理逻辑line.contains(“Spark”)，也就是只有当改行文本包含“Spark”才满足条件，才会被放入到结果集中。最后，等到lines集合遍历结束后，就会得到一个结果集，这个结果集中包含了所有包含“Spark”的行。最后，对这个结果集调用count()，这是一个行动操作，会计算出结果集中的元素个数。 2.map(func) map(func)：将每个元素传递到函数func中，并将结果返回为一个新的数据集 1234&gt;&gt;&gt; data =[1,2,3,4,5]&gt;&gt;&gt; rdd1 = sc.parallelize(data)&gt;&gt;&gt; rdd2 = rdd1.map(lambda x:x+10)&gt;&gt;&gt; rdd2.foreach(print) 上述语句执行过程如图 所示。第 1行语句创建了一个包含 5 个整型元素的列表 data。第2行语句执行 sc.parallelize(data)，从列表 data 中生成一个 RDD，即 rdd1,rdd1 中包含了5 个整型的元素即1、2、3、4、5。第 3 行语句执行 rdd1.map0操作,map0的输入参数“lambda x:x+10”是一个Lambda表达式。rdd1.map(lambda x:x+10)的含义是，依次取出 rdd1 这个RDD 中的每个元素，对于当前取到的元素，把它赋值给 Lambda 表达式中的变量x，然后，执行 Lambda 表达式的函数体部分“x+10”也就是把变量x的值和 10 相加后，作为函数的返回值，并作为一个元素放入到新的 RDD(即rdd2中。最终，新牛成的RDD (即 rdd2) 中包含了 5 个整型元素，即 11、12、13、14、15。 另外一个实例： 123&gt;&gt;&gt;lines=sc.textFile(&quot;file:///usr/local/spark/mycode/rdd/word.txt&quot;)&gt;&gt;&gt; words = lines.map(lambda line:line.split(&quot; &quot;))&gt;&gt;&gt; words.foreach(print) 上述语句执行过程如图所示。在第 1 行语句中，执行 sc.textFile0方法把 word.txt 文件中的数据加载到内存生成一个 RDD，即 lines，这个RDD 中的每个元素都是字符串类型，即每个 RDD 元素都是一行文本，比如，lines 中的第 1 个元素是”Hadoop is good”，第2 个元素是”Spark is fast”，第3个元素是”Spark is better”。在第 2 行语句中，执行 lies.map0操作，map0的输入参数 lambdaline:line.split(“)是一个 Lambda 表达式。linesmap(lambda line:line.split(“”)的含义是，依次取出 lines这个 RDD 中的每个元素，对于当前取到的元素，把它赋值给 Lambda 表达式中的变量 line，然后，执行 Lambda 表达式的函数体部分 line.split(“”)。因为 line 是一行文本，如”Hadoop is good”，一行文本中包含了很多个单词，单词之间以空格进行分隔，所以，line.split(“”的功能是，以空格作为分隔符把 line 拆分成一个个单词,拆分后得到的单词都封装在一个列表对象中,成为新的 RDD( 即 words)的一个元素，比如，”Hadoop is good”被拆分后，得到”Hadoop”、”is”和”good”3 个单词，会被封装到一个列表对象中，即[“Hadoop”.”is”,”good”]，成为 words 这个 RDD 中的一个元素。 3.flatMap(func)flatMap(func)与 map0相似，但每个输入元素都可以映射到 0 或多个输出结果。例如: 123&gt;&gt;&gt;lines=sc.textFile(&quot;file:///usr/local/spark/mycode/rdd/word.txt&quot;)&gt;&gt;&gt;words =lines.flatMap(lambda line:line.split(&quot; &quot;))&gt;&gt;&gt; words.foreach(print) 上述语句执行过程如图所示。在第 1行语句中，执行 sc.textFile0方法把 wordtxt 文件中的数据加载到内存生成一个RDD，即 lines，这个 RDD 中的每个元素都是字符串类型，即每个RDD 元素都是一行文本。在第2行语句中，执行 linesflatMap0操作，flatMap0的输入参数 line:linesplit(“”)是个Lambda 表达式。lines.flatMap(lambda line:line.split(“”))的结果，等价于如下两步操作的结果。 第1步: map0。执行 lines.map(lambda line: linesplit(“”))操作，从 lines 转换得到一个新的 RDD(即wordArray),wordArray 中的每个元素都是一个列表,比如,第1个元素是[“Hadoop”,”is”，”good”]7.第2个元素是”Spark”，”is”,”fast”]，第3 个元素是[“Spark”,”is””better”]。 第 2步:拍扁 ( flat)。flatMap0操作中的“flat”是一个很形象的动作-“拍扁”，也就是把vordArray 中的每个 RDD 元素都“拍扁”成多个元素。所有这些被拍扁以后得到的元素，构成一个新的 RDD，即 words。比如，wordArray 中的第1个元素是[“Hadoop”,”is”,”good]，被拍扁以后得到3个新的字符串类型的元素,即”Hadoop”、”is”和”good”; wordArray 中的第 2 个元素是[“Spark”,”is”fast”],被拍扁以后得到 3 个新的元素,即”Spark”、”is”和”fast”; wordArray 中的第 3 个元素是[“Spark””is””beter”，被拍扁以后得到 3 个新的元素，即”Spark”、”is”和”beter”。最终，这些被拍扁以后得到的 9 个字符串类型的元素构成一个新的 RDD (即 words )。也就是说，words 里面包含了 9 个字串类型的元素，分别是”Hadoop”、”is”、”good”、”Spark”、”is”、”fast”、”Spark”、”is”和”。","categories":[{"name":"2023","slug":"2023","permalink":"http://example.com/categories/2023/"}],"tags":[{"name":"Spark","slug":"Spark","permalink":"http://example.com/tags/Spark/"}]},{"title":"3-8-2023","slug":"3-8-2023","date":"2023-03-08T05:19:53.978Z","updated":"2023-03-08T05:45:39.860Z","comments":true,"path":"2023/03/08/3-8-2023/","link":"","permalink":"http://example.com/2023/03/08/3-8-2023/","excerpt":"三月初自我反省","text":"三月初自我反省 1.退实验室✔ 2.数学第一章✔ 3.单词200 per day✔ 4.后端增删查改✔ 1234567891011121314151617181920212223def department_list(request): member_list=Department.objects.all() return render(request,&#x27;dep.html&#x27;,&#123;&#x27;member&#x27;:member_list&#125;)def add_dep(request): if request.method==&#x27;GET&#x27;: return render(request,&#x27;adddep.html&#x27;) elif request.method==&#x27;POST&#x27;: title=request.POST.get(&#x27;aatitle&#x27;) Department.objects.create(tittle=title) return redirect(&quot;/dep/list&quot;)def delete_dep(request): memid=request.GET.get(&#x27;memid&#x27;) Department.objects.filter(id=memid).delete() return redirect(&quot;/dep/list&quot;)def edit_dep(request,memid): if request.method==&#x27;GET&#x27;: nnmame=Department.objects.filter(id=memid).first() return render(request,&#x27;editdpt.html&#x27;,&#123;&#x27;nnmame&#x27;:nnmame.tittle&#125;) aatitle=request.POST.get(&#x27;aatitle&#x27;) Department.objects.filter(id=memid).update(tittle=aatitle) return redirect(&quot;/dep/list&quot;) 5.数据结构 图(floyd，dijkstra)✔ 1234567891011121314151617181920212223242526272829303132#include&lt;cstdio&gt;#include&lt;iostream&gt;#include&lt;cmath&gt;#include&lt;cstring&gt;using namespace std;int a[101][3];double f[101][101];int n,i,j,k,x,y,m,s,e;int main()&#123;// freopen(&quot;short.in&quot;,&quot;r&quot;,stdin);// freopen(&quot;short.out&quot;,&quot;w&quot;,stdout); cin&gt;&gt;n; for(i=1;i&lt;=n;i++) cin&gt;&gt;a[i][1]&gt;&gt;a[i][2]; cin&gt;&gt;m; memset(f,0x7f,sizeof(f)); //初始化为最大值 for(i=1;i&lt;=m;i++)&#123; cin&gt;&gt;x&gt;&gt;y;// int temp1=;// int temp2=; f[y][x]=f[x][y]=sqrt(pow(double(a[x][1]-a[y][1]),2)+pow(double(a[x][2]-a[y][2]),2)); &#125; cin&gt;&gt;s&gt;&gt;e; for(k=1;k&lt;=n;k++) for(j=1;j&lt;=n;j++) for(i=1;i&lt;=n;i++) if(f[i][k]+f[k][j]&lt;f[i][j]) f[i][j]=f[i][k]+f[k][j]; printf(&quot;%.2lf\\n&quot;,f[s][e]); return 0; &#125; 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849#include&lt;cstdio&gt;#include&lt;cstring&gt;#define INF 1e4+10using namespace std;const int M=1e4+10;const int N=1000+10;int n,m,s;int mp[N][M];int dis[N],vis[N];void initmp()&#123;memset(mp,INF,sizeof(mp)); &#125;void dijkstra(int s)&#123; //求s点到其它点的最短路径 memset(vis,0,sizeof(vis));//0表示蓝点(未确定最短路径的点)，1表示白点（确定路径的点） memset(dis,0x3f,sizeof(dis));//默认情况下设置为无穷大 dis[s]=0; while(1)&#123; int mini=0,min_=INF; for(int j=1;j&lt;=n;j++)&#123; if(!vis[j]&amp;&amp;min_&gt;dis[j])&#123;//从蓝点中找出最小的点 .vis[j](蓝点)为0,那么!vis[j]就为1了.dis[j]是权值 mini=j;//记录第几个点 min_=dis[j]; //记录最短的路的距离 &#125; &#125; //如果没有蓝点就提前结束 if(mini==0) break; vis[mini]=1;//变成白点 for(int i=1;i&lt;=n;i++)&#123; if(dis[i]&gt;dis[mini]+mp[mini][i]) dis[i]=dis[mini]+mp[mini][i]; &#125; &#125; &#125;int main()&#123; memset(mp,INF,sizeof(mp)); while(scanf(&quot;%d %d&quot;,&amp;n,&amp;m)!=EOF&amp;&amp;n)&#123; initmp();//每次清空mp for(int i=0;i&lt;m;i++)&#123; int u,v,w; scanf(&quot;%d %d %d&quot;,&amp;u,&amp;v,&amp;w); if(mp[u][v]&gt;w) mp[u][v]=mp[v][u]=w; &#125; dijkstra(1); printf(&quot;%d\\n&quot;,dis[n]); &#125; return 0;&#125;","categories":[{"name":"2023","slug":"2023","permalink":"http://example.com/categories/2023/"}],"tags":[{"name":"casual_talk","slug":"casual-talk","permalink":"http://example.com/tags/casual-talk/"}]},{"title":"DataError at /index/add_member 1366, \"Incorrect string value :\\\\xE4\\\\xBC\\\\x98\\\\xE","slug":"ERROR 1366 (HY000)Incorrect string value解决方案","date":"2023-03-05T03:11:11.586Z","updated":"2023-03-08T05:16:49.900Z","comments":true,"path":"2023/03/05/ERROR 1366 (HY000)Incorrect string value解决方案/","link":"","permalink":"http://example.com/2023/03/05/ERROR%201366%20(HY000)Incorrect%20string%20value%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/","excerpt":"&#x38;&#x32;&#53;&#53;&#x37;&#x37;&#x39;&#x34;&#x30;&#64;&#113;&#x71;&#46;&#99;&#x6f;&#x6d; DataError at &#x2F;index&#x2F;add_member 1366, “Incorrect string value: ‘\\xE4\\xBC\\x98\\xE ERROR 1366 (HY000):Incorrect string value解决方案","text":"&#x38;&#x32;&#53;&#53;&#x37;&#x37;&#x39;&#x34;&#x30;&#64;&#113;&#x71;&#46;&#99;&#x6f;&#x6d; DataError at &#x2F;index&#x2F;add_member 1366, “Incorrect string value: ‘\\xE4\\xBC\\x98\\xE ERROR 1366 (HY000):Incorrect string value解决方案 https://zhuanlan.zhihu.com/p/53941345 after before 然后把数据库删除，重新创建数据库，再导入数据库文件，就又是一条好汉","categories":[{"name":"2023","slug":"2023","permalink":"http://example.com/categories/2023/"}],"tags":[{"name":"mysql","slug":"mysql","permalink":"http://example.com/tags/mysql/"}]},{"title":"远离不规范书籍，不然会变得不幸","slug":"远离不规范书籍，不然会变得不幸","date":"2023-03-04T09:14:48.511Z","updated":"2023-03-08T05:16:54.675Z","comments":true,"path":"2023/03/04/远离不规范书籍，不然会变得不幸/","link":"","permalink":"http://example.com/2023/03/04/%E8%BF%9C%E7%A6%BB%E4%B8%8D%E8%A7%84%E8%8C%83%E4%B9%A6%E7%B1%8D%EF%BC%8C%E4%B8%8D%E7%84%B6%E4%BC%9A%E5%8F%98%E5%BE%97%E4%B8%8D%E5%B9%B8/","excerpt":"远离不规范书籍,不然会变得不幸","text":"远离不规范书籍,不然会变得不幸","categories":[{"name":"2023","slug":"2023","permalink":"http://example.com/categories/2023/"}],"tags":[{"name":"casual_talk","slug":"casual-talk","permalink":"http://example.com/tags/casual-talk/"}]},{"title":"2月开学总结","slug":"2月开学总结","date":"2023-03-01T06:57:51.608Z","updated":"2023-03-08T05:15:23.317Z","comments":true,"path":"2023/03/01/2月开学总结/","link":"","permalink":"http://example.com/2023/03/01/2%E6%9C%88%E5%BC%80%E5%AD%A6%E6%80%BB%E7%BB%93/","excerpt":"2月开学总结","text":"2月开学总结 每日200单词，真的坚持不下来（我妈说过一句老话：新的马桶只有三天是香的） 周五-周日每日50页django目前停滞（p117），在后渲前的简单&#123;&#123;&#125;&#125;不清楚具体语法，有时间看b具体简单讲解，我实在无法理解，这种书怎么出版的，前20页每页都有错误，这个人抄官方文档都能抄错？？？？！！！ 问了师姐她复习进度，四月之前（include四月）刷完1800,以及师姐说英二难度比江苏高考英语难度小 临时接了挑战杯的复赛答辩，要准备讲演稿子 目前数学进度第一章（第一遍做不到不看视频（看视频时真的费时间），但已经都忘了（为什么上学期我要拒绝高数老师让我做她的助教（扇自己耳光））） 英语6级太难了 准备算法考试 所有的东西并行真的做不到，一天只能选一个（上周多线程进行复习&amp;&amp;学习，效率极低） 佛山顺德愿望get 实验室老师开始整幺蛾子了：周四下午7、8节加了一节选修课。明天去一节看看情况，不行就退实验室;以及未来一个月内实验室搬迁，不行就退。 昨天去交材料，党建的辅导老师说：好久没看见你了，你最近在干嘛。 我：准备考研，和实验室的东西。 老师:你准备考研的话要平衡比赛和考研准备的东西 老师:考研的书差不多要买了 我：嗯嗯12.仰天长叹，下个月三场考试，4月份一轮，师姐说828要在这学期内过完，操作系统跟着这学期的老师好好学一遍，就没什么问题，我真的能平衡吗……实验室感觉差不多可以退了，但又想拼一把计算机设计大赛，自己再做个东西出来…… emoji format 本来想花15min解决的note，花了1个小时的原因窒息","categories":[{"name":"2023","slug":"2023","permalink":"http://example.com/categories/2023/"}],"tags":[{"name":"casual_talk","slug":"casual-talk","permalink":"http://example.com/tags/casual-talk/"}]},{"title":"Import pymysql could not be resolved from","slug":"Import pymysql could not be resolved from","date":"2023-02-26T13:23:28.035Z","updated":"2023-03-13T16:56:38.944Z","comments":true,"path":"2023/02/26/Import pymysql could not be resolved from/","link":"","permalink":"http://example.com/2023/02/26/Import%20pymysql%20could%20not%20be%20resolved%20from/","excerpt":"Import “pymysql” could not be resolved from","text":"Import “pymysql” could not be resolved from 在anaconda里面装一个 首先先切进django的虚拟环境里面 在Anaconda中，可以通过使用conda命令来创建和管理虚拟环境。要切换已创建的虚拟环境，可以使用以下命令： 列出已有环境： 1conda info --envs 激活目标环境： 1conda activate &lt;env_name&gt; 这里&lt;env_name&gt;是你想要激活的虚拟环境的名称。激活环境后，你可以在该环境中使用安装的软件包和工具。 取消激活当前环境： 1conda deactivate 这将使当前环境不再处于活动状态，回到默认的基础环境。 注意：如果你在使用Anaconda Navigator，也可以通过选择“Environments”选项卡，然后单击目标环境的名称来激活虚拟环境。 conda install pymysql 看你anaconda用的是什么源，国内的记得关闭魔法上网工具","categories":[{"name":"2023","slug":"2023","permalink":"http://example.com/categories/2023/"}],"tags":[{"name":"django","slug":"django","permalink":"http://example.com/tags/django/"}]},{"title":"官方文档","slug":"null¶","date":"2023-02-24T12:24:35.657Z","updated":"2023-03-01T07:09:14.756Z","comments":true,"path":"2023/02/24/null¶/","link":"","permalink":"http://example.com/2023/02/24/null%C2%B6/","excerpt":"https://stackoverflow.com/questions/19428572/django-templatesyntaxerror-could-not-parse-the-remainder","text":"https://stackoverflow.com/questions/19428572/django-templatesyntaxerror-could-not-parse-the-remainder 模型字段参考 字段选项 https://docs.djangoproject.com/zh-hans/4.1/ref/models/fields/#validators 以下参数对所以字段类型均有效，且是可选的。 null¶ Field.``null¶ 如果是 True， Django 将在数据库中存储空值为 NULL。默认为 False。 避免在基于字符串的字段上使用 null，如 CharField 和 TextField。如果一个基于字符串的字段有 null=True，这意味着它有两种可能的“无数据”值。NULL，和空字符串。在大多数情况下，“无数据”有两种可能的值是多余的，Django 的惯例是使用空字符串，而不是 NULL。一个例外是当一个 CharField 同时设置了 unique=True 和 blank=True。在这种情况下，null=True 是需要的，以避免在保存具有空白值的多个对象时违反唯一约束。 无论是基于字符串的字段还是非字符串的字段，如果希望在表单中允许空值，还需要设置 blank=True，因为 null 参数只影响数据库的存储（参见 blank ）。","categories":[{"name":"2023","slug":"2023","permalink":"http://example.com/categories/2023/"}],"tags":[{"name":"django","slug":"django","permalink":"http://example.com/tags/django/"}]},{"title":"Module \"django.contrib.sessions.serializers\" does not define a \"PicleSerializer\" attribute/class","slug":"Module django.contrib.sessions.serializers does not define a PicleSerializer attributeclass","date":"2023-02-24T07:05:59.648Z","updated":"2023-03-01T07:09:09.742Z","comments":true,"path":"2023/02/24/Module django.contrib.sessions.serializers does not define a PicleSerializer attributeclass/","link":"","permalink":"http://example.com/2023/02/24/Module%20django.contrib.sessions.serializers%20does%20not%20define%20a%20PicleSerializer%20attributeclass/","excerpt":"Module “django.contrib.sessions.serializers” does not define a “PicleSerializer” attribute&#x2F;class","text":"Module “django.contrib.sessions.serializers” does not define a “PicleSerializer” attribute&#x2F;class 是这本书打错了hhhh https://docs.djangoproject.com/zh-hans/4.1/topics/http/sessions/ 在这里ctrl+F找 serializers 最后一个 serializers.``PickleSerializer tmd是这个玩意儿！ 不是picle睡觉哦pick 服了这个写书的老六！","categories":[{"name":"2023","slug":"2023","permalink":"http://example.com/categories/2023/"}],"tags":[{"name":"django","slug":"django","permalink":"http://example.com/tags/django/"}]},{"title":"无法加载文件C:\\Users\\xxx\\Documents\\WindowsPowerShell\\profile.ps1","slug":"无法加载文件CUsersxxxDocumentsWindowsPowerShellprofile.ps1，因为在此系统上禁止运行脚本","date":"2023-02-24T04:38:04.277Z","updated":"2023-03-01T07:08:52.941Z","comments":true,"path":"2023/02/24/无法加载文件CUsersxxxDocumentsWindowsPowerShellprofile.ps1，因为在此系统上禁止运行脚本/","link":"","permalink":"http://example.com/2023/02/24/%E6%97%A0%E6%B3%95%E5%8A%A0%E8%BD%BD%E6%96%87%E4%BB%B6CUsersxxxDocumentsWindowsPowerShellprofile.ps1%EF%BC%8C%E5%9B%A0%E4%B8%BA%E5%9C%A8%E6%AD%A4%E7%B3%BB%E7%BB%9F%E4%B8%8A%E7%A6%81%E6%AD%A2%E8%BF%90%E8%A1%8C%E8%84%9A%E6%9C%AC/","excerpt":"无法加载文件C:\\Users\\xxx\\Documents\\WindowsPowerShell\\profile.ps1，因为在此系统上禁止运行脚本","text":"无法加载文件C:\\Users\\xxx\\Documents\\WindowsPowerShell\\profile.ps1，因为在此系统上禁止运行脚本 问题描述打开 PowerShell 提示如下报错信息。 123456789101112Windows PowerShell版权所有（C） Microsoft Corporation。保留所有权利。安装最新的 PowerShell，了解新功能和改进！https://aka.ms/PSWindows. : 无法加载文件 C:\\Users\\87897\\Documents\\WindowsPowerShell\\profile.ps1，因为在此系统上禁止运行脚本。有关详细信息，请参阅 https:/go.microsoft.com/fwlink/?LinkID=135170 中的 about_Execution_Policies。所在位置 行:1 字符: 3+ . &#x27;C:\\Users\\87897\\Documents\\WindowsPowerShell\\profile.ps1&#x27;+ ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ + CategoryInfo : SecurityError: (:) []，PSSecurityException1234567891011 原因分析输入 get-ExecutionPolicy 输出 Restricted，即脚本执行策略受限。 123PS C:\\Windows\\system32&gt; get-ExecutionPolicyRestricted12 解决方案更换脚本执行策略：set-ExecutionPolicy RemoteSigned，然后输入 Y。 1234567PS C:\\Windows\\system32&gt; set-ExecutionPolicy RemoteSigned执行策略更改执行策略可帮助你防止执行不信任的脚本。更改执行策略可能会产生安全风险，如 https:/go.microsoft.com/fwlink/?LinkID=135170中的 about_Execution_Policies 帮助主题所述。是否要更改执行策略?[Y] 是(Y) [A] 全是(A) [N] 否(N) [L] 全否(L) [S] 暂停(S) [?] 帮助 (默认值为“N”): Y123456 更换完成后，再次使用命令 get-ExecutionPolicy 查看脚本执行策略。 123PS C:\\Windows\\system32&gt; get-ExecutionPolicyRemoteSigned12 可以发现已经更改了。问题完美解决，over~~😊","categories":[{"name":"2023","slug":"2023","permalink":"http://example.com/categories/2023/"}],"tags":[{"name":"powershell","slug":"powershell","permalink":"http://example.com/tags/powershell/"}]},{"title":"anaconda安装其他东西","slug":"Win10下Anaconda使用conda activate报错Your shell has not been properly configured to use 'conda activate'","date":"2023-02-24T04:23:35.093Z","updated":"2023-03-08T05:18:49.483Z","comments":true,"path":"2023/02/24/Win10下Anaconda使用conda activate报错Your shell has not been properly configured to use 'conda activate'/","link":"","permalink":"http://example.com/2023/02/24/Win10%E4%B8%8BAnaconda%E4%BD%BF%E7%94%A8conda%20activate%E6%8A%A5%E9%94%99Your%20shell%20has%20not%20been%20properly%20configured%20to%20use%20'conda%20activate'/","excerpt":"Win10下Anaconda使用conda activate报错Your shell has not been properly configured to use ‘conda activate’","text":"Win10下Anaconda使用conda activate报错Your shell has not been properly configured to use ‘conda activate’ 1234567891011121314151617181920212223PS E:\\dijango&gt; conda activate baseCommandNotFoundError: Your shell has not been properly configured to use &#x27;conda activate&#x27;.If using &#x27;conda activate&#x27; from a batch script, change yourinvocation to &#x27;CALL conda.bat activate&#x27;.To initialize your shell, run $ conda init &lt;SHELL_NAME&gt;Currently supported shells are:- bash- cmd.exe- fish- tcsh- xonsh- zsh- powershellSee &#x27;conda init --help&#x27; for more information and options.IMPORTANT: You may need to close and restart your shell after running &#x27;conda init&#x27;. 先以管理员身份打开cmd。试一下conda activate 环境名称。如果命令行提示 1Your shell has not been properly configured to use ‘conda activate’. 然后下面还提示 conda init &lt;SHELL NAME&gt; 就按照他的要求，输入一下 conda init cmd.exe 或者 conda init powershell 这两条都试试，回车，重启cmd说不定就好了。反正我好了。","categories":[{"name":"2023","slug":"2023","permalink":"http://example.com/categories/2023/"}],"tags":[{"name":"anaconda","slug":"anaconda","permalink":"http://example.com/tags/anaconda/"}]},{"title":"闭包","slug":"闭包","date":"2023-02-23T14:17:31.662Z","updated":"2023-02-23T13:50:32.190Z","comments":true,"path":"2023/02/23/闭包/","link":"","permalink":"http://example.com/2023/02/23/%E9%97%AD%E5%8C%85/","excerpt":"闭包","text":"闭包 12345678910111213141516171819202122232425262728// 1.污染环境的全局变量实现函数执行一次次数减一 var a=10; function fa()&#123; a--; console.log(a); &#125; // 2.那就换成局部变量试试 function fb()&#123; var a=10; a--; console.log(a); &#125;/*它居然不动了*/ // 3.闭包 function fc()&#123; let a=10; function fd()&#123; a--; console.log(a); &#125; return fd; &#125; var fm=fc();//完成这句才算闭包 // 总结 // 1.有嵌套函数 // 2.内部函数引用外部作用域 // 3.返回值是函数 // 4.船舰一个对象函数，让其长期驻留","categories":[{"name":"2022","slug":"2022","permalink":"http://example.com/categories/2022/"}],"tags":[{"name":"js","slug":"js","permalink":"http://example.com/tags/js/"}]},{"title":"reat-router","slug":"router","date":"2023-02-23T14:17:31.647Z","updated":"2023-02-23T13:50:45.673Z","comments":true,"path":"2023/02/23/router/","link":"","permalink":"http://example.com/2023/02/23/router/","excerpt":"随意使用您选择的打包器，例如 Create React App 1npx create-react-app router-tutorial","text":"随意使用您选择的打包器，例如 Create React App 1npx create-react-app router-tutorial 然后安装 React Router 依赖项： 12cd router-tutorialnpm install react-router-dom@6 history@5 然后编辑你的App.js，让它变得很无聊: 1234567export default function App() &#123; return ( &lt;div&gt; &lt;h1&gt;Bookkeeper!&lt;/h1&gt; &lt;/div&gt; );&#125; 最后，确认index.js or main.jsx（取决于你的打包工具）是可用的： root渲染App 123456import &#123; render &#125; from &quot;react-dom&quot;;import App from &quot;./App&quot;;const rootElement = document.getElementById(&quot;root&quot;);render(&lt;App /&gt;, rootElement); 然后是删了一点东西 启动您的React应用： 1npm start 连接路由首先，我们想把你的应用连接到路由: import ‘ BrowserRouter ‘，并用它包裹你的整个应用。(修改index.js) 1234567891011import &#123; render &#125; from &quot;react-dom&quot;;import &#123; BrowserRouter &#125; from &quot;react-router-dom&quot;;import App from &quot;./App&quot;;const rootElement = document.getElementById(&quot;root&quot;);render( &lt;BrowserRouter&gt; &lt;App /&gt; &lt;/BrowserRouter&gt;, rootElement); 应用程序中没有任何变化，但现在我们已准备好开始处理路由。 添加一些链接打开 src&#x2F;App.js、导入 Link 并添加一些全局导航。注：在本教程中不要对待样式太认真，我们只是为了方便而使用内联样式，你可以根据需要设置样式。 123456789101112131415161718import &#123; Link &#125; from &quot;react-router-dom&quot;;export default function App() &#123; return ( &lt;div&gt; &lt;h1&gt;Bookkeeper&lt;/h1&gt; &lt;nav style=&#123;&#123; borderBottom: &quot;solid 1px&quot;, paddingBottom: &quot;1rem&quot; &#125;&#125; &gt; &lt;Link to=&quot;/invoices&quot;&gt;Invoices&lt;/Link&gt; |&#123;&quot; &quot;&#125; &lt;Link to=&quot;/expenses&quot;&gt;Expenses&lt;/Link&gt; &lt;/nav&gt; &lt;/div&gt; );&#125; 单击链接和后退&#x2F;前进按钮。React Router 现在正在控制 URL！ 我们还没有在 URL 更改时呈现任何路由，但 Link 可以更改 URL，而不会导致整个页面重新加载。 添加一些路由添加几个新文件： src/routes/invoices.jsx src/routes/expenses.jsx (文件的位置并不重要，但是当你想要自动生成后端API，服务器渲染，代码分割或者更多的功能时，像这样命名你的文件可以很容易地将这个应用程序移植到其他项目，Remix😉) 现在在文件中加入以下代码： expenses.jsx 1234567export default function Expenses() &#123; return ( &lt;main style=&#123;&#123; padding: &quot;1rem 0&quot; &#125;&#125;&gt; &lt;h2&gt;Expenses&lt;/h2&gt; &lt;/main&gt; );&#125; invoices.jsx 1234567export default function Invoices() &#123; return ( &lt;main style=&#123;&#123; padding: &quot;1rem 0&quot; &#125;&#125;&gt; &lt;h2&gt;Invoices&lt;/h2&gt; &lt;/main&gt; );&#125; 最后，让我们通过在main.jsx或者index.js 中创建我们的第一个“路由配置”来让 React Router 在不同的 URL 上呈现我们的界面。 123456789101112131415161718192021import &#123; render &#125; from &quot;react-dom&quot;;import &#123; BrowserRouter, Routes, Route&#125; from &quot;react-router-dom&quot;;import App from &quot;./App&quot;;import Expenses from &quot;./routes/expenses&quot;;import Invoices from &quot;./routes/invoices&quot;;const rootElement = document.getElementById(&quot;root&quot;);render( &lt;BrowserRouter&gt; &lt;Routes&gt; &lt;Route path=&quot;/&quot; element=&#123;&lt;App /&gt;&#125; /&gt; &lt;Route path=&quot;expenses&quot; element=&#123;&lt;Expenses /&gt;&#125; /&gt; &lt;Route path=&quot;invoices&quot; element=&#123;&lt;Invoices /&gt;&#125; /&gt; &lt;/Routes&gt; &lt;/BrowserRouter&gt;, rootElement); 注意：当路由为”&#x2F;“时它渲染App组件，在”&#x2F;invoices”时它渲染Invoices组件。 所以到这里我们可以看出，点击后会整页都会变换掉 嵌套路由你可能已经注意到，当点击链接时，“App”中的布局会消失。共享布局是一件令人头疼的事情。我们已经知道，大多数UI都是一系列嵌套布局，这些布局总会映射到URL上，所以这个思路被直接植入到React Router中。 12345678910111213141516171819202122import &#123; render &#125; from &quot;react-dom&quot;;import &#123; BrowserRouter, Routes, Route&#125; from &quot;react-router-dom&quot;;import App from &quot;./App&quot;;import Expenses from &quot;./routes/expenses&quot;;import Invoices from &quot;./routes/invoices&quot;;const rootElement = document.getElementById(&quot;root&quot;);render( &lt;BrowserRouter&gt; &lt;Routes&gt; &lt;Route path=&quot;/&quot; element=&#123;&lt;App /&gt;&#125;&gt; &lt;Route path=&quot;expenses&quot; element=&#123;&lt;Expenses /&gt;&#125; /&gt; &lt;Route path=&quot;invoices&quot; element=&#123;&lt;Invoices /&gt;&#125; /&gt; &lt;/Route&gt; &lt;/Routes&gt; &lt;/BrowserRouter&gt;, rootElement); 当路由有子节点时，它会做两件事： 它嵌套了 URL (&quot;/&quot; + &quot;expenses&quot; 和 &quot;/&quot; + &quot;invoices&quot;) 当子路由匹配时，它将嵌套共享布局的 UI 组件： 但是，为了使（2）生效，我们需要在App.jsx“父”路由中渲染一个 组件。 12345678910111213141516171819import &#123; Outlet, Link &#125; from &quot;react-router-dom&quot;;export default function App() &#123; return ( &lt;div&gt; &lt;h1&gt;Bookkeeper&lt;/h1&gt; &lt;nav style=&#123;&#123; borderBottom: &quot;solid 1px&quot;, paddingBottom: &quot;1rem&quot; &#125;&#125; &gt; &lt;Link to=&quot;/invoices&quot;&gt;Invoices&lt;/Link&gt; |&#123;&quot; &quot;&#125; &lt;Link to=&quot;/expenses&quot;&gt;Expenses&lt;/Link&gt; &lt;/nav&gt; &lt;Outlet /&gt; &lt;/div&gt; );&#125; 现在再次单击。父路由 ( App.js) 仍然存在，而 &lt;Outlet&gt; 在两个子路由 (&lt;Invoices&gt; 和 &lt;Expenses&gt;)之间切换！ 正如我们稍后将看到的，这适用于路由层次结构的任何级别，并且非常强大。 列出发票通常你会从某个地方的服务器获取数据，但在本教程中，让我们造一些数据，这样我们就可以专注于路由。 创建一个文件src&#x2F;data.js并将其复制&#x2F;粘贴到那里： 123456789101112131415161718192021222324252627282930313233343536let invoices = [ &#123; name: &quot;Santa Monica&quot;, number: 1995, amount: &quot;$10,800&quot;, due: &quot;12/05/1995&quot; &#125;, &#123; name: &quot;Stankonia&quot;, number: 2000, amount: &quot;$8,000&quot;, due: &quot;10/31/2000&quot; &#125;, &#123; name: &quot;Ocean Avenue&quot;, number: 2003, amount: &quot;$9,500&quot;, due: &quot;07/22/2003&quot; &#125;, &#123; name: &quot;Tubthumper&quot;, number: 1997, amount: &quot;$14,000&quot;, due: &quot;09/01/1997&quot; &#125;, &#123; name: &quot;Wide Open Spaces&quot;, number: 1998, amount: &quot;$4,600&quot;, due: &quot;01/27/2998&quot; &#125;];export function getInvoices() &#123; return invoices;&#125; 现在我们可以在发票路由中使用它。让我们也添加一些样式来获得侧边栏导航布局。随意复制&#x2F;粘贴所有这些，但要特别注意 &lt;Link&gt; 组件需要 to 属性： 1234567891011121314151617181920212223242526import &#123; Link &#125; from &quot;react-router-dom&quot;;import &#123; getInvoices &#125; from &quot;../data&quot;;export default function Invoices() &#123; let invoices = getInvoices(); return ( &lt;div style=&#123;&#123; display: &quot;flex&quot; &#125;&#125;&gt; &lt;nav style=&#123;&#123; borderRight: &quot;solid 1px&quot;, padding: &quot;1rem&quot; &#125;&#125; &gt; &#123;invoices.map(invoice =&gt; ( &lt;Link style=&#123;&#123; display: &quot;block&quot;, margin: &quot;1rem 0&quot; &#125;&#125; to=&#123;`/invoices/$&#123;invoice.number&#125;`&#125; key=&#123;invoice.number&#125; &gt; &#123;invoice.name&#125; &lt;/Link&gt; ))&#125; &lt;/nav&gt; &lt;/div&gt; );&#125;","categories":[{"name":"2022","slug":"2022","permalink":"http://example.com/categories/2022/"}],"tags":[{"name":"reat","slug":"reat","permalink":"http://example.com/tags/reat/"}]},{"title":"匿名函数","slug":"匿名函数","date":"2023-02-23T14:17:31.647Z","updated":"2023-02-23T13:50:36.485Z","comments":true,"path":"2023/02/23/匿名函数/","link":"","permalink":"http://example.com/2023/02/23/%E5%8C%BF%E5%90%8D%E5%87%BD%E6%95%B0/","excerpt":"匿名函数","text":"匿名函数 123456789101112131415161718// 1.表达式赋值给变量来使用var fa =function()&#123; console.log(20);&#125;fa();// 2.当作函数来被调用setTimeout(function()&#123;console.log(30);&#125;,1000);// 3.通过函数嵌套当成闭包里的返回函数来调用function fb()&#123; return function()&#123;console.log(40);&#125;&#125;var fm=fb();fm();// 4.函数自己调用自己，也就是自调用。!function()&#123;console.log(50);&#125;();//匿名函数智能被调用或是自调用。//带参数的匿名函数自调用!function(a,b)&#123;console.log(a+b);&#125;(40,50);","categories":[{"name":"2022","slug":"2022","permalink":"http://example.com/categories/2022/"}],"tags":[{"name":"js","slug":"js","permalink":"http://example.com/tags/js/"}]},{"title":"回调函数","slug":"回调函数","date":"2023-02-23T14:17:31.647Z","updated":"2023-02-23T13:50:29.285Z","comments":true,"path":"2023/02/23/回调函数/","link":"","permalink":"http://example.com/2023/02/23/%E5%9B%9E%E8%B0%83%E5%87%BD%E6%95%B0/","excerpt":"回调函数","text":"回调函数 12345678910111213141516171819// 先定义一个函数，用来做短时间或无法脱身的事情，同步function sdo(does)&#123; console.log(does);&#125;// 在定义以恶搞函数，用来做长时间等待的事情，异步//用回调解决这个问题function ldo(doing,callback)&#123; setTimeout(()=&gt;&#123; console.log(doing); callback(&#x27;吃鸡&#x27;) &#125;,1000);&#125;// 接下来要开始迫害只因sdo(&#x27;买鸡&#x27;)sdo(&#x27;杀鸡&#x27;)ldo(&#x27;炖鸡&#x27;,sdo)//===&gt;函数作为参数// sdo(&#x27;吃鸡&#x27;)// 会发现不对劲","categories":[{"name":"2022","slug":"2022","permalink":"http://example.com/categories/2022/"}],"tags":[{"name":"js","slug":"js","permalink":"http://example.com/tags/js/"}]},{"title":"解决bash hexo command not found","slug":"解决bash hexo command not found","date":"2023-02-23T14:17:31.647Z","updated":"2023-03-01T07:08:49.612Z","comments":true,"path":"2023/02/23/解决bash hexo command not found/","link":"","permalink":"http://example.com/2023/02/23/%E8%A7%A3%E5%86%B3bash%20hexo%20command%20not%20found/","excerpt":"解决bash: hexo: command not found","text":"解决bash: hexo: command not found 检查 nodejs 和 npm 是否正常，依次输入命令 node -v 和 npm -v 看看是否有相关版本信息 出现了版本信息就证明 nodejs 和 npm 是没有问题的，那么就应该是环境变量的配置问题了，在【此电脑】右键【属性】，依次选择【高级系统设置】-【环境变量】，选择系统变量 Path，将 node_modules 下的 .bin 文件路径添加到 Path 里面 注意你的博客目录下应该有两个 node_modules 文件夹 F:\\blog 和F:\\blog\\BLOG 我是加了第一个module在环境变量 别的博主有的加了第二个module 总之自己试一下按哪个 环境变量添加好了之后重新打开 git 即可运行 hexo 命令，如果此时仍然无法执行 hexo 命令，那就只能拿出终极绝招了，运行命令 npm install hexo-cli -g 重新安装 hexo 即可！","categories":[{"name":"2023","slug":"2023","permalink":"http://example.com/categories/2023/"}],"tags":[{"name":"hexo","slug":"hexo","permalink":"http://example.com/tags/hexo/"}]},{"title":"箭头函数","slug":"箭头函数","date":"2023-02-23T14:17:31.647Z","updated":"2023-02-23T13:50:33.998Z","comments":true,"path":"2023/02/23/箭头函数/","link":"","permalink":"http://example.com/2023/02/23/%E7%AE%AD%E5%A4%B4%E5%87%BD%E6%95%B0/","excerpt":"箭头函数","text":"箭头函数 12345678910111213141516// 1.箭头函数常见写法let fun1=(a,b)=&gt;&#123;return a+b;&#125;// 2.箭头函数没有参数，那么也要写括号let fun2=()=&gt;&#123;console.log(&#x27;你好&#x27;);&#125;// 3.如果只有一个参数，那么括号可以省略let fun3=name=&gt;&#123;console.log(`你好$&#123;name&#125;`);&#125;// 4.如果函数体只有一句执行代码，那么可以省略大括号，同时代码默认会被ruturn出去let fun4=name=&gt;`你好$&#123;name&#125;`;console.log(fun4(&#x27;小明&#x27;));// 5.箭头函数没有自己的this，他的this是来自于上层作用域的this let obj=&#123; fun5()&#123;console.log(&#x27;fun5:&#x27;,this);&#125;, fun6:()=&gt;&#123;console.log(&#x27;fun6:&#x27;,this);&#125; &#125; obj.fun5(); obj.fun6();","categories":[{"name":"2022","slug":"2022","permalink":"http://example.com/categories/2022/"}],"tags":[{"name":"js","slug":"js","permalink":"http://example.com/tags/js/"}]},{"title":"PyQt5显示图片","slug":"PyQt5显示图片","date":"2023-02-23T14:17:31.640Z","updated":"2023-02-23T14:03:39.746Z","comments":true,"path":"2023/02/23/PyQt5显示图片/","link":"","permalink":"http://example.com/2023/02/23/PyQt5%E6%98%BE%E7%A4%BA%E5%9B%BE%E7%89%87/","excerpt":"PyQt5显示图片","text":"PyQt5显示图片 123redImg=QImage()QImage.load(redImg,&#x27;path&#x27;,format=&#x27;png&#x27;)self.label_3.setPixmap(QtGui.QPixmap(redImg)) 123img_path=&#x27;path&#x27;self.showImage = QPixmap(img_path).scaled(self.label_3.width(), self.label_3.height()) # 适应窗口大小self.label_3.setPixmap(self.showImage) # 显示图片 1234567image=cv2.imread(&#x27;path&#x27;)def showImageRed(self): self.image_1 = self.image self.image_1 = QtGui.QImage(self.image_1.data, self.image_1.shape[1],self.image_1.shape[0],QtGui.QImage.Format_RGB888).rgbSwapped() self.label_3.setPixmap(QtGui.QPixmap.fromImage(self.image_1)) 第三种方法可能会有斜影子，修改成下方这样 1234def showImageRed(self): self.image_1 = self.image self.image_1 = QtGui.QImage(self.image_1.data, self.image_1.shape[1], self.image_1.shape[0],self.image_1.shape[1]*3, QtGui.QImage.Format_RGB888).rgbSwapped() self.label_3.setPixmap(QtGui.QPixmap.fromImage(self.image_1)) 感觉应该是三通道问题","categories":[{"name":"2022","slug":"2022","permalink":"http://example.com/categories/2022/"}],"tags":[{"name":"PyQt5","slug":"PyQt5","permalink":"http://example.com/tags/PyQt5/"}]},{"title":"Hello World","slug":"hello-world","date":"2023-02-23T14:17:31.624Z","updated":"2023-02-06T13:37:47.659Z","comments":true,"path":"2023/02/23/hello-world/","link":"","permalink":"http://example.com/2023/02/23/hello-world/","excerpt":"hello","text":"hello Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new &quot;My New Post&quot; More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","categories":[],"tags":[]},{"title":"maven 找不到依赖项 javax.servlet:servlet-api:${servlet-api.version}","slug":"maven","date":"2023-02-23T14:17:31.624Z","updated":"2023-02-23T14:10:17.356Z","comments":true,"path":"2023/02/23/maven/","link":"","permalink":"http://example.com/2023/02/23/maven/","excerpt":"找不到依赖项 javax.servlet:servlet-api:${servlet-api.version}1.下载maven百度","text":"找不到依赖项 javax.servlet:servlet-api:${servlet-api.version}1.下载maven百度 2.maven仓库查找 https://mvnrepository.com/ 直接搜索 比如 直接搜索 然后 点击之后往下移动 找到这一行 贴到pom.xml文件里 坐标组成 配置本地仓库 中央仓库 id唯一标识符，用来区分不同的mirror元素 mirrorOf代替哪个仓库 url镜像的URL","categories":[{"name":"2023","slug":"2023","permalink":"http://example.com/categories/2023/"}],"tags":[{"name":"maven","slug":"maven","permalink":"http://example.com/tags/maven/"}]},{"title":"PyQt5","slug":"pyqt5","date":"2023-02-23T14:17:31.624Z","updated":"2023-02-23T14:03:21.742Z","comments":true,"path":"2023/02/23/pyqt5/","link":"","permalink":"http://example.com/2023/02/23/pyqt5/","excerpt":"安装PyQt5打开Anaconda Promt，切换到对应环境输入：","text":"安装PyQt5打开Anaconda Promt，切换到对应环境输入： 1pip install PyQt5 -i https://pypi.douban.com/simple 安装PyQt5-tools 12pip install PyQt5-tools -i https://pypi.douban.com/simple 打开 Anaconda prompt 输入: 1PyQt5-tools designer 它有很多东西 1234designerinstalluicqmlsceneqmltestrunner 不知道其他是啥（待解决） 直接点击创建（main window） 随便拖两个button上去 另存为 然后回到anaconda那个窗口， 我们要把这个.ui文件转化为py文件 方法一： 1python -m PyQt5.uic.pyuic test.ui -o test.py 要切换到相对应的文件夹路径下再运行 已经生成了 方法二： 太烦了，不写 F:\\anaconda\\EMPYTY\\pkgs\\pyqt-5.9.2-py39hd77b12b_6\\Library\\bin 大概在这个路径里面 很鸡肋，虽然写的前面的那玩意少了点，但是要吧ui移到当前文件夹里面，辣鸡 1pyuic5 test.ui -o test.py 方法三：直接使用扩展程序打开 pycharm扩展程序（vscode没找到在哪） 不太好搞（不想写，没看懂） 综上，用方法一 1.水平布局 回到vscode里面 123456789101112131415import sysimport shuipingfrom PyQt5.QtWidgets import QApplication,QMainWindow#创建QApplication类的实例app=QApplication(sys.argv)#创建一个窗口mainWindow=QMainWindow()#向主窗口添加控件ui=shuiping.Ui_MainWindow()ui.setupUi(mainWindow)# 显示窗口mainWindow.show()# 进入程序的主循环、并通过exit函数确保主循环安全结束sys.exit(app.exec_()) 表单布局 垂直布局 栅格布局 尺寸策略 伙伴关系 tab顺序 编辑信号和槽","categories":[{"name":"2022","slug":"2022","permalink":"http://example.com/categories/2022/"}],"tags":[{"name":"PyQt5","slug":"PyQt5","permalink":"http://example.com/tags/PyQt5/"}]},{"title":"mysql报错ERROR 1045 (28000) Access denied for user 'root'@'localhost' (using password:NO)","slug":"mysql启动","date":"2023-02-23T14:17:31.624Z","updated":"2023-02-23T14:12:54.315Z","comments":true,"path":"2023/02/23/mysql启动/","link":"","permalink":"http://example.com/2023/02/23/mysql%E5%90%AF%E5%8A%A8/","excerpt":"ERROR 1045 (28000): Access denied for user ‘root‘@’localhost’ (using password: NO)","text":"ERROR 1045 (28000): Access denied for user ‘root‘@’localhost’ (using password: NO) E:\\jeecg\\jeecg-boot-master\\db\\jeecgboot-mysql-5.7.sql","categories":[{"name":"2023","slug":"2023","permalink":"http://example.com/categories/2023/"}],"tags":[{"name":"mysql","slug":"mysql","permalink":"http://example.com/tags/mysql/"}]},{"title":"npm install 包，没有报错，提示安装成功，但是项目中没有出现node_modules也没有安装的包","slug":"npm npm install hexo-cli -g","date":"2023-02-23T14:17:31.624Z","updated":"2023-03-01T07:07:25.030Z","comments":true,"path":"2023/02/23/npm npm install hexo-cli -g/","link":"","permalink":"http://example.com/2023/02/23/npm%20npm%20install%20hexo-cli%20-g/","excerpt":"npm install 包，没有报错，提示安装成功，但是项目中没有出现node_modules也没有安装的包1npm install hexo-cli -g","text":"npm install 包，没有报错，提示安装成功，但是项目中没有出现node_modules也没有安装的包1npm install hexo-cli -g 在当前文件夹目录下npm安装 hexo-cli -g 在当前文件夹不显示 因为这是全局安装 所以会跑到node.js文件夹目录底下 去这边找会发现一个hexo-cli的文件夹 点击这个博客[https://blog.csdn.net/qq_38613992/article/details/103769192] 查看npm的配置 1npm config list 一开始我是没有global&#x3D;？？？ 的 2.查看全局下，是否有自己安装的包 123npm root -g//获取到全局安装目录 一般看上面那个F盘的图，会在那里 3.修改npm配置信息，查看 图例1，global属性是否安装到全局，如果你的这里是true，那么，就算你安装一个包时，没有写-g，它也会自动将你的包安装到全局！ — 修改配置信息 方法一：命令行输入 123npm config set global=false，npm config set global=false 再次查看配置，确认是否修改 1npm config list 然后再 1npm install hexo-cli 后面不要-g就会在自己的文件夹里出现node_moudle了 你可以试试有-g的&#96;&#96;&#96;npm install hexo-cli&#96;&#96;，这样的话，就又会跑到node.js的global的moudle的文件夹里了 安装完成，如图","categories":[{"name":"2023","slug":"2023","permalink":"http://example.com/categories/2023/"}],"tags":[{"name":"hexo","slug":"hexo","permalink":"http://example.com/tags/hexo/"}]},{"title":"C++文件操作之freopen","slug":"C++文件操作之freopen","date":"2023-02-23T14:17:31.609Z","updated":"2023-02-23T13:51:59.659Z","comments":true,"path":"2023/02/23/C++文件操作之freopen/","link":"","permalink":"http://example.com/2023/02/23/C++%E6%96%87%E4%BB%B6%E6%93%8D%E4%BD%9C%E4%B9%8Bfreopen/","excerpt":"C++文件操作之freopen","text":"C++文件操作之freopen 12freopen(&quot;xxx.in&quot;,&quot;r&quot;,stdin); //输入文件freopen(&quot;xxx.out&quot;,&quot;w&quot;,stdout); //输出文件 1234567891011121314#include&lt;cstdio&gt;#include&lt;iostream&gt;using namespace std;int main()&#123; freopen(&quot;a+b.in&quot;,&quot;r&quot;,stdin); freopen(&quot;a+b.out&quot;,&quot;w&quot;,stdout); //以上是模板 int a,b; cin&gt;&gt;a&gt;&gt;b; cout&lt;&lt;a+b&lt;&lt;endl; return 0;&#125;","categories":[{"name":"2023","slug":"2023","permalink":"http://example.com/categories/2023/"}],"tags":[{"name":"c++","slug":"c","permalink":"http://example.com/tags/c/"}]},{"title":"Failed to scan","slug":"Failed to scan [fileFmavenrepositoryorgspringframeworkspring-aspects5","date":"2023-02-23T14:17:31.609Z","updated":"2023-02-23T13:53:39.577Z","comments":true,"path":"2023/02/23/Failed to scan [fileFmavenrepositoryorgspringframeworkspring-aspects5/","link":"","permalink":"http://example.com/2023/02/23/Failed%20to%20scan%20[fileFmavenrepositoryorgspringframeworkspring-aspects5/","excerpt":"Failed to scan [file:&#x2F;F:&#x2F;maven&#x2F;repository&#x2F;org&#x2F;springframework&#x2F;spring-aspects&#x2F;5.1.9.RELEASE&#x2F;spring-aspects-5.1.9.RELEASE.jar] from classloader hierarchyjava.util.zip.ZipException: error in opening zip file","text":"Failed to scan [file:&#x2F;F:&#x2F;maven&#x2F;repository&#x2F;org&#x2F;springframework&#x2F;spring-aspects&#x2F;5.1.9.RELEASE&#x2F;spring-aspects-5.1.9.RELEASE.jar] from classloader hierarchyjava.util.zip.ZipException: error in opening zip file 1mvn install:install-file -DgroupId=com.qiyuesuo.sdk -DartifactId=sdk-java -Dversion=3.4.1 -Dpackaging=jar -Dfile=D:\\jar\\sdk-java-3.4.1.jar 1F:\\maven\\repository\\org\\springframework\\spring-aspects\\5.1.9.RELEASE org.springframework.spring-aspects 12mvn install:install-file -DgroupId=org.springframework.spring-aspects-DartifactId=spring-aspects -Dversion=5.3.1 -Dpackaging=jar -Dfile=F:\\maven\\spring-aspects-5.3.1.jar mvn install:install-file -DgroupId&#x3D;org.springframework.spring-aspects-DartifactId&#x3D;spring-aspects -Dversion&#x3D;5.3.1 -Dpackaging&#x3D;jar -Dfile&#x3D;F:\\maven\\spring-aspects-5.3.1.jar","categories":[{"name":"2023","slug":"2023","permalink":"http://example.com/categories/2023/"}],"tags":[{"name":"maven","slug":"maven","permalink":"http://example.com/tags/maven/"}]},{"title":"之前的博客慢慢再修复，先把最近的东西放上来，sos！","slug":"breautiful","date":"2023-02-23T14:17:31.609Z","updated":"2023-02-23T13:41:12.493Z","comments":true,"path":"2023/02/23/breautiful/","link":"","permalink":"http://example.com/2023/02/23/breautiful/","excerpt":"","text":"之前的博客慢慢再修复，先把最近的东西放上来，sos！","categories":[{"name":"2023","slug":"2023","permalink":"http://example.com/categories/2023/"}],"tags":[{"name":"casual_talk","slug":"casual-talk","permalink":"http://example.com/tags/casual-talk/"}]}],"categories":[{"name":"2023","slug":"2023","permalink":"http://example.com/categories/2023/"},{"name":"2022","slug":"2022","permalink":"http://example.com/categories/2022/"}],"tags":[{"name":"设计模式","slug":"设计模式","permalink":"http://example.com/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"},{"name":"vmware","slug":"vmware","permalink":"http://example.com/tags/vmware/"},{"name":"Spark","slug":"Spark","permalink":"http://example.com/tags/Spark/"},{"name":"casual_talk","slug":"casual-talk","permalink":"http://example.com/tags/casual-talk/"},{"name":"mysql","slug":"mysql","permalink":"http://example.com/tags/mysql/"},{"name":"django","slug":"django","permalink":"http://example.com/tags/django/"},{"name":"powershell","slug":"powershell","permalink":"http://example.com/tags/powershell/"},{"name":"anaconda","slug":"anaconda","permalink":"http://example.com/tags/anaconda/"},{"name":"js","slug":"js","permalink":"http://example.com/tags/js/"},{"name":"reat","slug":"reat","permalink":"http://example.com/tags/reat/"},{"name":"hexo","slug":"hexo","permalink":"http://example.com/tags/hexo/"},{"name":"PyQt5","slug":"PyQt5","permalink":"http://example.com/tags/PyQt5/"},{"name":"maven","slug":"maven","permalink":"http://example.com/tags/maven/"},{"name":"c++","slug":"c","permalink":"http://example.com/tags/c/"}]}