{"meta":{"title":"睡觉万岁","subtitle":"","description":"在梦里啥都有","author":"毛","url":"http://example.com","root":"/"},"pages":[{"title":"about","date":"2022-12-31T14:33:19.000Z","updated":"2023-03-15T10:30:14.364Z","comments":true,"path":"about/index.html","permalink":"http://example.com/about/index.html","excerpt":"","text":"欠的债迟早都要还的！~！~！~！~！ 不要急躁，静心高效做好每一件事情"},{"title":"资源","date":"2022-12-31T14:33:21.000Z","updated":"2022-12-31T14:37:12.176Z","comments":false,"path":"resources/index.html","permalink":"http://example.com/resources/index.html","excerpt":"","text":""},{"title":"标签","date":"2022-12-31T14:33:16.000Z","updated":"2022-12-31T14:36:40.295Z","comments":false,"path":"tags/index.html","permalink":"http://example.com/tags/index.html","excerpt":"","text":""},{"title":"分类","date":"2022-12-31T14:33:04.000Z","updated":"2022-12-31T14:36:05.876Z","comments":false,"path":"categories/index.html","permalink":"http://example.com/categories/index.html","excerpt":"","text":""}],"posts":[{"title":"383. 赎金信","slug":"383.-赎金信","date":"2023-05-08T13:40:21.178Z","updated":"2023-05-08T14:02:43.830Z","comments":true,"path":"2023/05/08/383.-赎金信/","link":"","permalink":"http://example.com/2023/05/08/383.-%E8%B5%8E%E9%87%91%E4%BF%A1/","excerpt":"","text":"383. 赎金信 暴力 123456789101112131415bool canConstruct(string ransomNote,string magazine)&#123; for(int i =0;i&lt;magazine.length();i++)&#123; for(int j = 0;j&lt;ransomNote.length();j++)&#123; //在ransomNote中找到和magazine相同的字符 if(magazine[i]==ransomNote[j])&#123; ransomNote.erase(ransomNote.begin()+j); break; &#125; &#125; &#125; if(ransomNote.length()==0)&#123; return true; &#125; return false;&#125; 哈希 12345678910111213141516bool canConstruct(string ransomNote,string magazine)&#123; int record[26]=&#123;0&#125;; if(ransomNote.size()&gt;magazine.size())&#123; return false; &#125; for(int i=0;i&lt;magazine.length();i++)&#123; record[magazine[i]-&#x27;a&#x27;]++; &#125; for(int j =0;j&lt;ransomNote.length();j++)&#123; record[ransomNote[j]-&#x27;a&#x27;]--; if(record[ransomNote[j]-&#x27;a&#x27;]&lt;0)&#123; return flae; &#125; &#125; return true;&#125;","categories":[{"name":"代码随想录","slug":"代码随想录","permalink":"http://example.com/categories/%E4%BB%A3%E7%A0%81%E9%9A%8F%E6%83%B3%E5%BD%95/"}],"tags":[{"name":"哈希表","slug":"哈希表","permalink":"http://example.com/tags/%E5%93%88%E5%B8%8C%E8%A1%A8/"}]},{"title":"for(int a :nums1)是什么","slug":"for(int-a-nums1)是什么","date":"2023-05-08T13:26:10.830Z","updated":"2023-05-08T13:46:57.860Z","comments":true,"path":"2023/05/08/for(int-a-nums1)是什么/","link":"","permalink":"http://example.com/2023/05/08/for(int-a-nums1)%E6%98%AF%E4%BB%80%E4%B9%88/","excerpt":"","text":"for(int a :nums1) 是 C++11 中引入的一种新的循环语法，称为范围 for 循环（range-based for loop），用于方便地遍历容器中的元素。 在这个语法中，nums1 是一个容器，a 是一个变量，表示容器中的每个元素。循环语句会依次遍历容器中的每个元素，并将当前元素赋值给变量 a，然后执行循环体中的语句，直到遍历完所有元素。 以下是一个使用范围 for 循环遍历 vector 容器中的元素的例子： 12345678910111213#include &lt;iostream&gt;#include &lt;vector&gt;using namespace std;int main()&#123; vector&lt;int&gt; nums = &#123;1, 2, 3, 4, 5&#125;; for (int num : nums) &#123; cout &lt;&lt; num &lt;&lt; &quot; &quot;; &#125; cout &lt;&lt; endl; return 0;&#125; 在这个例子中，我们定义了一个包含整数的 vector 容器 nums，然后使用范围 for 循环遍历 nums 容器中的每个元素，并将当前元素赋值给 num 变量，然后输出 num 的值。在执行循环语句后，输出结果为：1 2 3 4 5。 需要注意的是，范围 for 循环可以用于遍历各种类型的容器，包括数组、vector、list、deque、set、map 等容器类型。在实际编程中，我们可以使用范围 for 循环来方便地遍历容器中的元素，以提高代码的可读性和可维护性。","categories":[{"name":"代码随想录","slug":"代码随想录","permalink":"http://example.com/categories/%E4%BB%A3%E7%A0%81%E9%9A%8F%E6%83%B3%E5%BD%95/"}],"tags":[{"name":"vector容器","slug":"vector容器","permalink":"http://example.com/tags/vector%E5%AE%B9%E5%99%A8/"}]},{"title":"454. 四数相加 II","slug":"454.-四数相加-II","date":"2023-05-08T13:05:13.178Z","updated":"2023-05-08T13:05:13.179Z","comments":true,"path":"2023/05/08/454.-四数相加-II/","link":"","permalink":"http://example.com/2023/05/08/454.-%E5%9B%9B%E6%95%B0%E7%9B%B8%E5%8A%A0-II/","excerpt":"","text":"454. 四数相加 II 12345int fourCount(vector&lt;int&gt;&amp; A,vectot&lt;int&gt;&amp; B,vector&lt;int&gt;&amp; C,vector&lt;int&gt;&amp; D)&#123; unordered_map&lt;int,int&gt; umap;//key:a+b的数值,value:a+b数值出现的次数 //遍历大A和大B数组,统计两个数组元素之和,和出现的次数,放到map中 &#125;","categories":[{"name":"代码随想录","slug":"代码随想录","permalink":"http://example.com/categories/%E4%BB%A3%E7%A0%81%E9%9A%8F%E6%83%B3%E5%BD%95/"}],"tags":[{"name":"哈希表","slug":"哈希表","permalink":"http://example.com/tags/%E5%93%88%E5%B8%8C%E8%A1%A8/"}]},{"title":"有关using","slug":"有关using","date":"2023-05-07T14:18:02.748Z","updated":"2023-05-07T14:18:02.748Z","comments":true,"path":"2023/05/07/有关using/","link":"","permalink":"http://example.com/2023/05/07/%E6%9C%89%E5%85%B3using/","excerpt":"","text":"有关usingusing 是 C++ 中的一个关键字，它有多种用途，主要包括以下几个方面： 别名声明：使用 using 关键字可以给一个类型、变量、函数、模板等起一个别名。例如： 12using IntVec = std::vector&lt;int&gt;; // using 别名声明IntVec vec = &#123;1, 2, 3&#125;; // 使用别名 IntVec 来声明 vector&lt;int&gt; 类型的变量 上面的代码中，我们使用 using 关键字给 std::vector&lt;int&gt; 类型起了一个别名 IntVec，然后使用别名 IntVec 来声明一个 vector&lt;int&gt; 类型的变量 vec，从而简化了代码。 命名空间别名：使用 using namespace 可以给一个命名空间起一个别名。例如： 1namespace my_ns = my_namespace::sub_namespace; // 命名空间别名 上面的代码中，我们使用 using namespace 关键字给 my_namespace::sub_namespace 命名空间起了一个别名 my_ns，从而在后续的代码中可以使用 my_ns 来代替 my_namespace::sub_namespace。 模板别名：使用 using 关键字可以给一个模板类型起一个别名。例如： 123template &lt;typename T&gt;using MyVec = std::vector&lt;T&gt;; // 模板别名声明MyVec&lt;int&gt; vec = &#123;1, 2, 3&#125;; // 使用模板别名 MyVec 来声明 vector&lt;int&gt; 类型的变量 上面的代码中，我们使用 using 关键字给 std::vector&lt;T&gt; 类型起了一个模板别名 MyVec&lt;T&gt;，然后使用模板别名 MyVec&lt;int&gt; 来声明一个 vector&lt;int&gt; 类型的变量 vec，从而简化了代码。 需要注意的是，using 关键字的使用虽然可以简化代码，但过度使用可能会降低代码的可读性和可维护性。在使用 using 关键字时，应该尽量保持别名的清晰和语义明确，以便于代码的理解和维护。","categories":[{"name":"代码随想录","slug":"代码随想录","permalink":"http://example.com/categories/%E4%BB%A3%E7%A0%81%E9%9A%8F%E6%83%B3%E5%BD%95/"}],"tags":[{"name":"哈希表","slug":"哈希表","permalink":"http://example.com/tags/%E5%93%88%E5%B8%8C%E8%A1%A8/"}]},{"title":"有关于auto","slug":"有关于auto","date":"2023-05-07T13:58:11.236Z","updated":"2023-05-07T13:58:11.236Z","comments":true,"path":"2023/05/07/有关于auto/","link":"","permalink":"http://example.com/2023/05/07/%E6%9C%89%E5%85%B3%E4%BA%8Eauto/","excerpt":"","text":"有关于autoauto 是 C++11 中引入的关键字，用于让编译器自动推导变量的类型。通过 auto 关键字，我们可以让编译器根据变量的初始值或表达式推导出变量的类型，从而省略变量类型的显式声明。 具体来说，auto 关键字可以用于以下几种情况： 自动推导变量类型：在变量声明时使用 auto 关键字，让编译器自动推导变量的类型。例如： 1234auto x = 1; // 推导出 x 的类型为 intauto y = 3.14; // 推导出 y 的类型为 doubleauto z = &quot;hello&quot;; // 推导出 z 的类型为 const char*​``` 函数返回值类型自动推导：在函数定义时使用 auto 关键字，让编译器自动推导函数的返回值类型。例如： 12345auto add(int x, int y) -&gt; int // 推导出函数返回值类型为 int&#123; return x + y;&#125; 注意，这种用法需要在函数定义时使用尾置返回类型（trailing return type）语法。 迭代器类型自动推导：在使用迭代器时使用 auto 关键字，让编译器自动推导迭代器的类型。例如： 1234for (auto it = vec.begin(); it != vec.end(); ++it)&#123; // do something with *it&#125; 在这个例子中，auto 关键字让编译器自动推导出 it 的类型为 std::vector&lt;int&gt;::iterator。 需要注意的是，虽然 auto 关键字可以让代码更加简洁，但过度使用可能会降低代码的可读性和可维护性。在使用 auto 关键字时，应该尽量保持变量名的清晰和语义明确，以便于代码的理解和维护。 123456std::vector&lt;int&gt; vec = &#123;1, 2, 3&#125;;for (auto it = vec.begin(); it != vec.end(); ++it)&#123; // do something with *it&#125;在这个例子中，`auto` 关键字让编译器自动推导出 `it` 的类型为 `std::vector&lt;int&gt;::iterator`。 12345std::vector&lt;int&gt; vec = &#123;1, 2, 3&#125;;for (std::vector&lt;int&gt;::iterator it = vec.begin(); it != vec.end(); ++it)&#123; // do something with *it&#125;","categories":[{"name":"代码随想录","slug":"代码随想录","permalink":"http://example.com/categories/%E4%BB%A3%E7%A0%81%E9%9A%8F%E6%83%B3%E5%BD%95/"}],"tags":[{"name":"哈希表","slug":"哈希表","permalink":"http://example.com/tags/%E5%93%88%E5%B8%8C%E8%A1%A8/"}]},{"title":"1.两数之和","slug":"1.两数之和","date":"2023-05-06T14:25:13.631Z","updated":"2023-05-07T14:58:34.579Z","comments":true,"path":"2023/05/06/1.两数之和/","link":"","permalink":"http://example.com/2023/05/06/1.%E4%B8%A4%E6%95%B0%E4%B9%8B%E5%92%8C/","excerpt":"","text":"1. 两数之和 12345678910std:unordered_map&lt;int,int&gt; map;//key 存数字 value存indexfor(int i = 0 ;i &lt; nums.size(); i++)&#123; auto iter= map.find(target-nums[i]); if(iter!=map.end())&#123; return&#123;iter-&gt;second,i&#125;; &#125; map.insert(pair&lt;int,int&gt;(nums[i],i));&#125; return &#123;&#125;; 123456789unordered_map&lt;int,int&gt; map;for(int i = 0 ; i &lt;nums.size();i++)&#123; unordered_map&lt;int,int&gt;::iterator iter=map.find(target-nums[i]); if(iter!=map.end())&#123; return &#123;iter-&gt;second,i&#125;; &#125; map.insert(pair&lt;int,int&gt;(nums[i],i));&#125;return &#123;&#125;; Q: 在这边 map.insert(pair&lt;int,int&gt;(nums[i],i)); 可以换成 map.insert(unordered_map&lt;int,int&gt;(nums[i],i));吗 A: 不可以，因为 std::unordered_map 是一个关联容器，其中的元素是键值对（key-value pair），而 unordered_map&lt;int,int&gt;(nums[i], i) 是一个无序键值对，不能直接用来插入到 std::unordered_map 容器中。 在这个例子中，我们需要将每个元素的值 nums[i] 和下标 i 插入到 map 中，以便在后续查找过程中能够快速找到匹配的元素。因此，我们需要使用 std::pair&lt;int, int&gt; 类型来表示每个元素的键值对，然后将其插入到 map 中。 在代码中，map.insert(pair&lt;int, int&gt;(nums[i], i)); 表示将一个由 nums[i] 和 i 组成的键值对插入到 map 中。这里使用了 std::pair&lt;int, int&gt; 类型来表示键值对，从而可以将其作为 map 的元素插入到容器中。 需要注意的是，C++ 中提供了很多种容器类型，每种容器类型都有其特定的用途和特性。在使用容器时，需要根据具体情况选择合适的容器类型，并了解容器类型的特性和使用方法，以提高代码的效率和可读性。","categories":[{"name":"代码随想录","slug":"代码随想录","permalink":"http://example.com/categories/%E4%BB%A3%E7%A0%81%E9%9A%8F%E6%83%B3%E5%BD%95/"}],"tags":[{"name":"哈希表","slug":"哈希表","permalink":"http://example.com/tags/%E5%93%88%E5%B8%8C%E8%A1%A8/"}]},{"title":"202. 快乐数","slug":"202.-快乐数","date":"2023-05-05T14:23:31.628Z","updated":"2023-05-05T14:27:20.990Z","comments":true,"path":"2023/05/05/202.-快乐数/","link":"","permalink":"http://example.com/2023/05/05/202.-%E5%BF%AB%E4%B9%90%E6%95%B0/","excerpt":"","text":"202. 快乐数 12345678910111213141516171819202122232425int getSum(int n)&#123; int sum=0; while(n)&#123; sum+=(n%10)*(n%10); n/=10; &#125; return sum;&#125;bool isHappy(int n)&#123; unordered_set&lt;int&gt; set; while(1)&#123; int sum=getSum(n); if(sum==1)&#123; return true; &#125; // 如果这个sum曾经出现过，说明已经陷入了无限循环了，立刻return false if(set.find(sum)!=set.end())&#123; return false; &#125; else&#123; set.insert(sum); &#125; n=sum; &#125;&#125;","categories":[{"name":"代码随想录","slug":"代码随想录","permalink":"http://example.com/categories/%E4%BB%A3%E7%A0%81%E9%9A%8F%E6%83%B3%E5%BD%95/"}],"tags":[{"name":"哈希表","slug":"哈希表","permalink":"http://example.com/tags/%E5%93%88%E5%B8%8C%E8%A1%A8/"}]},{"title":"349.两个数组的交集","slug":"349.两个数组的交集","date":"2023-04-29T13:31:36.116Z","updated":"2023-05-05T13:50:25.051Z","comments":true,"path":"2023/04/29/349.两个数组的交集/","link":"","permalink":"http://example.com/2023/04/29/349.%E4%B8%A4%E4%B8%AA%E6%95%B0%E7%BB%84%E7%9A%84%E4%BA%A4%E9%9B%86/","excerpt":"","text":"349. 两个数组的交集 set 123456789101112vector&lt;int&gt; intersection(vector&lt;int&gt;&amp; nums1,vector&lt;int&gt;&amp; nums2)&#123; unordered_set&lt;int&gt; result_set;//存放结果，给结果去重 unordered_set&lt;int&gt; nums_set(nums1.begin(),nums1.end()); for(int num: nums2)&#123; //发现nums2的元素，在nums_set里又出现过 //nums_set.end() 表示 std::unordered_set 中最后一个元素的下一个位置的迭代器 if(nums_set.find(num)!=nums_set.end())&#123; result_set.insert(num); &#125; &#125; return vector&lt;int&gt;(result_set.begin(),result.end());&#125; 数组 12345678910111213vector&lt;int&gt; intersection(vector&lt;int&gt;&amp; nums1,vector&lt;int&gt;&amp; nums2)&#123; unordered_set&lt;int&gt; result_set; //save result int hash[1005]=&#123;0&#125;;//默认0 for(int num:nums1)&#123;//出现过的字母在hash数组中做记录 hash[num]=1; &#125; for(int num:num2)&#123;//nums2中出现的话，result记录 if(hash[num]==1)&#123; result_set.inset(num); &#125; &#125; return vector&lt;int&gt;(result_set.begin(),result_sey.end());&#125;","categories":[{"name":"代码随想录","slug":"代码随想录","permalink":"http://example.com/categories/%E4%BB%A3%E7%A0%81%E9%9A%8F%E6%83%B3%E5%BD%95/"}],"tags":[{"name":"哈希表","slug":"哈希表","permalink":"http://example.com/tags/%E5%93%88%E5%B8%8C%E8%A1%A8/"}]},{"title":"哈希表基础","slug":"哈希表基础","date":"2023-04-25T14:26:45.851Z","updated":"2023-04-25T14:26:45.852Z","comments":true,"path":"2023/04/25/哈希表基础/","link":"","permalink":"http://example.com/2023/04/25/%E5%93%88%E5%B8%8C%E8%A1%A8%E5%9F%BA%E7%A1%80/","excerpt":"","text":"首先什么是 哈希表，哈希表（英文名字为Hash table，国内也有一些算法书籍翻译为散列表，大家看到这两个名称知道都是指hash table就可以了）。 哈希表是根据关键码的值而直接进行访问的数据结构。 这么这官方的解释可能有点懵，其实直白来讲其实数组就是一张哈希表。 哈希表中关键码就是数组的索引下标，然后通过下标直接访问数组中的元素，如下图所示： 那么哈希表能解决什么问题呢，一般哈希表都是用来快速判断一个元素是否出现集合里。 例如要查询一个名字是否在这所学校里。 要枚举的话时间复杂度是O(n)，但如果使用哈希表的话， 只需要O(1)就可以做到。 我们只需要初始化把这所学校里学生的名字都存在哈希表里，在查询的时候通过索引直接就可以知道这位同学在不在这所学校里了。 将学生姓名映射到哈希表上就涉及到了hash function ，也就是哈希函数。 #哈希函数哈希函数，把学生的姓名直接映射为哈希表上的索引，然后就可以通过查询索引下标快速知道这位同学是否在这所学校里了。 哈希函数如下图所示，通过hashCode把名字转化为数值，一般hashcode是通过特定编码方式，可以将其他数据格式转化为不同的数值，这样就把学生名字映射为哈希表上的索引数字了。 如果hashCode得到的数值大于 哈希表的大小了，也就是大于tableSize了，怎么办呢？ 此时为了保证映射出来的索引数值都落在哈希表上，我们会在再次对数值做一个取模的操作，就要我们就保证了学生姓名一定可以映射到哈希表上了。 此时问题又来了，哈希表我们刚刚说过，就是一个数组。 如果学生的数量大于哈希表的大小怎么办，此时就算哈希函数计算的再均匀，也避免不了会有几位学生的名字同时映射到哈希表 同一个索引下标的位置。 接下来哈希碰撞登场 #哈希碰撞如图所示，小李和小王都映射到了索引下标 1 的位置，这一现象叫做哈希碰撞。 一般哈希碰撞有两种解决方法， 拉链法和线性探测法。 #拉链法刚刚小李和小王在索引1的位置发生了冲突，发生冲突的元素都被存储在链表中。 这样我们就可以通过索引找到小李和小王了 （数据规模是dataSize， 哈希表的大小为tableSize） 其实拉链法就是要选择适当的哈希表的大小，这样既不会因为数组空值而浪费大量内存，也不会因为链表太长而在查找上浪费太多时间。 #线性探测法使用线性探测法，一定要保证tableSize大于dataSize。 我们需要依靠哈希表中的空位来解决碰撞问题。 例如冲突的位置，放了小李，那么就向下找一个空位放置小王的信息。所以要求tableSize一定要大于dataSize ，要不然哈希表上就没有空置的位置来存放 冲突的数据了。如图所示： 其实关于哈希碰撞还有非常多的细节，感兴趣的同学可以再好好研究一下，这里我就不再赘述了。 #常见的三种哈希结构当我们想使用哈希法来解决问题的时候，我们一般会选择如下三种数据结构。 数组 set （集合） map(映射) 这里数组就没啥可说的了，我们来看一下set。 在C++中，set 和 map 分别提供以下三种数据结构，其底层实现以及优劣如下表所示： 集合 底层实现 是否有序 数值是否可以重复 能否更改数值 查询效率 增删效率 std::set 红黑树 有序 否 否 O(log n) O(log n) std::multiset 红黑树 有序 是 否 O(logn) O(logn) std::unordered_set 哈希表 无序 否 否 O(1) O(1) std::unordered_set底层实现为哈希表，std::set 和std::multiset 的底层实现是红黑树，红黑树是一种平衡二叉搜索树，所以key值是有序的，但key不可以修改，改动key值会导致整棵树的错乱，所以只能删除和增加。 映射 底层实现 是否有序 数值是否可以重复 能否更改数值 查询效率 增删效率 std::map 红黑树 key有序 key不可重复 key不可修改 O(logn) O(logn) std::multimap 红黑树 key有序 key可重复 key不可修改 O(log n) O(log n) std::unordered_map 哈希表 key无序 key不可重复 key不可修改 O(1) O(1) std::unordered_map 底层实现为哈希表，std::map 和std::multimap 的底层实现是红黑树。同理，std::map 和std::multimap 的key也是有序的（这个问题也经常作为面试题，考察对语言容器底层的理解）。 当我们要使用集合来解决哈希问题的时候，优先使用unordered_set，因为它的查询和增删效率是最优的，如果需要集合是有序的，那么就用set，如果要求不仅有序还要有重复数据的话，那么就用multiset。 那么再来看一下map ，在map 是一个key value 的数据结构，map中，对key是有限制，对value没有限制的，因为key的存储方式使用红黑树实现的。 其他语言例如：java里的HashMap ，TreeMap 都是一样的原理。可以灵活贯通。 虽然std::set、std::multiset 的底层实现是红黑树，不是哈希表，std::set、std::multiset 使用红黑树来索引和存储，不过给我们的使用方式，还是哈希法的使用方式，即key和value。所以使用这些数据结构来解决映射问题的方法，我们依然称之为哈希法。 map也是一样的道理。 这里在说一下，一些C++的经典书籍上 例如STL源码剖析，说到了hash_set hash_map，这个与unordered_set，unordered_map又有什么关系呢？ 实际上功能都是一样一样的， 但是unordered_set在C++11的时候被引入标准库了，而hash_set并没有，所以建议还是使用unordered_set比较好，这就好比一个是官方认证的，hash_set，hash_map 是C++11标准之前民间高手自发造的轮子。 #总结总结一下，当我们遇到了要快速判断一个元素是否出现集合里的时候，就要考虑哈希法。 但是哈希法也是牺牲了空间换取了时间，因为我们要使用额外的数组，set或者是map来存放数据，才能实现快速的查找。 如果在做面试题目的时候遇到需要判断一个元素是否出现过的场景也应该第一时间想到哈希法！","categories":[{"name":"代码随想录","slug":"代码随想录","permalink":"http://example.com/categories/%E4%BB%A3%E7%A0%81%E9%9A%8F%E6%83%B3%E5%BD%95/"}],"tags":[{"name":"哈希表","slug":"哈希表","permalink":"http://example.com/tags/%E5%93%88%E5%B8%8C%E8%A1%A8/"}]},{"title":"242. 有效的字母异位词","slug":"242.-有效的字母异位词","date":"2023-04-25T13:47:03.789Z","updated":"2023-04-25T14:33:46.022Z","comments":true,"path":"2023/04/25/242.-有效的字母异位词/","link":"","permalink":"http://example.com/2023/04/25/242.-%E6%9C%89%E6%95%88%E7%9A%84%E5%AD%97%E6%AF%8D%E5%BC%82%E4%BD%8D%E8%AF%8D/","excerpt":"","text":"242. 有效的字母异位词 12345678910111213141516bool isAnagram(string s,string t)&#123; int record[26]=&#123;0&#125;; for(int i = 0 ;i&lt;s.size();i++)&#123; // 并不需要记住字符a的ASCII，只要c求出一个相对数值就可以了 record[s[i]-&#x27;a&#x27;]++; &#125; for(int i =0 ;i &lt;t.size();i++)&#123; record[t[i]-&#x27;a&#x27;]--; &#125; for(int i = 0 ;i &lt;26;i++)&#123; if(record[i]!=0)&#123; return flase; &#125; &#125; return true;&#125; 1234567891011121314151617class Solution &#123;public: bool isAnagram(string s, string t) &#123; int record[26]=&#123;0&#125;; for(int i=0;i&lt;s.size();i++)&#123; record[s[i]-&#x27;a&#x27;]++; &#125; for(int i = 0 ; i&lt;t.size();i++)&#123; record[t[i]-&#x27;a&#x27;]--; &#125; for(int i = 0 ; i &lt;26;i++)&#123; if(record[i]!=0) return false; &#125; return true; &#125;&#125;; 丢人现眼的暴力(原来之前的这种思维题算是哈希法0.0) 123456789101112131415161718192021222324252627282930313233#include&lt;iostream&gt;using namespace std;int main()&#123; string a,b; cin&gt;&gt;a; cin&gt;&gt;b; int A[60000]; int B[60000]; for(int i = 0 ; i &lt; a.size();i++)&#123; A[a[i]]=A[a[i]]+1; &#125; for(int i = 0 ; i &lt; b.size();i++)&#123; if(A[b[i]]==A[a[i]])&#123; A[a[i]]--; &#125; &#125; int flag=0; for(int i = 0 ; i &lt;a.size();i++)&#123; if(A[a[i]]!=0)&#123; flag=1; &#125; &#125; if (flag==0)&#123; cout&lt;&lt;&quot;niubi&quot;; &#125; else&#123; cout&lt;&lt;&quot;goushi&quot;; &#125; return 0;&#125;","categories":[{"name":"代码随想录","slug":"代码随想录","permalink":"http://example.com/categories/%E4%BB%A3%E7%A0%81%E9%9A%8F%E6%83%B3%E5%BD%95/"}],"tags":[{"name":"哈希表","slug":"哈希表","permalink":"http://example.com/tags/%E5%93%88%E5%B8%8C%E8%A1%A8/"}]},{"title":"142. 环形链表 II","slug":"142.-环形链表-II","date":"2023-04-24T13:50:36.441Z","updated":"2023-04-24T13:53:07.576Z","comments":true,"path":"2023/04/24/142.-环形链表-II/","link":"","permalink":"http://example.com/2023/04/24/142.-%E7%8E%AF%E5%BD%A2%E9%93%BE%E8%A1%A8-II/","excerpt":"","text":"142. 环形链表 II 12345678910111213141516ListNode* fast =head;ListNode* slow=head;while(fast!=NULL&amp;&amp;fast-&gt;next!=NULL)&#123; slow=slow-&gt;next; fast=fast-&gt;next-&gt;next; if(slow==fast)&#123; ListNode* index1=fast; ListNode* index2=head; while(index1!=index2)&#123; index1=index1-&gt;next; index2=index2-&gt;next; &#125; return inedx2; &#125; return NULL;&#125; 123456789101112131415161718192021222324252627282930/** * Definition for singly-linked list. * struct ListNode &#123; * int val; * ListNode *next; * ListNode(int x) : val(x), next(NULL) &#123;&#125; * &#125;; */class Solution &#123;public: ListNode *detectCycle(ListNode *head) &#123; ListNode *fast=head; ListNode *slow=head; while(fast!=NULL&amp;&amp;fast-&gt;next!=NULL)&#123; fast=fast-&gt;next-&gt;next;//走两部 slow=slow-&gt;next;//走一步 if(fast==slow)&#123; //当快==慢时候(为什么不直返回slow呢？因为fast 不只走了一圈) ListNode* index1=fast; //所以直接找它的地址再的地方 ListNode* index2=head; //从头数fast在哪 while(index1!=index2)&#123; index1=index1-&gt;next; index2=index2-&gt;next; &#125; return index2; &#125; &#125; return NULL; &#125;&#125;;","categories":[{"name":"代码随想录","slug":"代码随想录","permalink":"http://example.com/categories/%E4%BB%A3%E7%A0%81%E9%9A%8F%E6%83%B3%E5%BD%95/"}],"tags":[{"name":"链表","slug":"链表","permalink":"http://example.com/tags/%E9%93%BE%E8%A1%A8/"}]},{"title":"02.07. 链表相交","slug":"02.07.-链表相交","date":"2023-04-22T14:13:00.355Z","updated":"2023-04-22T14:34:00.814Z","comments":true,"path":"2023/04/22/02.07.-链表相交/","link":"","permalink":"http://example.com/2023/04/22/02.07.-%E9%93%BE%E8%A1%A8%E7%9B%B8%E4%BA%A4/","excerpt":"","text":"02.07. 链表相交 123456789101112131415161718192021222324252627282930313233ListNode* curA=headA;ListNode* curB=headB;int lenA=0,lenB=0;while(curA!=NULL)&#123; lenA++;//A长度 curA=curA-&gt;next;&#125;while(curB!=NULL)&#123; lenB++;//B长度 curB=curB-&gt;next;&#125;curA=headA;curB=headB;//curA become max ,lenA is its lengthif(lenB&gt;lenA)&#123; swap(lenA,lenB); swap(curA,curB);&#125;//求长度差int gap= lenA-lenB;while(gap--)&#123; curA=curA-&gt;next;&#125;//遍历curA和curB 遇到相同则直接返回while(curA!=NULL)&#123; if(curA==curB)&#123; return curA; &#125; curA=curA-&gt;next; curB=curB-&gt;next;&#125;return NULL; 12345678910111213141516171819202122232425262728293031323334353637383940414243444546/** * Definition for singly-linked list. * struct ListNode &#123; * int val; * ListNode *next; * ListNode(int x) : val(x), next(NULL) &#123;&#125; * &#125;; */class Solution &#123;public: ListNode *getIntersectionNode(ListNode *headA, ListNode *headB) &#123; ListNode* curA=headA; ListNode* curB=headB; int lenA=0,lenB=0; while(curA!=NULL)&#123; lenA++; curA=curA-&gt;next; &#125; while(curB!=NULL)&#123; lenB++; curB=curB-&gt;next; &#125; //为什么还要再次赋值，因为上面next到了NULL，懂否，傻子 curA = headA; curB = headB; if(lenB&gt;lenA)&#123; swap(lenA,lenB); swap(curA,curB); &#125; int gap=lenA-lenB; //移动 while(gap)&#123; curA=curA-&gt;next; gap--; &#125; while(curA!=NULL)&#123; if(curA==curB)&#123; return curA; &#125; curA=curA-&gt;next; curB=curB-&gt;next; &#125; return NULL; &#125;&#125;;","categories":[{"name":"代码随想录","slug":"代码随想录","permalink":"http://example.com/categories/%E4%BB%A3%E7%A0%81%E9%9A%8F%E6%83%B3%E5%BD%95/"}],"tags":[{"name":"链表","slug":"链表","permalink":"http://example.com/tags/%E9%93%BE%E8%A1%A8/"}]},{"title":"19.删除链表的倒数第 N 个结点","slug":"19.删除链表的倒数第-N-个结点","date":"2023-04-21T15:14:48.418Z","updated":"2023-04-22T13:39:30.060Z","comments":true,"path":"2023/04/21/19.删除链表的倒数第-N-个结点/","link":"","permalink":"http://example.com/2023/04/21/19.%E5%88%A0%E9%99%A4%E9%93%BE%E8%A1%A8%E7%9A%84%E5%80%92%E6%95%B0%E7%AC%AC-N-%E4%B8%AA%E7%BB%93%E7%82%B9/","excerpt":"","text":"19. 删除链表的倒数第 N 个结点 所以快慢指针只是减少了遍历一遍链表长度实质上就是用fast来代替长度罢了……………… 还不如自己写一遍傻的暴力 12345678910111213141516171819202122232425262728293031/** * Definition for singly-linked list. * struct ListNode &#123; * int val; * ListNode *next; * ListNode() : val(0), next(nullptr) &#123;&#125; * ListNode(int x) : val(x), next(nullptr) &#123;&#125; * ListNode(int x, ListNode *next) : val(x), next(next) &#123;&#125; * &#125;; */class Solution &#123;public: ListNode* removeNthFromEnd(ListNode* head, int n) &#123; ListNode* dummyHead=new ListNode(0); dummyHead-&gt;next=head; ListNode* fast=dummyHead; ListNode* slow=dummyHead; while(n&amp;&amp;fast-&gt;next!=NULL)&#123; fast=fast-&gt;next; n--; &#125; fast=fast-&gt;next; while(fast!=NULL)&#123; fast=fast-&gt;next; slow=slow-&gt;next; &#125; slow-&gt;next=slow-&gt;next-&gt;next; return dummyHead-&gt;next; &#125;&#125;; 暴力 1234567891011121314151617181920212223242526272829/** * Definition for singly-linked list. * struct ListNode &#123; * int val; * ListNode *next; * ListNode() : val(0), next(nullptr) &#123;&#125; * ListNode(int x) : val(x), next(nullptr) &#123;&#125; * ListNode(int x, ListNode *next) : val(x), next(next) &#123;&#125; * &#125;; */class Solution &#123;public: ListNode* removeNthFromEnd(ListNode* head, int n) &#123; ListNode* dummyHead=new ListNode(0); dummyHead-&gt;next=head; int length=0; while(head!=NULL)&#123; length++; head=head-&gt;next; &#125; ListNode* cur=dummyHead; for(int i = 1 ;i&lt;=length-n;i++)&#123; cur=cur-&gt;next; &#125; cur-&gt;next=cur-&gt;next-&gt;next; return dummyHead-&gt;next; &#125;&#125;;","categories":[{"name":"代码随想录","slug":"代码随想录","permalink":"http://example.com/categories/%E4%BB%A3%E7%A0%81%E9%9A%8F%E6%83%B3%E5%BD%95/"}],"tags":[{"name":"链表","slug":"链表","permalink":"http://example.com/tags/%E9%93%BE%E8%A1%A8/"}]},{"title":"24. 两两交换链表中的节点","slug":"24.-两两交换链表中的节点","date":"2023-04-21T14:09:44.429Z","updated":"2023-04-21T14:09:44.430Z","comments":true,"path":"2023/04/21/24.-两两交换链表中的节点/","link":"","permalink":"http://example.com/2023/04/21/24.-%E4%B8%A4%E4%B8%A4%E4%BA%A4%E6%8D%A2%E9%93%BE%E8%A1%A8%E4%B8%AD%E7%9A%84%E8%8A%82%E7%82%B9/","excerpt":"","text":"24. 两两交换链表中的节点 12345678910111213141516171819202122232425262728/** * Definition for singly-linked list. * struct ListNode &#123; * int val; * ListNode *next; * ListNode() : val(0), next(nullptr) &#123;&#125; * ListNode(int x) : val(x), next(nullptr) &#123;&#125; * ListNode(int x, ListNode *next) : val(x), next(next) &#123;&#125; * &#125;; */class Solution &#123;public: ListNode* swapPairs(ListNode* head) &#123; ListNode *dummyHead=new ListNode(0); dummyHead-&gt;next=head; ListNode *cur=dummyHead; while(cur-&gt;next!=NULL&amp;&amp;cur-&gt;next-&gt;next!=NULL)&#123; ListNode* temp=cur-&gt;next; ListNode* temp1=cur-&gt;next-&gt;next-&gt;next; cur-&gt;next=cur-&gt;next-&gt;next; cur-&gt;next-&gt;next=temp; cur-&gt;next-&gt;next-&gt;next=temp1; //顺着思路比较好毕竟已经改变了cur-&gt;next的值，直接顺下比较清楚 cur=cur-&gt;next-&gt;next; &#125; return dummyHead-&gt;next; &#125;&#125;;","categories":[{"name":"代码随想录","slug":"代码随想录","permalink":"http://example.com/categories/%E4%BB%A3%E7%A0%81%E9%9A%8F%E6%83%B3%E5%BD%95/"}],"tags":[{"name":"链表","slug":"链表","permalink":"http://example.com/tags/%E9%93%BE%E8%A1%A8/"}]},{"title":"206. 反转链表","slug":"206.-反转链表","date":"2023-04-20T15:01:48.789Z","updated":"2023-04-20T15:21:00.026Z","comments":true,"path":"2023/04/20/206.-反转链表/","link":"","permalink":"http://example.com/2023/04/20/206.-%E5%8F%8D%E8%BD%AC%E9%93%BE%E8%A1%A8/","excerpt":"","text":"206. 反转链表 示例: 输入: 1-&gt;2-&gt;3-&gt;4-&gt;5-&gt;NULL 输出: 5-&gt;4-&gt;3-&gt;2-&gt;1-&gt;NULL 123456789101112ListNode* reverseList(ListNode* head)&#123; ListNode* temp; //保存cur的下一个结点 ListNode* cur=head; ListNode* pre =NULL; while(cur)&#123; tmp=cur-&gt;next; //保存cur的下一个结点，因为接下来要改变cur-&gt;next cur-&gt;next=pre; //反转 pre=cur; //更新pre cur=temp; //再更新cur &#125; return pre;&#125; 12345678910111213141516171819202122232425/** * Definition for singly-linked list. * struct ListNode &#123; * int val; * ListNode *next; * ListNode() : val(0), next(nullptr) &#123;&#125; * ListNode(int x) : val(x), next(nullptr) &#123;&#125; * ListNode(int x, ListNode *next) : val(x), next(next) &#123;&#125; * &#125;; */class Solution &#123;public: ListNode* reverseList(ListNode* head) &#123; ListNode* pre=NULL; ListNode* cur=head; ListNode* tmp; while(cur)&#123; tmp=cur-&gt;next; cur-&gt;next=pre; pre=cur; cur=tmp; &#125; return pre; &#125;&#125;; 递归 12345678910111213141516171819class Solution &#123;public: ListNode* reverse(ListNode* pre,ListNode* cur)&#123; if(cur == NULL) return pre; ListNode* temp = cur-&gt;next; cur-&gt;next = pre; // 可以和双指针法的代码进行对比，如下递归的写法，其实就是做了这两步 // pre = cur; // cur = temp; return reverse(cur,temp); &#125; ListNode* reverseList(ListNode* head) &#123; // 和双指针法初始化是一样的逻辑 // ListNode* cur = head; // ListNode* pre = NULL; return reverse(NULL, head); &#125;&#125;;","categories":[{"name":"代码随想录","slug":"代码随想录","permalink":"http://example.com/categories/%E4%BB%A3%E7%A0%81%E9%9A%8F%E6%83%B3%E5%BD%95/"}],"tags":[{"name":"链表","slug":"链表","permalink":"http://example.com/tags/%E9%93%BE%E8%A1%A8/"}]},{"title":"4-20-2023","slug":"4-20-2023","date":"2023-04-20T13:12:09.312Z","updated":"2023-04-20T13:36:41.837Z","comments":true,"path":"2023/04/20/4-20-2023/","link":"","permalink":"http://example.com/2023/04/20/4-20-2023/","excerpt":"","text":"1.半夜背东西的效果 2.一边看田静长难句每日一句，忘记的语法看了英语兔，觉得看懂中高阶难度的文章单词重要语法也重要 3.写的越来越慢了，进展到链表（TAT） 4.数学干掉了第三章和知识框架，进展到张宇30讲第三讲函数极限， 正在做7种未定式归纳。 感觉怪怪的： 首先把所以定义理了一遍（超级费时间）， 然后把张宇和武忠祥的题归纳在了活页本上，感觉做题方法啥的有点乱，一道题不一定用了一个知识点，不过第三遍看张宇的，思路清晰很多。 这周希望能写1800那上面的题吧（有思路的写） 5.半夜报复性的玩代号鸢，单词都咩有背完（投降）（认错）（再也不敢了） 比起看英语文章，背单词的还是比看文章的轻松太多的。 知道了那个考南邮的是哪个师兄了！！！ acm铜的江苏师兄，专业课110 数学98 政治50英语60多 总分320无缘南邮直接上班去了（掰了掰手指头算了算我考的学校，好像我得数学上百，zz70英语80才可以哦（怎么感觉在梦里可以做到呢）（考不上就进流水线（摆）））","categories":[{"name":"2023","slug":"2023","permalink":"http://example.com/categories/2023/"}],"tags":[{"name":"casual_talk","slug":"casual-talk","permalink":"http://example.com/tags/casual-talk/"}]},{"title":"707.设计链表","slug":"707.设计链表","date":"2023-04-18T15:01:25.264Z","updated":"2023-04-18T15:05:11.775Z","comments":true,"path":"2023/04/18/707.设计链表/","link":"","permalink":"http://example.com/2023/04/18/707.%E8%AE%BE%E8%AE%A1%E9%93%BE%E8%A1%A8/","excerpt":"","text":"707. 设计链表 123456789101112131415161718192021222324252627282930313233343536373839struct LinkNode&#123; int val; LinkedNode* next; LinkedNode(int val):val(val),next(NULL)&#123;&#125;&#125;;//初始化链表MyLinkedList()&#123; dummyHead=new LinkedNode(0);//虚拟头结点 size=0;&#125;//获取第index个结点数值，index是从0开始的，第0个结点就是头结点int get(int index)&#123; if(index&gt;(size-1)||index&lt;0)&#123; //如果index是非法数值返回-1， return -1; &#125; LinkedNode* cur=dummyHead-&gt;next; while(index)&#123; //当index的值不为0的时候 cur=cur-&gt;next; //continue 到下一个，因为加了个dummy虚拟头节点所以第一个cur-&gt;next就是头结点 index--; &#125; return cur-&gt;val;&#125;void addAtHead(int val)&#123; LinkedNode* newNode=new LinkedNode(val);//创建个的结点 newNode-&gt;next=dummyHead-&gt;next;//让新节点的地址指向当初的头节点 dummyHead-&gt;next=newNode; //然后再让虚拟头结点的地址指向新的结点 size++;&#125;//在链表最后面添加一个结点void addAtTail(int val)&#123; LinkedNode* newNode =new LinkedNode(val);//创建一个结点 LinkedNode* cur=dummyHead;//设置一个cur来操作dummy while(cur-&gt;next!=NULL)&#123;//当当前结点不为空的时候 ，继续往下找 cur=cur-&gt;next; &#125; cur-&gt;next=newNode; //把最后一个结点的地址变成newnode size++;&#125; 123456789101112131415//在index之前的地方插入新结点void addIndex(int index,int val)&#123; if(index&gt;size) return ;// ilegal if(index&lt;0) index=0; LinkedNode* newNode=new LinkedNode(val); //set new node LinkedNode* cur=dummyHead;// set cur while(index)&#123; //index!=NULL cur=cur-&gt;next; //point to next address index--; &#125; newNode-&gt;next=cur-&gt;next; //把 newNode的 地址 变成cur地址（后面的值放入） cur-&gt;next=newNode;//再把newNode放到cur的地址上（前面的值改变） size++; &#125; 123456789101112131415161718192021222324//删除第index个结点void deleteAtIndex(int index)&#123; if(index&gt;=size||index&lt;0)&#123; return; &#125; LinkedNode* cur = dummyHead; while(index)&#123; cur=cur-&gt;next; index--; &#125; LinkedNode* tmp =cur-&gt;next; cur-&gt;next=cur-&gt;next-&gt;next; delete tmp; size--;&#125;//打印链表void printLinkedList()&#123; LinkedNode* cur =dummyHead; while(cur-&gt;next!=NULL)&#123; cout&lt;&lt;cur-&gt;next-&gt;val&lt;&lt;&quot; &quot;; cur=cur-&gt;next; &#125; cout&lt;&lt;endl;&#125;","categories":[{"name":"代码随想录","slug":"代码随想录","permalink":"http://example.com/categories/%E4%BB%A3%E7%A0%81%E9%9A%8F%E6%83%B3%E5%BD%95/"}],"tags":[{"name":"链表","slug":"链表","permalink":"http://example.com/tags/%E9%93%BE%E8%A1%A8/"}]},{"title":"203.移除链表元素","slug":"203.移除链表元素","date":"2023-04-17T13:43:19.021Z","updated":"2023-04-18T14:09:27.819Z","comments":true,"path":"2023/04/17/203.移除链表元素/","link":"","permalink":"http://example.com/2023/04/17/203.%E7%A7%BB%E9%99%A4%E9%93%BE%E8%A1%A8%E5%85%83%E7%B4%A0/","excerpt":"","text":"203. 移除链表元素 直接使用原来的链表来进行移除节点操作： 12345678910111213141516171819ListNode* removeElements(ListNode* head,int val)&#123; //删除头结点 while(head!=NULL&amp;&amp;head-&gt;val==val)&#123; ListNode* tmp=head; head=head-&gt;next;//直接让head等于下一个next delete tmp; &#125; //删除非头结点 ListNode* cur =head; //设置一个cur的东西来操作链表 while(cur!=NULL&amp;&amp;cur-&gt;next!=NULL)&#123; //当前不为空，且下一个结点也不为空 if(cur-&gt;next-&gt;val==val)&#123; // 如果当前的下一个结点为val 当前的next地址为下一个结点 ListNode* tep=cur-&gt;next; cur-&gt;next=cur-&gt;next-&gt;next; //val的next变成 val的下一个下一个的next &#125;else&#123; cur=cur-&gt;next; &#125; &#125; return head;&#125; 12345678910111213141516171819202122232425262728293031323334/** * Definition for singly-linked list. * struct ListNode &#123; * int val; * ListNode *next; * ListNode() : val(0), next(nullptr) &#123;&#125; * ListNode(int x) : val(x), next(nullptr) &#123;&#125; * ListNode(int x, ListNode *next) : val(x), next(next) &#123;&#125; * &#125;; */class Solution &#123;public: ListNode* removeElements(ListNode* head, int val) &#123; //删除头结点 while(head!=NULL&amp;&amp;head-&gt;val==val)&#123; ListNode* tmp=head; head=head-&gt;next; delete tmp; &#125; //删除非头结点 ListNode *cur=head; while(cur!=NULL&amp;&amp;cur-&gt;next!=NULL)&#123; //当前不为空，且下一个也不为空 if(cur-&gt;next-&gt;val==val)&#123; ListNode *tmp=cur-&gt;next; cur-&gt;next=cur-&gt;next-&gt;next; delete tmp; &#125; else&#123; cur=cur-&gt;next; &#125; &#125; return head; &#125;&#125;; 设置一个虚拟头结点在进行移除节点操作： 12345678910111213141516171819ListNode* removeElements(ListNode* head,int val)&#123; ListNode* dummyHead=new ListNode(0); //创建一个虚拟节点 dummyHead-&gt;next=head; //这个结点的地址指向head ListNode* cur=dummyHead;//用来操作的作为 当前的为虚拟结点 while(cur-&gt;next!=NULL)&#123; if(cur-&gt;next-&gt;val==val)&#123;// 当前的下一个结点值 等于 val ListNode* tmp=cur-&gt;next;// cur-&gt;next=cur-&gt;next-&gt;next; //下一个等于下一个结点 delete tmp; &#125; else&#123; cur=cur-&gt;next; //cur移向下一个结点 &#125; head=dummyHead-&gt;next; //head为虚拟结点的下一个结点 delete dummyHead;// return head; &#125;&#125; 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869#include &lt;iostream&gt;using namespace std;//单链表struct ListNode&#123; int val; //节点上存储的元素 ListNode *next; //指向下一个结点的指针 ListNode(int x): val(x) ,next(NULL)&#123;&#125;&#125;; //创建链表//ListNode* createList()&#123;// ListNode* head=NULL;// ListNode* tail=NULL;// int val;// while(cin&gt;&gt;val)&#123;// ListNode* node=new ListNode(val);// if(tail==NULL)&#123;// head=node;// tail==node;// &#125;// else&#123;// tail-&gt;next=node;// tail=node;// &#125;// &#125;//&#125; ListNode* removeElements(ListNode* head,int val)&#123; ListNode *dymmy=new ListNode(0); dymmy-&gt;next=head; ListNode *cur=dymmy; while(cur-&gt;next!=NULL)&#123; if(cur-&gt;next-&gt;val==val)&#123; ListNode *tmp=cur-&gt;next; cur-&gt;next=cur-&gt;next-&gt;next; delete tmp; &#125; else&#123; cur=cur-&gt;next; &#125; &#125;// head=dymmy-&gt;next return head=dymmy-&gt;next; &#125;//打印链表void printList(ListNode* head)&#123; while(head)//head is not empty &#123; cout&lt;&lt;head-&gt;val&lt;&lt;&quot; &quot;;//pirnt the value of the head head=head-&gt;next; //turn to the next address &#125; cout&lt;&lt;endl;&#125; int main()&#123; ListNode* head = new ListNode(1); head-&gt;next = new ListNode(2); head-&gt;next-&gt;next = new ListNode(6); head-&gt;next-&gt;next-&gt;next = new ListNode(3); head-&gt;next-&gt;next-&gt;next-&gt;next = new ListNode(4); head-&gt;next-&gt;next-&gt;next-&gt;next-&gt;next = new ListNode(5); head-&gt;next-&gt;next-&gt;next-&gt;next-&gt;next-&gt;next = new ListNode(6); int val = 6; ListNode* newHead= removeElements(head,val); printList(newHead); return 0; &#125;","categories":[{"name":"代码随想录","slug":"代码随想录","permalink":"http://example.com/categories/%E4%BB%A3%E7%A0%81%E9%9A%8F%E6%83%B3%E5%BD%95/"}],"tags":[{"name":"链表","slug":"链表","permalink":"http://example.com/tags/%E9%93%BE%E8%A1%A8/"}]},{"title":"链表基础","slug":"链表基础","date":"2023-04-17T12:30:06.859Z","updated":"2023-04-17T12:31:03.212Z","comments":true,"path":"2023/04/17/链表基础/","link":"","permalink":"http://example.com/2023/04/17/%E9%93%BE%E8%A1%A8%E5%9F%BA%E7%A1%80/","excerpt":"","text":"链表的定义链表的定义。 刷leetcode的链表的节点都默认定义好了，直接用就行了 没有注意到链表的节点是如何定义的。 C&#x2F;C++的定义链表节点方式，如下所示： 123456// 单链表struct ListNode &#123; int val; // 节点上存储的元素 ListNode *next; // 指向下一个节点的指针 ListNode(int x) : val(x), next(NULL) &#123;&#125; // 节点的构造函数&#125;; 我不定义构造函数行不行，答案是可以的，C++默认生成一个构造函数。 但是这个构造函数不会初始化任何成员变量，下面我来举两个例子： 通过自己定义构造函数初始化节点： 1ListNode* head = new ListNode(5); 使用默认构造函数初始化节点： 12ListNode* head = new ListNode();head-&gt;val = 5; 果不定义构造函数使用默认构造函数的话，在初始化的时候就不能直接给变量赋值！ 性能分析再把链表的特性和数组的特性进行一个对比，如图所示：","categories":[{"name":"代码随想录","slug":"代码随想录","permalink":"http://example.com/categories/%E4%BB%A3%E7%A0%81%E9%9A%8F%E6%83%B3%E5%BD%95/"}],"tags":[{"name":"链表","slug":"链表","permalink":"http://example.com/tags/%E9%93%BE%E8%A1%A8/"}]},{"title":"数组总结","slug":"数组总结","date":"2023-04-17T12:15:53.906Z","updated":"2023-04-17T12:15:53.906Z","comments":true,"path":"2023/04/17/数组总结/","link":"","permalink":"http://example.com/2023/04/17/%E6%95%B0%E7%BB%84%E6%80%BB%E7%BB%93/","excerpt":"","text":"数组总结","categories":[{"name":"代码随想录","slug":"代码随想录","permalink":"http://example.com/categories/%E4%BB%A3%E7%A0%81%E9%9A%8F%E6%83%B3%E5%BD%95/"}],"tags":[{"name":"数组总结","slug":"数组总结","permalink":"http://example.com/tags/%E6%95%B0%E7%BB%84%E6%80%BB%E7%BB%93/"}]},{"title":"59.螺旋矩阵II","slug":"59.螺旋矩阵II","date":"2023-04-17T11:41:23.637Z","updated":"2023-04-17T12:12:32.269Z","comments":true,"path":"2023/04/17/59.螺旋矩阵II/","link":"","permalink":"http://example.com/2023/04/17/59.%E8%9E%BA%E6%97%8B%E7%9F%A9%E9%98%B5II/","excerpt":"","text":"螺旋矩阵 II 123456789101112131415161718192021222324252627282930313233vector&lt;vector&lt;int&gt;&gt; res(n,vector&lt;int&gt;(n,0));//用vector定义一个二维数组int startx=0,starty=0;int loop=n/2;int mid=n/2;int count=1;int offset=1;//需要控制每一条边遍历的长度，每次循环右边界收缩一位int i,j;while(loop--)&#123; i=startx; j=starty; //第一行 for(j=starty;j&lt;n-offset;j++)&#123; res[startx][j]=count++; //行不动，j++ &#125; for(i=startx;i&lt;n-offset;i++)&#123; res[i][j]=count++; //保持上面的j的值，i++行++ &#125; for(;j&gt;starty;j--)&#123; res[i][j]=count++;//保持上面的值，j--左边 &#125; for(;i&gt;startx;i--)&#123; res[i][j]=count++;//保持上面的j的值,i--回到最上面 &#125; startx++; starty++; offset+=1;&#125;//为奇数 单独思考if(n%2)&#123; res[mid][mid]=count;&#125;return res; 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647class Solution &#123;public: vector&lt;vector&lt;int&gt;&gt; generateMatrix(int n) &#123; vector&lt;vector&lt;int&gt;&gt; res(n, vector&lt;int&gt;(n, 0)); // 使用vector定义一个二维数组 int startx = 0, starty = 0; // 定义每循环一个圈的起始位置 int loop = n / 2; // 每个圈循环几次，例如n为奇数3，那么loop = 1 只是循环一圈，矩阵中间的值需要单独处理 int mid = n / 2; // 矩阵中间的位置，例如：n为3， 中间的位置就是(1，1)，n为5，中间位置为(2, 2) int count = 1; // 用来给矩阵中每一个空格赋值 int offset = 1; // 需要控制每一条边遍历的长度，每次循环右边界收缩一位 int i,j; while (loop --) &#123; i = startx; j = starty; // 下面开始的四个for就是模拟转了一圈 // 模拟填充上行从左到右(左闭右开) for (j = starty; j &lt; n - offset; j++) &#123; res[startx][j] = count++; &#125; // 模拟填充右列从上到下(左闭右开) for (i = startx; i &lt; n - offset; i++) &#123; res[i][j] = count++; &#125; // 模拟填充下行从右到左(左闭右开) for (; j &gt; starty; j--) &#123; res[i][j] = count++; &#125; // 模拟填充左列从下到上(左闭右开) for (; i &gt; startx; i--) &#123; res[i][j] = count++; &#125; // 第二圈开始的时候，起始位置要各自加1， 例如：第一圈起始位置是(0, 0)，第二圈起始位置是(1, 1) startx++; starty++; // offset 控制每一圈里每一条边遍历的长度 offset += 1; &#125; // 如果n为奇数的话，需要单独给矩阵最中间的位置赋值 if (n % 2) &#123; res[mid][mid] = count; &#125; return res; &#125;&#125;; 1234567891011121314151617181920212223242526272829303132333435363738class Solution &#123;public: vector&lt;vector&lt;int&gt;&gt; generateMatrix(int n) &#123; vector&lt;vector&lt;int&gt;&gt; res(n,vector&lt;int&gt;(n,0)); //vector&lt;int&gt; a(10,1) 初始化 10个1 int loop=n/2; //转圈次数 int count=1; int mid=n/2; int startx=0,starty=0; int i,j; int offset=1; while(loop--)&#123; for(j=starty;j&lt;n-offset;j++)&#123; // res[startx][j]=count++; //拆解出来就是,这个不是自增 res[startx][j]=count; count++; &#125; for(i=startx;i&lt;n-offset;i++)&#123; res[i][j]=count++; &#125; for(;j&gt;starty;j--)&#123; res[i][j]=count++; &#125; for(;i&gt;startx;i--)&#123; res[i][j]=count++; &#125; startx++; starty++; offset++; &#125; if(n%2)&#123; res[mid][mid]=count; &#125; return res; &#125;&#125;;","categories":[{"name":"代码随想录","slug":"代码随想录","permalink":"http://example.com/categories/%E4%BB%A3%E7%A0%81%E9%9A%8F%E6%83%B3%E5%BD%95/"}],"tags":[{"name":"螺旋矩阵","slug":"螺旋矩阵","permalink":"http://example.com/tags/%E8%9E%BA%E6%97%8B%E7%9F%A9%E9%98%B5/"}]},{"title":"如何打开ipynb文件","slug":"如何打开ipynb文件","date":"2023-04-17T07:41:31.210Z","updated":"2023-04-17T07:41:31.210Z","comments":true,"path":"2023/04/17/如何打开ipynb文件/","link":"","permalink":"http://example.com/2023/04/17/%E5%A6%82%E4%BD%95%E6%89%93%E5%BC%80ipynb%E6%96%87%E4%BB%B6/","excerpt":"","text":"安装 Jupyter Notebook 或 JupyterLab：您可以使用 pip 命令来安装，如下所示： 1pip install jupyterlab 启动 Jupyter Notebook 或 JupyterLab：在命令行中输入 jupyter notebook 或 jupyter lab 命令，启动 Jupyter Notebook 或 JupyterLab。 打开 .ipynb 文件：在 Jupyter Notebook 或 JupyterLab 的主界面中，找到包含 .ipynb 文件的目录，点击文件名即可打开。 运行和编辑 .ipynb 文件：在打开的 .ipynb 文件中，您可以执行代码、编辑文本、添加图像等内容，并且可以在浏览器中进行交互式的运行和编辑。","categories":[{"name":"2023","slug":"2023","permalink":"http://example.com/categories/2023/"}],"tags":[{"name":"大数据可视化","slug":"大数据可视化","permalink":"http://example.com/tags/%E5%A4%A7%E6%95%B0%E6%8D%AE%E5%8F%AF%E8%A7%86%E5%8C%96/"}]},{"title":"滑动窗口904. 水果成篮","slug":"滑动窗口904.-水果成篮","date":"2023-04-16T14:50:33.795Z","updated":"2023-04-16T14:50:33.795Z","comments":true,"path":"2023/04/16/滑动窗口904.-水果成篮/","link":"","permalink":"http://example.com/2023/04/16/%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3904.-%E6%B0%B4%E6%9E%9C%E6%88%90%E7%AF%AE/","excerpt":"","text":"904. 水果成篮 1234567891011121314151617181920212223class Solution &#123;public: int totalFruit(vector&lt;int&gt;&amp; fruits) &#123; int left=0,right=0; int n=fruits.size(); int max_fruit=INT_MIN; unordered_map&lt;int,int&gt; basket; //这个什么map不懂 for(int i = 0 ; i&lt;n;i++)&#123; //大循环 从0-n-1 int fruit_num= fruits[i]; // 记录fruits[i]的数字，当比如fruits[0]=1,fruits[1]=1,那么，basket[1]=1+1=2 basket[fruit_num]++; while(basket.size()&gt;2)&#123;//当篮里种类大于2时 int fruit_num=fruits[left];//记录从fruits[0]=1即basket[1]=2 basket[fruit_num]--; //把前面的减掉 if(basket[fruit_num]==0)&#123; basket.erase(fruit_num); //当这种水果为0的时候，就删除这种水果 //删除key就行了 &#125; left++; //继续从当前的位置往右边移动 &#125; max_fruit=max_fruit&gt;i-left+1?max_fruit:i-left+1; &#125; return max_fruit; &#125;&#125;;","categories":[{"name":"代码随想录","slug":"代码随想录","permalink":"http://example.com/categories/%E4%BB%A3%E7%A0%81%E9%9A%8F%E6%83%B3%E5%BD%95/"}],"tags":[{"name":"滑动窗口","slug":"滑动窗口","permalink":"http://example.com/tags/%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3/"}]},{"title":"C++中map和unordered_map的用法","slug":"C++中map和unordered_map的用法","date":"2023-04-16T14:36:59.563Z","updated":"2023-04-16T14:36:59.564Z","comments":true,"path":"2023/04/16/C++中map和unordered_map的用法/","link":"","permalink":"http://example.com/2023/04/16/C++%E4%B8%ADmap%E5%92%8Cunordered_map%E7%9A%84%E7%94%A8%E6%B3%95/","excerpt":"","text":"1. 简介map和unordered_map都是c++中可以充当字典（key-value）来用的数据类型，但是其基本实现是不一样的。 2.map对于map的底层原理，是通过红黑树（一种非严格意义上的平衡二叉树）来实现的，因此map内部所有的数据都是有序的，map的查询、插入、删除操作的时间复杂度都是O(logn)。此外，map的key需要定义operator &lt;，对于一般的数据类型已被系统实现，若是用户自定义的数据类型，则要重新定义该操作符。 map的基本操作如下 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748#include&lt;iostream&gt;#include&lt;map&gt;#include&lt;string&gt;using namespace std;int main()&#123; // 构造函数 map&lt;string, int&gt; dict;// 插入数据的三种方式dict.insert(pair&lt;string,int&gt;(&quot;apple&quot;,2));dict.insert(map&lt;string, int&gt;::value_type(&quot;orange&quot;,3));dict[&quot;banana&quot;] = 6; // 判断是否有元素if(dict.empty()) cout&lt;&lt;&quot;该字典无元素&quot;&lt;&lt;endl;else cout&lt;&lt;&quot;该字典共有&quot;&lt;&lt;dict.size()&lt;&lt;&quot;个元素&quot;&lt;&lt;endl; // 遍历map&lt;string, int&gt;::iterator iter;for(iter=dict.begin();iter!=dict.end();iter++) cout&lt;&lt;iter-&gt;first&lt;&lt;ends&lt;&lt;iter-&gt;second&lt;&lt;endl; // 查找if((iter=dict.find(&quot;banana&quot;))!=dict.end()) // 返回一个迭代器指向键值为key的元素，如果没找到就返回end() cout&lt;&lt;&quot;已找到banana,其value为&quot;&lt;&lt;iter-&gt;second&lt;&lt;&quot;.&quot;&lt;&lt;endl;else cout&lt;&lt;&quot;未找到banana.&quot;&lt;&lt;endl; if(dict.count(&quot;watermelon&quot;)==0) // 返回键值等于key的元素的个数 cout&lt;&lt;&quot;watermelon不存在&quot;&lt;&lt;endl;else cout&lt;&lt;&quot;watermelon存在&quot;&lt;&lt;endl;pair&lt;map&lt;string, int&gt;::iterator, map&lt;string, int&gt;::iterator&gt; ret;ret = dict.equal_range(&quot;banana&quot;); // 查找键值等于 key 的元素区间为[start,end)，指示范围的两个迭代器以 pair 返回cout&lt;&lt;ret.first-&gt;first&lt;&lt;ends&lt;&lt;ret.first-&gt;second&lt;&lt;endl;cout&lt;&lt;ret.second-&gt;first&lt;&lt;ends&lt;&lt;ret.second-&gt;second&lt;&lt;endl; iter = dict.lower_bound(&quot;boluo&quot;); // 返回一个迭代器，指向键值&gt;=key的第一个元素。cout&lt;&lt;iter-&gt;first&lt;&lt;endl;iter = dict.upper_bound(&quot;boluo&quot;); // 返回一个迭代器，指向值键值&gt;key的第一个元素。cout&lt;&lt;iter-&gt;first&lt;&lt;endl;return 0;&#125; 注意如果定义了map&lt;string,int&gt;这个类型，需要在头文件中包含#include&lt;string&gt;，这是因为默认的string是系统的xstring对象，但是没有定义operator&lt;，从而报错。map用到自定义的类型，一定要定义operator&lt;，具体用法如下。 12345678910111213141516struct person &#123; string name; int age; person(string name, int age) &#123; this-&gt;name = name; this-&gt;age = age; &#125; bool operator &lt; (const person&amp; p) const &#123; return this-&gt;age &lt; p.age; &#125; &#125;; map&lt;person,int&gt; m; 3.unordered_mapunordered_map和map类似，都是存储的key-value的值，可以通过key快速索引到value。不同的是unordered_map不会根据key的大小进行排序，存储时是根据key的hash值判断元素是否相同，即unordered_map内部元素是无序的。unordered_map的底层是一个防冗余的哈希表（开链法避免地址冲突）。unordered_map的key需要定义hash_value函数并且重载operator &#x3D;&#x3D;。 哈希表最大的优点，就是把数据的存储和查找消耗的时间大大降低，时间复杂度为O(1)；而代价仅仅是消耗比较多的内存。哈希表的查询时间虽然是O(1)，但是并不是unordered_map查询时间一定比map短，因为实际情况中还要考虑到数据量，而且unordered_map的hash函数的构造速度也没那么快，所以不能一概而论，应该具体情况具体分析。 unordered_map的基本操作 12345678910111213141516171819202122232425262728293031323334353637#include&lt;string&gt; #include&lt;iostream&gt; #include&lt;unordered_map&gt;using namespace std; int main()&#123; unordered_map&lt;string, int&gt; dict; // 声明unordered_map对象// 插入数据的三种方式dict.insert(pair&lt;string,int&gt;(&quot;apple&quot;,2));dict.insert(unordered_map&lt;string, int&gt;::value_type(&quot;orange&quot;,3));dict[&quot;banana&quot;] = 6;// 判断是否有元素if(dict.empty()) cout&lt;&lt;&quot;该字典无元素&quot;&lt;&lt;endl;else cout&lt;&lt;&quot;该字典共有&quot;&lt;&lt;dict.size()&lt;&lt;&quot;个元素&quot;&lt;&lt;endl;// 遍历unordered_map&lt;string, int&gt;::iterator iter;for(iter=dict.begin();iter!=dict.end();iter++) cout&lt;&lt;iter-&gt;first&lt;&lt;ends&lt;&lt;iter-&gt;second&lt;&lt;endl;// 查找if(dict.count(&quot;boluo&quot;)==0) cout&lt;&lt;&quot;can&#x27;t find boluo!&quot;&lt;&lt;endl;else cout&lt;&lt;&quot;find boluo!&quot;&lt;&lt;endl;if((iter=dict.find(&quot;banana&quot;))!=dict.end()) cout&lt;&lt;&quot;banana=&quot;&lt;&lt;iter-&gt;second&lt;&lt;endl;else cout&lt;&lt;&quot;can&#x27;t find boluo!&quot;&lt;&lt;endl;return 0;&#125; unordered_map用到自定义的类型，需要对key定义hash_value函数并且重载operator &#x3D;&#x3D;，具体用法请参考文献3（有空再来补个示例）。 参考文献 C++11 新特性： unordered_map 与 map 的对比 2.C++ STL之map与unordered_map 3.std::unordered_map（提供自己的Hash函数和等价准则） 4.https://blog.csdn.net/jingyi130705008/article/details/82633778","categories":[{"name":"代码随想录","slug":"代码随想录","permalink":"http://example.com/categories/%E4%BB%A3%E7%A0%81%E9%9A%8F%E6%83%B3%E5%BD%95/"}],"tags":[{"name":"map和unordered_map","slug":"map和unordered-map","permalink":"http://example.com/tags/map%E5%92%8Cunordered-map/"}]},{"title":"关于最大值最小值的定义","slug":"关于最大值最小值的定义","date":"2023-04-15T14:09:17.701Z","updated":"2023-04-15T14:09:17.701Z","comments":true,"path":"2023/04/15/关于最大值最小值的定义/","link":"","permalink":"http://example.com/2023/04/15/%E5%85%B3%E4%BA%8E%E6%9C%80%E5%A4%A7%E5%80%BC%E6%9C%80%E5%B0%8F%E5%80%BC%E7%9A%84%E5%AE%9A%E4%B9%89/","excerpt":"","text":"最大值1int result = INT32_MAX; 最近在刷Leetcode的一些题的时候，发现经常会使用到最大值。Xcode告诉我这个值在limits.h中老版本的limit.h可能还会有NC++ 1#define INT_MAX 2147483647 但是现在新的版本已经是 1#define INT_MAX __INT_MAX__ 同样的 INT_MIN 、 LONG_MAX 等等数值都会有相应的定义。 最小值1int result = INT32_MIN 1INT32_MAX","categories":[{"name":"代码随想录","slug":"代码随想录","permalink":"http://example.com/categories/%E4%BB%A3%E7%A0%81%E9%9A%8F%E6%83%B3%E5%BD%95/"}],"tags":[{"name":"c++最大值","slug":"c-最大值","permalink":"http://example.com/tags/c-%E6%9C%80%E5%A4%A7%E5%80%BC/"}]},{"title":"209. 长度最小的子数组-滑动窗口","slug":"209.-长度最小的子数组-滑动窗口","date":"2023-04-14T15:11:46.427Z","updated":"2023-04-16T13:13:08.559Z","comments":true,"path":"2023/04/14/209.-长度最小的子数组-滑动窗口/","link":"","permalink":"http://example.com/2023/04/14/209.-%E9%95%BF%E5%BA%A6%E6%9C%80%E5%B0%8F%E7%9A%84%E5%AD%90%E6%95%B0%E7%BB%84-%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3/","excerpt":"","text":"209. 长度最小的子数组 暴力o(n^2)超时呵呵呵，不是能做出来就好了吗啊吧啊吧。 123456789101112131415161718192021class Solution &#123;public: int minSubArrayLen(int target, vector&lt;int&gt;&amp; nums) &#123; int sum; int min=100000; int count; for(int i=0;i&lt;nums.size();i++)&#123; sum=0; for(int j = i;j&lt;nums.size();j++)&#123; sum+=nums[j]; if(sum&gt;=target)&#123; count=j-i+1; min=min&lt;count?min:count; break; &#125; &#125; if(min&gt;nums.size()) min=0; &#125; return min; &#125;&#125;; 滑动窗口 思路是先让 sum+nums[j] 当sum&gt;=target的时候 算出子数组长度subL 1234567891011121314151617181920212223242526272829303132```while```循环```nums[i++]```一直减到它```&lt;target```退出```while```用result记录min的subL然后再次大循环从nums[j+1]```cclass Solution &#123;public: int minSubArrayLen(int target, vector&lt;int&gt;&amp; nums) &#123; int i=0; int subL=0; int sum=0; int result=INT_MAX; for(int j =0;j&lt;nums.size();j++)&#123; sum+=nums[j]; while(sum&gt;=target)&#123; subL=j-i+1; sum-=nums[i]; result=min(result,subL); i++; &#125; &#125; return result==INT_MAX ? 0 : result; &#125;&#125;; 如何理解 1return result==INT_MAX ? 0 : result; 当result&#x3D;&#x3D;INT_MAX时候 是 返回0 否 返回result 如何理解 1result = result &lt; subLength ? result : subLength; 当result&lt;subL的时候 是 返回result 否 返回subL","categories":[{"name":"代码随想录","slug":"代码随想录","permalink":"http://example.com/categories/%E4%BB%A3%E7%A0%81%E9%9A%8F%E6%83%B3%E5%BD%95/"}],"tags":[{"name":"滑动窗口","slug":"滑动窗口","permalink":"http://example.com/tags/%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3/"}]},{"title":"双指针法-977. 有序数组的平方","slug":"双指针-977有序数组的平方","date":"2023-04-14T14:27:22.038Z","updated":"2023-04-14T14:28:03.321Z","comments":true,"path":"2023/04/14/双指针-977有序数组的平方/","link":"","permalink":"http://example.com/2023/04/14/%E5%8F%8C%E6%8C%87%E9%92%88-977%E6%9C%89%E5%BA%8F%E6%95%B0%E7%BB%84%E7%9A%84%E5%B9%B3%E6%96%B9/","excerpt":"","text":"977. 有序数组的平方 12345678910111213141516171819class Solution &#123;public: vector&lt;int&gt; sortedSquares(vector&lt;int&gt;&amp; nums) &#123; vector&lt;int&gt; result(nums.size(),0); int k=nums.size()-1; for(int i=0,j=nums.size()-1;i&lt;=j;)&#123; // 注意i&lt;=j if(nums[i]*nums[i]&lt;nums[j]*nums[j])&#123; result[k--]=nums[j]*nums[j]; j--; &#125; else if(nums[i]*nums[i]&gt;=nums[j]*nums[j])&#123; result[k--]=nums[i]*nums[i]; i++; &#125; &#125; return result; &#125;&#125;;","categories":[{"name":"代码随想录","slug":"代码随想录","permalink":"http://example.com/categories/%E4%BB%A3%E7%A0%81%E9%9A%8F%E6%83%B3%E5%BD%95/"}],"tags":[{"name":"双指针法","slug":"双指针法","permalink":"http://example.com/tags/%E5%8F%8C%E6%8C%87%E9%92%88%E6%B3%95/"}]},{"title":"双指针法---844.比较含退格的字符串","slug":"双指针法---844.比较含退格的字符串","date":"2023-04-13T14:09:58.835Z","updated":"2023-04-13T14:21:42.844Z","comments":true,"path":"2023/04/13/双指针法---844.比较含退格的字符串/","link":"","permalink":"http://example.com/2023/04/13/%E5%8F%8C%E6%8C%87%E9%92%88%E6%B3%95---844.%E6%AF%94%E8%BE%83%E5%90%AB%E9%80%80%E6%A0%BC%E7%9A%84%E5%AD%97%E7%AC%A6%E4%B8%B2/","excerpt":"","text":"844. 比较含退格的字符串我没看懂怎么用双指针，用栈吧（阿巴阿巴阿巴，傻子流口水） 12345678910111213141516171819class Solution &#123;public: bool backspaceCompare(string S, string T) &#123; return build(S) == build(T); &#125; string build(string str) &#123; string ret; for (char ch : str) &#123; if (ch != &#x27;#&#x27;) &#123; ret.push_back(ch); &#125; else if (!ret.empty()) &#123; ret.pop_back(); &#125; &#125; return ret; &#125;&#125;;","categories":[{"name":"代码随想录","slug":"代码随想录","permalink":"http://example.com/categories/%E4%BB%A3%E7%A0%81%E9%9A%8F%E6%83%B3%E5%BD%95/"}],"tags":[{"name":"双指针法","slug":"双指针法","permalink":"http://example.com/tags/%E5%8F%8C%E6%8C%87%E9%92%88%E6%B3%95/"}]},{"title":"双指针法---283. 移动零","slug":"双指针法---283.-移动零","date":"2023-04-13T13:16:37.903Z","updated":"2023-04-13T13:16:37.903Z","comments":true,"path":"2023/04/13/双指针法---283.-移动零/","link":"","permalink":"http://example.com/2023/04/13/%E5%8F%8C%E6%8C%87%E9%92%88%E6%B3%95---283.-%E7%A7%BB%E5%8A%A8%E9%9B%B6/","excerpt":"","text":"283. 移动零12345678910111213141516171819void moveZeroes(int* nums, int numsSize)&#123; int target=0; int slow=0; int fast; for(fast=0;fast&lt;numsSize;fast++)&#123; if(nums[fast]!=target)&#123; nums[slow]=nums[fast]; slow++; &#125; &#125; int i; for(i=slow;i&lt;numsSize;i++)&#123; nums[i]=target; &#125; return i;&#125; 在后面一个for那边卡了，不敢写（因为用了两个for）时间复杂度大不敢了","categories":[{"name":"代码随想录","slug":"代码随想录","permalink":"http://example.com/categories/%E4%BB%A3%E7%A0%81%E9%9A%8F%E6%83%B3%E5%BD%95/"}],"tags":[{"name":"双指针法","slug":"双指针法","permalink":"http://example.com/tags/%E5%8F%8C%E6%8C%87%E9%92%88%E6%B3%95/"}]},{"title":"双指针法---26. 删除有序数组中的重复项","slug":"双指针法---26.-删除有序数组中的重复项","date":"2023-04-12T14:56:39.562Z","updated":"2023-04-12T14:56:39.562Z","comments":true,"path":"2023/04/12/双指针法---26.-删除有序数组中的重复项/","link":"","permalink":"http://example.com/2023/04/12/%E5%8F%8C%E6%8C%87%E9%92%88%E6%B3%95---26.-%E5%88%A0%E9%99%A4%E6%9C%89%E5%BA%8F%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84%E9%87%8D%E5%A4%8D%E9%A1%B9/","excerpt":"","text":"26. 删除有序数组中的重复项 1234567891011int removeDuplicates(int* nums, int numsSize)&#123; int slow=0; int fast; for(fast=0;fast&lt;numsSize;fast++)&#123; if(nums[slow]!=nums[fast])&#123; slow++; nums[slow]=nums[fast]; &#125; &#125; return slow+1;&#125;","categories":[{"name":"代码随想录","slug":"代码随想录","permalink":"http://example.com/categories/%E4%BB%A3%E7%A0%81%E9%9A%8F%E6%83%B3%E5%BD%95/"}],"tags":[{"name":"双指针法","slug":"双指针法","permalink":"http://example.com/tags/%E5%8F%8C%E6%8C%87%E9%92%88%E6%B3%95/"}]},{"title":"双指针法---27.移除元素","slug":"双指针法---移除元素","date":"2023-04-12T14:14:34.792Z","updated":"2023-04-12T14:55:32.821Z","comments":true,"path":"2023/04/12/双指针法---移除元素/","link":"","permalink":"http://example.com/2023/04/12/%E5%8F%8C%E6%8C%87%E9%92%88%E6%B3%95---%E7%A7%BB%E9%99%A4%E5%85%83%E7%B4%A0/","excerpt":"","text":"27. 移除元素 1234567891011int removeElement(int* nums, int numsSize, int val)&#123; int slow=0; for( int fast=0;fast&lt;numsSize;fast++)&#123; if(nums[fast]!=val)&#123; nums[slow]=nums[fast]; slow++; &#125; &#125; return slow;&#125; 反而比暴力慢 12345678910111213141516int removeElement(int* nums, int numsSize, int val)&#123; int j=0; int nums2[100]; int i; for( i =0;i&lt;numsSize;i++)&#123; if (nums[i]==val)&#123; for(int j = i + 1;j &lt; numsSize;j++)&#123; nums[j-1]=nums[j]; &#125; numsSize--; i--; &#125; &#125; return numsSize;&#125;","categories":[{"name":"代码随想录","slug":"代码随想录","permalink":"http://example.com/categories/%E4%BB%A3%E7%A0%81%E9%9A%8F%E6%83%B3%E5%BD%95/"}],"tags":[{"name":"双指针法","slug":"双指针法","permalink":"http://example.com/tags/%E5%8F%8C%E6%8C%87%E9%92%88%E6%B3%95/"}]},{"title":"双指针法","slug":"双指针法","date":"2023-04-12T14:08:45.228Z","updated":"2023-04-12T14:33:48.627Z","comments":true,"path":"2023/04/12/双指针法/","link":"","permalink":"http://example.com/2023/04/12/%E5%8F%8C%E6%8C%87%E9%92%88%E6%B3%95/","excerpt":"","text":"双指针法（快慢指针法）： 通过一个快指针和慢指针在一个for循环下完成两个for循环的工作。 定义快慢指针 快指针：寻找新数组的元素 ，新数组就是不含有目标元素的数组 慢指针：指向更新 新数组下标的位置 12345678910slow=0;val=3nums[0,1,2,3,3,0,4,2];for(int fast=0;fast&lt;size;fast++)&#123; if(nums[fast]!=val)&#123; //当【fast】的不等于val的值的时候 nums[slow]=nums[fast]; // slow是下标 fast是数组元素 slow++; &#125;&#125; return slow; 123456789101112131415161718192021222324252627/*** 相向双指针方法，基于元素顺序可以改变的题目描述改变了元素相对位置，确保了移动最少元素* 时间复杂度：O(n)* 空间复杂度：O(1)*/class Solution &#123;public: int removeElement(vector&lt;int&gt;&amp; nums, int val) &#123; int leftIndex = 0; int rightIndex = nums.size() - 1; while (leftIndex &lt;= rightIndex) &#123; // 找左边等于val的元素 while (leftIndex &lt;= rightIndex &amp;&amp; nums[leftIndex] == val)&#123; ++leftIndex; &#125; // 找右边不等于val的元素 while (leftIndex &lt;= rightIndex &amp;&amp; nums[rightIndex] != val) &#123; -- rightIndex; &#125; // 将右边不等于val的元素覆盖左边等于val的元素 if (leftIndex &lt; rightIndex) &#123; nums[leftIndex++] = nums[rightIndex--]; &#125; &#125; return leftIndex; // leftIndex一定指向了最终数组末尾的下一个元素 &#125;&#125;;","categories":[{"name":"代码随想录","slug":"代码随想录","permalink":"http://example.com/categories/%E4%BB%A3%E7%A0%81%E9%9A%8F%E6%83%B3%E5%BD%95/"}],"tags":[{"name":"双指针法","slug":"双指针法","permalink":"http://example.com/tags/%E5%8F%8C%E6%8C%87%E9%92%88%E6%B3%95/"}]},{"title":"vector容器删除元素的几种简单方法","slug":"vector容器删除元素的几种简单方法","date":"2023-04-12T13:26:17.947Z","updated":"2023-04-12T14:57:14.308Z","comments":true,"path":"2023/04/12/vector容器删除元素的几种简单方法/","link":"","permalink":"http://example.com/2023/04/12/vector%E5%AE%B9%E5%99%A8%E5%88%A0%E9%99%A4%E5%85%83%E7%B4%A0%E7%9A%84%E5%87%A0%E7%A7%8D%E7%AE%80%E5%8D%95%E6%96%B9%E6%B3%95/","excerpt":"","text":"一、直接删除法（1）使用 vector库函数“erase”删除，使用erase函数后容器size自动-112345678910int removeElement(vector&lt;int&gt;&amp; nums, int detarget) &#123; for (int i = 0; i &lt; nums.size(); i++)&#123; if(nums[i] == detarget)&#123; nums.erase(nums.begin() + i); i--; //由于容器size-1，还按原来的i的话相当于自动右移一位而漏掉一个元素 &#125; &#125; return nums.size(); &#125; 12345678910111213141516171819202122232425262728#include &lt;iostream&gt;#include &lt;vector&gt;using namespace std;int removeElement(vector&lt;int&gt;&amp; nums, int detarget) &#123; for (int i = 0; i &lt; nums.size(); i++)&#123; if(nums[i] == detarget)&#123; nums.erase(nums.begin() + i); i--; //由于容器size-1，还按原`` 来的i的话相当于自动右移一位而漏掉一个元素 &#125; &#125; return nums.size();&#125;int main() &#123; vector&lt;int&gt; nums ; nums.push_back(3); nums.push_back(2); nums.push_back(2); nums.push_back(3); int detarget = 3; int len = removeElement(nums, detarget); cout &lt;&lt; &quot;After removing &quot; &lt;&lt; detarget &lt;&lt; &quot;, the length of nums is &quot; &lt;&lt; len &lt;&lt; endl; for(int i = 0; i &lt; len; i++)&#123; cout &lt;&lt; nums[i] &lt;&lt; &quot; &quot;; &#125; cout &lt;&lt; endl; return 0;&#125; （2）使用 vector库函数“swap和pop_back()”,由于pop_back删除的是最后一个元素，所以先移位再删除12345678910int removeElement(vector&lt;int&gt;&amp; nums, int detarget) &#123; for (int i = 0; i &lt; nums.size(); i++)&#123; if(nums[i] == detarget)&#123; swap(nums[i], nums[nums.size() - 1]); //将要删除的元素交换到最后 nums.pop_back(); i--; //这里的i--与上面的作用一样 &#125; &#125; return nums.size(); &#125; 二、遍历覆盖法如果从数组的角度理解，因为数组存储的内容在地址上是连续的，要移除目标元素，就没有库函数可以使用，那就需要对其他元素进行处理，进行覆盖和前移，比较暴力的思路是发现目标元素后，将后面的所有元素都前移覆盖原来的元素，这种方法需要两个for循环，时间复杂度为O(n2),这里不详细讲这种写法。从覆盖的角度思考，我们可以通过一次遍历把非目标元素全部前移覆盖到前半部片 123456int removeElement(vector&lt;int&gt;&amp; nums, int detarget) &#123; int size = 0; for(auto x : nums) //遍历全部元素 if(x != detarget) nums[size++] = x;//如果不是要删除的目标元素，把它前移覆盖到前半部分 return size; //这里的size即为删除后的容量大小 &#125; 1234567891011121314151617//暴力int removeElement(int* nums, int numsSize, int val)&#123; int j=0; int nums2[100]; int i; for( i =0;i&lt;numsSize;i++)&#123; if (nums[i]==val)&#123; for(int j = i + 1;j &lt; numsSize;j++)&#123; nums[j-1]=nums[j]; &#125; numsSize--; i--; &#125; &#125; return numsSize;&#125; 三、相向双指针法(1)使用vector库函数swap，通过有两个指针和一个for循环将所有元素分为两个部分,左端的指针（快指针）控制前半部分的边界，swap后前半部分全部是要保留的元素右端的指针（慢指针）控制后半部分的边界，swap后后半部分全部是要删除的元素 &#x2F;&#x2F;时间复杂度：O（n)&#x2F;&#x2F;空间复杂度：O（1） 123456789101112int removeElement(vector&lt;int&gt;&amp; nums, int detarget) &#123; int j = nums.size() - 1; for (int i = 0; i &lt;= j; i++) &#123; if (nums[i] == detarget) &#123; swap(nums[i--], nums[j--]); //注意这里的i--，j--，代表先交换再移动，而不是先移动再交换 //i--的原因：如果发生交换的两个元素全是要删除的目标元素，这样不会把换过来的漏删 &#125; &#125; return j + 1; //j+1就是删除完的size大小 &#125; ps：上面几种方法只给出了核心算法的代码，具体问题做出相应改动即可","categories":[{"name":"代码随想录","slug":"代码随想录","permalink":"http://example.com/categories/%E4%BB%A3%E7%A0%81%E9%9A%8F%E6%83%B3%E5%BD%95/"}],"tags":[{"name":"vector容器","slug":"vector容器","permalink":"http://example.com/tags/vector%E5%AE%B9%E5%99%A8/"}]},{"title":"4-12-2023","slug":"4-12-2023","date":"2023-04-12T08:00:36.342Z","updated":"2023-04-12T08:03:48.993Z","comments":true,"path":"2023/04/12/4-12-2023/","link":"","permalink":"http://example.com/2023/04/12/4-12-2023/","excerpt":"","text":"2.打卡 3.洛谷先mark一下之前的题目数量，vjudge就不去刷了。 Conclusion:一天2h打题目太少了 4.数学放缓(等张宇来了过第三遍一二章（发疯）理出思维导图) 改良计划: ①下午没课就看数学，看到5.吃饭，吃完回来继续数学，到7.30。 ②看英语文章1h（尝试了一下，有难度的文章1h够呛） ③刷题到11.00 ④回去床上背单词（当然课上不困最好课上干掉） ⑤最近沉迷策门有所懈怠（双手合十）（低头认错）","categories":[{"name":"2023","slug":"2023","permalink":"http://example.com/categories/2023/"}],"tags":[{"name":"casual_talk","slug":"casual-talk","permalink":"http://example.com/tags/casual-talk/"}]},{"title":"memset函数","slug":"memset函数","date":"2023-04-11T13:39:36.903Z","updated":"2023-04-11T13:53:31.346Z","comments":true,"path":"2023/04/11/memset函数/","link":"","permalink":"http://example.com/2023/04/11/memset%E5%87%BD%E6%95%B0/","excerpt":"","text":"memset简介memset是一个初始化函数，作用是将某一块内存中的全部设置为指定的值。 void *memset(void *s, int c, size_t n); s指向要填充的内存块。c是要被设置的值。n是要被设置该值的字符数。返回类型是一个指向存储区s的指针。 需要说明的几个地方 一、不能任意赋值memset函数是按照字节对内存块进行初始化，所以不能用它将int数组出初始化为0和-1之外的其他值（除非该值高字节和低字节相同）。其实c的实际范围应该在0~255，因为memset函数只能取c的后八位给所输入范围的每个字节。也就是说无论c多大只有后八位二进制是有效的。 对于int a[4];memset(a, -1, sizeof(a)) 与 memset(a, 511, sizeof(a)) 所赋值的结果一样都为-1：因为 -1 的二进制码为（11111111 11111111 11111111 11111111）；511 的二进制码为（00000000 00000000 00000001 11111111）；后八位均为（11111111），所以数组中的每个字节都被赋值为（11111111）。注意int占四个字节，例如a[0]的四个字节都被赋值为（11111111），那么a[0]（11111111 11111111 11111111 11111111），即a[0] &#x3D; -1。 二、注意所要赋值的数组的元素类型先来看两个例子：例一：对char类型的数组a初始化，设置元素全为’1’ main()&#123;1234567 char a[4]; memset(a,&#x27;1&#x27;,4); for(int i=0; i&lt;4; i++)&#123; cout&lt;&lt;a[i]&lt;&lt;&quot; &quot;; &#125; return 0;&#125; 例二：对int类型的数组a初始化，设置元素值全为1 main()&#123;1234567 int a[4]; memset(a,1,sizeof(a)); for(int i=0; i&lt;4; i++)&#123; cout&lt;&lt;a[i]&lt;&lt;&quot; &quot;; &#125; return 0;&#125; 1、首先要说明的第一点 对于第二个程序，数组a是整型的，一般int所占内存空间为4个字节，所以在使用memset赋值时，下面的语句是错误的： 12int a[4];memset(a,1,4); 由于memset函数是以字节为单位进行赋值的，所以上述代码是为数组a的前4个字节进行赋值，那么所得到的执行结果就只能是： 正确的memset语句应为： 12memset(a,1,16); //int所占内存为4字节的情况memset(a,1,sizeof(a)); 至于为什么不是预期得到的1，将在下面的第二点进行说明。 当然，不同的机器上int的大小可能不同，所以最好用sizeof()函数。 2、为什么第一个程序可以正确赋值1而第二个不可以？这就又回到了刚刚说的第一个问题，memset函数中只能取c的后八位赋给每个字节。 第一个程序中，数组a是字符型的，字符型占据的内存大小就是1Byte，而memset函数也是以字节为单位进行赋值的，所以输出正确。第二个程序中，数组a是整型的，整型占据的内存大小为4Byte，而memset函数还是按照字节为单位进行赋值，将1（00000001）赋给每一个字节。那么对于a[0]来说，其值为(00000001 00000001 00000001 00000001），即十进制的16843009。 关于所要赋值的字符数的写法先来看一个示例： 12345678910111213141516#include&lt;bits/stdc++.h&gt;using namespace std;void fun1(int a[])&#123; memset(a,-1,sizeof(a)); &#125;int main()&#123; int a[6]; fun1(a); for(int i=0; i&lt;6; i++)&#123; cout&lt;&lt;a[i]&lt;&lt;&quot; &quot;; &#125; return 0;&#125;当数组作为参数传递时，其传递的实际上是一个指针，这个指针指向数组的首地址，如果用sizeof(a)函数得到的只是指针的长度，而不是数组的长度。 解决方案：在函数中加入数组长度参数，在传递前先获取数组长度，然后将数组长度作为参数传递进去。 12345678910111213141516#include&lt;bits/stdc++.h&gt;using namespace std;void fun1(int a[], int len)&#123; memset(a,-1,len); &#125;int main()&#123; int a[6]; int len = sizeof(a); fun1(a,len); for(int i=0; i&lt;6; i++)&#123; cout&lt;&lt;a[i]&lt;&lt;&quot; &quot;; &#125; return 0;&#125; 具体用法实例初始化数组 1234567891011char str[100];memset(str,0,100);清空结构体类型的变量typedef struct Stu&#123; char name[20]; int cno;&#125;Stu;Stu stu1; memset(&amp;stu1, 0 ,sizeof(Stu));Stu stu2[10]; //数组memset(stu2, 0, sizeof(Stu)*10); 此外，如果结构体中有数组的话还是需要对数组单独进行初始化处理的。","categories":[{"name":"代码随想录","slug":"代码随想录","permalink":"http://example.com/categories/%E4%BB%A3%E7%A0%81%E9%9A%8F%E6%83%B3%E5%BD%95/"}],"tags":[{"name":"memset函数","slug":"memset函数","permalink":"http://example.com/tags/memset%E5%87%BD%E6%95%B0/"}]},{"title":"367. 有效的完全平方数","slug":"367.-有效的完全平方数","date":"2023-04-11T13:15:52.421Z","updated":"2023-04-11T13:15:52.421Z","comments":true,"path":"2023/04/11/367.-有效的完全平方数/","link":"","permalink":"http://example.com/2023/04/11/367.-%E6%9C%89%E6%95%88%E7%9A%84%E5%AE%8C%E5%85%A8%E5%B9%B3%E6%96%B9%E6%95%B0/","excerpt":"","text":"367. 有效的完全平方数 1234567891011121314151617181920bool isPerfectSquare(int num)&#123; long long left=1; long long right=num; long long middle; long long temp=0; while(left&lt;=right)&#123; middle=(left+right)/2; if(middle*middle&lt;=num)&#123; if(middle*middle==num)&#123; temp=middle; &#125; left=middle+1; &#125; else if(middle*middle&gt;num)&#123; right=middle-1; &#125; &#125; if(temp==0) return false; else return temp;&#125;","categories":[{"name":"代码随想录","slug":"代码随想录","permalink":"http://example.com/categories/%E4%BB%A3%E7%A0%81%E9%9A%8F%E6%83%B3%E5%BD%95/"}],"tags":[{"name":"二分查找","slug":"二分查找","permalink":"http://example.com/tags/%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE/"}]},{"title":"69.x的平方根","slug":"69.x的平方根","date":"2023-04-11T13:05:23.435Z","updated":"2023-04-11T13:07:57.700Z","comments":true,"path":"2023/04/11/69.x的平方根/","link":"","permalink":"http://example.com/2023/04/11/69.x%E7%9A%84%E5%B9%B3%E6%96%B9%E6%A0%B9/","excerpt":"","text":"69. x 的平方根 12345678910111213141516171819202122int mySqrt(int x)&#123; long long temp; long long left = 1; long long right = x; long long middle; if (x==0)temp=0; else if (x==1) temp=1; else if(x!=0&amp;&amp;x!=1)&#123; while(left&lt;=right)&#123; middle=(left+right)/2; if(middle&lt;=x/middle)&#123; temp=middle; left=middle+1; &#125; else if(middle&gt;x/middle)&#123; right=middle-1; &#125; &#125; &#125; return temp;&#125; 123456789101112131415161718192021222324252627282930313233#include&lt;iostream&gt;#include&lt;vector&gt;using namespace std;int main()&#123; int temp; int n; cin&gt;&gt;n;// vector&lt;int&gt; x; // for(int i=0;i&lt;n;i++)// &#123;// x.push_back(i);// &#125; int left=1; int right=n; int middle;// int target=2; while(left&lt;=right)&#123; middle=(left+right)/2; if(middle&gt;n/middle)&#123; right=middle-1; &#125; else if(middle&lt;=n/middle)&#123; //middle^2&lt;n temp=middle; //因为2^2&lt;8&lt;2^3 所以直接取这边的middle left=middle+1; &#125; &#125; cout&lt;&lt;temp; return 0;&#125;","categories":[{"name":"代码随想录","slug":"代码随想录","permalink":"http://example.com/categories/%E4%BB%A3%E7%A0%81%E9%9A%8F%E6%83%B3%E5%BD%95/"}],"tags":[{"name":"二分查找","slug":"二分查找","permalink":"http://example.com/tags/%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE/"}]},{"title":"35. 搜索插入位置","slug":"35.-搜索插入位置","date":"2023-04-10T13:11:33.748Z","updated":"2023-04-10T13:11:33.748Z","comments":true,"path":"2023/04/10/35.-搜索插入位置/","link":"","permalink":"http://example.com/2023/04/10/35.-%E6%90%9C%E7%B4%A2%E6%8F%92%E5%85%A5%E4%BD%8D%E7%BD%AE/","excerpt":"","text":"35. 搜索插入位置 12345678910111213141516171819202122class Solution &#123;public: int searchInsert(vector&lt;int&gt;&amp; nums, int target) &#123; int left=0; int right=nums.size()-1; int middle; while(left&lt;=right)&#123; middle=(left+right)/2; if (nums[middle]&gt;target)&#123; right=middle-1; &#125; else if (nums[middle]&lt;target)&#123; left=middle+1; &#125; else&#123; return middle; &#125; &#125; return right+1; &#125;&#125;;","categories":[{"name":"代码随想录","slug":"代码随想录","permalink":"http://example.com/categories/%E4%BB%A3%E7%A0%81%E9%9A%8F%E6%83%B3%E5%BD%95/"}],"tags":[{"name":"二分查找","slug":"二分查找","permalink":"http://example.com/tags/%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE/"}]},{"title":"binary_search &lower_bound &upper_bound","slug":"binary_search-&lower_bound-&upper_bound","date":"2023-04-10T12:34:16.911Z","updated":"2023-04-10T12:37:08.524Z","comments":true,"path":"2023/04/10/binary_search-&lower_bound-&upper_bound/","link":"","permalink":"http://example.com/2023/04/10/binary_search-&lower_bound-&upper_bound/","excerpt":"","text":"使用方法： 1.binary_search:查找某个元素是否出现a.函数模板：binary_search(arr[],arr[]+size,indx) b.参数说明：arr[]:数组首地址size:数组元素个数indx：需要查找的值 c.函数功能：在数组中以二分法检索的方式查找，若在数组中查找到indx元素则真，若查找不到则返回值是假 2.lower_bound:查找第一个大于或等于某个元素的位置a.函数模板：lower_bound(arr[],arr[]+size,indx) b.参数说明：arr[] : 数组首地址size : 数组元素的个数indx : 需要查找的值 c.函数功能：函数lower_bound()在first和last的前闭后开区间进行二分查找，返回大于或等于val的第一个元素的位置，如果所有元素都小于val，则返回last的位置。举例：一个数组number序列为：4,10,11,30,69,70,96,100.设要插入数字3,9,111.pos为要插入的位置的下标，则 注意因为返回值是一个指针，所以减去数组的指针就是int变量了 pos &#x3D; lower_bound( number, number + 8, 3) - number，pos &#x3D; 0.即number数组的下标为0的位置。 pos &#x3D; lower_bound( number, number + 8, 9) - number， pos &#x3D; 1，即number数组的下标为1的位置（即10所在的位置）。 pos &#x3D; lower_bound( number, number + 8, 111) - number， pos &#x3D; 8，即number数组的下标为8的位置（但下标上限为7，所以返回最后一个元素的下一个元素）。e.注意：函数lower_bound()在first和last中的前闭后开区间进行二分查找，返回大于或等于val的第一个元素位置。如果所有元素都小于val，则返回last的位置，且last的位置是越界的！ 返回查找元素的第一个可安插位置，也就是“元素值&gt;&#x3D;查找值”的第一个元素的位置 3.upper_bound : 查找第一个大于某个元素的位置a. 函数模板 : upper_bound(arr[] , arr[]+size , indx)b. 参数说明：arr[] : 数组首地址size : 数组元素个数indx : 需要查找的值 c. 函数功能 : 函数upper_bound()返回的在前闭后开区间查找的关键字的上界，返回大于val的第一个元素位置 例如：一个数组number序列1,2,2,4.upper_bound(2)后，返回的位置是3（下标）也就是4所在的位置,同样，如果插入元素大于数组中全部元素，返回的是last。(注意：数组下标越界) 返回查找元素的最后一个可安插位置，也就是“元素值&gt;查找值”的第一个元素的位置 。 1234567891011121314151617181920#include&lt;iostream&gt;#include&lt;algorithm&gt;using namespace std;int main()&#123; int a[100]= &#123;5,9,11,30,69,70,96,100&#125;; int b=binary_search(a,a+9,5);//查找成功，返回1 cout&lt;&lt;&quot;在数组中查找元素5，结果为：&quot;&lt;&lt;b&lt;&lt;endl; int c=binary_search(a,a+9,99);//查找失败，返回0 cout&lt;&lt;&quot;在数组中查找元素99，结果为：&quot;&lt;&lt;b&lt;&lt;endl; int d=lower_bound(a,a+9,9)-a; cout&lt;&lt;&quot;在数组中查找第一个大于等于9的元素位置，结果为：&quot;&lt;&lt;d&lt;&lt;endl; int e=lower_bound(a,a+9,101)-a; cout&lt;&lt;&quot;在数组中查找第一个大于等于101的元素位置，结果为：&quot;&lt;&lt;e&lt;&lt;endl; int f=upper_bound(a,a+9,10)-a; cout&lt;&lt;&quot;在数组中查找第一个大于10的元素位置，结果为：&quot;&lt;&lt;f&lt;&lt;endl; int g=upper_bound(a,a+9,101)-a; cout&lt;&lt;&quot;在数组中查找第一个大于101的元素位置，结果为：&quot;&lt;&lt;g&lt;&lt;endl;&#125;","categories":[{"name":"代码随想录","slug":"代码随想录","permalink":"http://example.com/categories/%E4%BB%A3%E7%A0%81%E9%9A%8F%E6%83%B3%E5%BD%95/"}],"tags":[{"name":"search方法","slug":"search方法","permalink":"http://example.com/tags/search%E6%96%B9%E6%B3%95/"}]},{"title":"704.二分查找","slug":"704.二分查找","date":"2023-04-10T12:33:46.094Z","updated":"2023-04-10T12:47:04.024Z","comments":true,"path":"2023/04/10/704.二分查找/","link":"","permalink":"http://example.com/2023/04/10/704.%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE/","excerpt":"","text":"704. 二分查找 123456789101112131415161718192021class Solution &#123;public: int search(vector&lt;int&gt;&amp; nums, int target) &#123; int left=0; int right=nums.size()-1; while(left&lt;=right)&#123; int middle=(left+right)/2; if (nums[middle]&gt;target)&#123; right=middle-1; &#125; else if (nums[middle]&lt;target)&#123; left=middle+1; &#125; else&#123; return middle; &#125; &#125; return -1; &#125;&#125;; 1234567891011121314151617181920int search(int* nums, int numsSize, int target)&#123; int left=0; int right=numsSize-1; while(left&lt;=right)&#123; int middle=(left+right)/2; if (nums[middle]&gt;target)&#123; right=middle-1; &#125; else if (nums[middle]&lt;target)&#123; left=middle+1; &#125; else&#123; return middle; &#125; &#125; return -1; &#125; 12345678910111213141516171819202122232425262728293031323334#include&lt;iostream&gt;#include&lt;vector&gt;using namespace std;int main()&#123; vector &lt;int&gt; nums; int n; cin&gt;&gt;n; int target; cin&gt;&gt;target; while(n--)&#123; int temp; cin&gt;&gt;temp; nums.push_back(temp); &#125; int left=0; int right=nums.size()-1; while(left&lt;=right)&#123; int middle=(left+right)/2; if(nums[middle]&gt;target)&#123; right=middle-1; &#125; else if(nums[middle]&lt;target)&#123; left=middle+1; &#125; else &#123; cout&lt;&lt;middle; break; &#125; &#125; return 0; &#125;","categories":[{"name":"代码随想录","slug":"代码随想录","permalink":"http://example.com/categories/%E4%BB%A3%E7%A0%81%E9%9A%8F%E6%83%B3%E5%BD%95/"}],"tags":[{"name":"二分查找","slug":"二分查找","permalink":"http://example.com/tags/%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE/"}]},{"title":"vector容器","slug":"vector容器","date":"2023-04-10T12:01:57.586Z","updated":"2023-04-10T12:11:24.530Z","comments":true,"path":"2023/04/10/vector容器/","link":"","permalink":"http://example.com/2023/04/10/vector%E5%AE%B9%E5%99%A8/","excerpt":"","text":"1. vector：1.1 vector 说明 vector是向量类型，可以容纳许多类型的数据，因此也被称为容器 (可以理解为动态数组，是封装好了的类） 进行vector操作前应添加头文件#include &lt;vector&gt; 1.2 vector初始化：方式1. 123//定义具有10个整型元素的向量（尖括号为元素类型名，它可以是任何合法的数据类型），不具有初值，其值不确定vector&lt;int&gt;a(10);12 方式2. 12//定义具有10个整型元素的向量，且给出的每个元素初值为1vector&lt;int&gt;a(10,1); 方式3. 12//用向量b给向量a赋值，a的值完全等价于b的值vector&lt;int&gt;a(b); 方式4. 12//将向量b中从0-2（共三个）的元素赋值给a，a的类型为int型vector&lt;int&gt;a(b.begin(),b.begin+3); 方式5. 123 //从数组中获得初值int b[7]=&#123;1,2,3,4,5,6,7&#125;;vector&lt;int&gt; a(b,b+7）; 1.3 vector对象的常用内置函数使用（举例说明）12345678910111213141516171819202122232425262728293031323334353637383940414243#include&lt;vector&gt;vector&lt;int&gt; a,b;//b为向量，将b的0-2个元素赋值给向量aa.assign(b.begin(),b.begin()+3);//a含有4个值为2的元素a.assign(4,2);//返回a的最后一个元素a.back();//返回a的第一个元素a.front();//返回a的第i元素,当且仅当a存在a[i];//清空a中的元素a.clear();//判断a是否为空，空则返回true，非空则返回falsea.empty();//删除a向量的最后一个元素a.pop_back();//删除a中第一个（从第0个算起）到第二个元素，也就是说删除的元素从a.begin()+1算起（包括它）一直到a.begin()+3（不包括它）结束a.erase(a.begin()+1,a.begin()+3);//在a的最后一个向量后插入一个元素，其值为5a.push_back(5);//在a的第一个元素（从第0个算起）位置插入数值5,a.insert(a.begin()+1,5);//在a的第一个元素（从第0个算起）位置插入3个数，其值都为5a.insert(a.begin()+1,3,5);//b为数组，在a的第一个元素（从第0个元素算起）的位置插入b的第三个元素到第5个元素（不包括b+6）a.insert(a.begin()+1,b+3,b+6);//返回a中元素的个数a.size();//返回a在内存中总共可以容纳的元素个数a.capacity();//将a的现有元素个数调整至10个，多则删，少则补，其值随机a.resize(10);//将a的现有元素个数调整至10个，多则删，少则补，其值为2a.resize(10,2);//将a的容量扩充至100，a.reserve(100);//b为向量，将a中的元素和b中的元素整体交换a.swap(b);//b为向量，向量的比较操作还有 != &gt;= &gt; &lt;= &lt;a==b; 2. 顺序访问vector的几种方式，举例说明2.1. 对向量a添加元素的几种方式1.向向量a中添加元素 1234vector&lt;int&gt;a;for(int i=0;i&lt;10;++i)&#123; a.push_back(i);&#125; 2.从数组中选择元素向向量中添加 12345int a[6]=&#123;1,2,3,4,5,6&#125;;vector&lt;int&gt; b;for(int i=0;i&lt;=4;++i)&#123;b.push_back(a[i]);&#125; 3.从现有向量中选择元素向向量中添加 1234567int a[6]=&#123;1,2,3,4,5,6&#125;;vector&lt;int&gt;b;vector&lt;int&gt;c(a,a+4);for(vector&lt;int&gt;::iterator it=c.begin();it&lt;c.end();++it)&#123; b.push_back(*it);&#125; 4.从文件中读取元素向向量中添加 123ifstream in(&quot;data.txt&quot;);vector&lt;int&gt;a;for(int i;in&gt;&gt;i)&#123;a.push_back(i);&#125; 5.常见错误赋值方式 12vector&lt;int&gt;a;for(int i=0;i&lt;10;++i)&#123;a[i]=i;&#125;//下标只能用来获取已经存在的元素 2.2 从向量中读取元素1.通过下标方式获取 123int a[6]=&#123;1,2,3,4,5,6&#125;;vector&lt;int&gt;b(a,a+4);for(int i=0;i&lt;=b.size()-1;++i)&#123;cout&lt;&lt;b[i]&lt;&lt;endl;&#125; 2.通过迭代器方式读取 123int a[6]=&#123;1,2,3,4,5,6&#125;;vector&lt;int&gt;b(a,a+4);for(vector&lt;int&gt;::iterator it=b.begin();it!=b.end();it++)&#123;cout&lt;&lt;*it&lt;&lt;&quot; &quot;;&#125; 3.几个常用的算法12345678910#include&lt;algorithm&gt;//对a中的从a.begin()（包括它）到a.end()（不包括它）的元素进行从小到大排列sort(a.begin(),a.end());//对a中的从a.begin()（包括它）到a.end()（不包括它）的元素倒置，但不排列，如a中元素为1,3,2,4,倒置后为4,2,3,1reverse(a.begin(),a.end()); //把a中的从a.begin()（包括它）到a.end()（不包括它）的元素复制到b中，从b.begin()+1的位置（包括它）开始复制，覆盖掉原有元素copy(a.begin(),a.end(),b.begin()+1);//在a中的从a.begin()（包括它）到a.end()（不包括它）的元素中查找10，若存在返回其在向量中的位置 find(a.begin(),a.end(),10);","categories":[{"name":"代码随想录","slug":"代码随想录","permalink":"http://example.com/categories/%E4%BB%A3%E7%A0%81%E9%9A%8F%E6%83%B3%E5%BD%95/"}],"tags":[{"name":"vector容器","slug":"vector容器","permalink":"http://example.com/tags/vector%E5%AE%B9%E5%99%A8/"}]},{"title":"二分查找解题思路以及归错","slug":"二分查找解题思路以及归错","date":"2023-04-10T11:33:03.537Z","updated":"2023-04-10T13:10:31.600Z","comments":true,"path":"2023/04/10/二分查找解题思路以及归错/","link":"","permalink":"http://example.com/2023/04/10/%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE%E8%A7%A3%E9%A2%98%E6%80%9D%E8%B7%AF%E4%BB%A5%E5%8F%8A%E5%BD%92%E9%94%99/","excerpt":"","text":"1.[left,right] 1234567891011121314151617left=0;right=num.size()-1; //-1是因为]的原因while(left&lt;=right) //为什么= 因为[1,1]合法&#123; middle=(left+right)/2; if(num[middle]&gt;target) &#123; right=middle-1; //为什么是middle-1 因为&#x27;]&#x27;右区间去了闭，所以要减一避免重复 &#125; else if(num[middle]&lt;target)&#123; left=middle+1; //为什么+1，和上面同理 &#125; else&#123; return middle; &#125;&#125; 2.[left,right) 123456789101112131415left=0;right=num.size(); //)的原因while(left&lt;right) //为什么是&lt;,因为[),[1,1)开区间的取不到&#123; middle=(left+right)/2; if (num[middle]&gt;target)&#123; right=middle; //为什么不加1，因为)开区间取不到 &#125; else if(num[middle]&lt;target)&#123; left=middle+1; //闭区间取得到，所以+1 &#125; else&#123; return middle; &#125;&#125; 题目模板题704. 二分查找 其他： 35 搜索插入位置","categories":[{"name":"代码随想录","slug":"代码随想录","permalink":"http://example.com/categories/%E4%BB%A3%E7%A0%81%E9%9A%8F%E6%83%B3%E5%BD%95/"}],"tags":[{"name":"二分查找","slug":"二分查找","permalink":"http://example.com/tags/%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE/"}]},{"title":"Ubuntu安装hive，并配置mysql作为元数据库","slug":"Ubuntu安装hive，并配置mysql作为元数据库","date":"2023-04-07T07:26:24.366Z","updated":"2023-04-07T13:21:08.216Z","comments":true,"path":"2023/04/07/Ubuntu安装hive，并配置mysql作为元数据库/","link":"","permalink":"http://example.com/2023/04/07/Ubuntu%E5%AE%89%E8%A3%85hive%EF%BC%8C%E5%B9%B6%E9%85%8D%E7%BD%AEmysql%E4%BD%9C%E4%B8%BA%E5%85%83%E6%95%B0%E6%8D%AE%E5%BA%93/","excerpt":"","text":"hive是基于Hadoop的一个数据仓库工具，可以将结构化的数据文件映射为一张数据库表，并提供简单的sql查询功能，可以将sql语句转换为MapReduce任务进行运行。 其优点是学习成本低，可以通过类SQL语句快速实现简单的MapReduce统计，不必开发专门的MapReduce应用，十分适合数据仓库的统计分析。 一、安装hive1. 下载并解压hive源程序 Hive下载地址 1234sudo tar -zxvf ./apache-hive-1.2.1-bin.tar.gz -C /usr/local # 解压到/usr/local中cd /usr/local/sudo mv apache-hive-1.2.1-bin hive # 将文件夹名改为hivesudo chown -R dblab:dblab hive # 修改文件权限 2. 配置环境变量为了方便使用，我们把hive命令加入到环境变量中去，编辑~&#x2F;.bashrc文件vim ~/.bashrc，在最前面一行添加: 12export HIVE_HOME=/usr/local/hiveexport PATH=$PATH:$HIVE_HOME/bin 保存退出后，运行source ~/.bashrc使配置立即生效。 3. 修改&#x2F;usr&#x2F;local&#x2F;hive&#x2F;conf下的hive-site.xml将hive-default.xml.template重命名为hive-default.xml；新建一个文件touch hive-site.xml，并在hive-site.xml中粘贴如下配置信息： 123456789101112131415161718192021222324&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; standalone=&quot;no&quot;?&gt;&lt;?xml-stylesheet type=&quot;text/xsl&quot; href=&quot;configuration.xsl&quot;?&gt;&lt;configuration&gt; &lt;property&gt; &lt;name&gt;javax.jdo.option.ConnectionURL&lt;/name&gt; &lt;value&gt;jdbc:mysql://localhost:3306/hive?createDatabaseIfNotExist=true&lt;/value&gt; &lt;description&gt;JDBC connect string for a JDBC metastore&lt;/description&gt; &lt;/property&gt; &lt;property&gt; &lt;name&gt;javax.jdo.option.ConnectionDriverName&lt;/name&gt; &lt;value&gt;com.mysql.jdbc.Driver&lt;/value&gt; &lt;description&gt;Driver class name for a JDBC metastore&lt;/description&gt; &lt;/property&gt; &lt;property&gt; &lt;name&gt;javax.jdo.option.ConnectionUserName&lt;/name&gt; &lt;value&gt;hive&lt;/value&gt; &lt;description&gt;username to use against metastore database&lt;/description&gt; &lt;/property&gt; &lt;property&gt; &lt;name&gt;javax.jdo.option.ConnectionPassword&lt;/name&gt; &lt;value&gt;hive&lt;/value&gt; &lt;description&gt;password to use against metastore database&lt;/description&gt; &lt;/property&gt;&lt;/configuration&gt; 二、安装并配置mysql1.Ubuntu下mysql的安装请参考：Ubuntu安装MySQL2.下载mysql jdbc 包,下载地址 https://downloads.mysql.com/archives/c-j/ 12tar -zxvf mysql-connector-java-5.1.40.tar.gz #解压cp mysql-connector-java-5.1.40/mysql-connector-java-5.1.40-bin.jar /usr/local/hive/lib #将mysql-connector-java-5.1.40-bin.jar拷贝到/usr/local/hive/lib目录下 3. 启动并登陆mysql shell 12service mysql start #启动mysql服务mysql -u root -p #登陆shell界面 4. 新建hive数据库。 1mysql&gt; create database hive; #这个hive数据库与hive-site.xml中localhost:3306/hive的hive对应，用来保存hive元数据 5. 配置mysql允许hive接入： 1234567891011这条MySQL语句是为用户&#x27;hive&#x27;授予所有数据库的所有权限，并设置&#x27;hive&#x27;用户的密码为&#x27;hive&#x27;。这个命令通常用于在授权给用户访问数据库之前，先为该用户创建一个数据库账户并为其授权。在这个命令中，&#x27;identified by&#x27;语句用于设置用户的密码。&#x27;hive&#x27;是数据库账户的用户名和密码，它将用于在hive-site.xml配置文件中连接数据库。请注意，为了安全起见，建议不要在授权语句中明文指定密码。相反，可以使用以下语句来创建用户并设置其密码：CREATE USER &#x27;hive&#x27;@&#x27;localhost&#x27; IDENTIFIED BY &#x27;password&#x27;;然后使用以下命令来授予用户所有数据库的所有权限：GRANT ALL ON *.* TO &#x27;hive&#x27;@&#x27;localhost&#x27;;这样做可以保护您的数据库免受潜在的安全威胁。 12mysql&gt; grant all on *.* to hive@localhost identified by &#x27;hive&#x27;; #将所有数据库的所有表的所有权限赋给hive用户，后面的hive是配置hive-site.xml中配置的连接密码mysql&gt; flush privileges; #刷新mysql系统权限关系表 6. 启动hive启动hive之前，请先启动hadoop集群。 12start-all.sh #启动hadoophive #启动hive 解决Hive启动，Hive metastore database is not initialized的错误。出错原因：重新安装Hive和MySQL，导致版本、配置不一致。在终端执行如下命令: 1schematool -dbType mysql -initSchema Hive 分布现在包含一个用于 Hive Metastore 架构操控的脱机工具，名为 schematool.此工具可用于初始化当前 Hive 版本的 Metastore 架构。此外，其还可处理从较旧版本到新版本的架构升级。 https://dblab.xmu.edu.cn/blog/996/","categories":[{"name":"2023","slug":"2023","permalink":"http://example.com/categories/2023/"}],"tags":[{"name":"Spark","slug":"Spark","permalink":"http://example.com/tags/Spark/"}]},{"title":"Ubuntu安装MySQL及常用操作","slug":"Ubuntu安装MySQL及常用操作","date":"2023-04-07T06:54:34.492Z","updated":"2023-04-07T07:20:27.784Z","comments":true,"path":"2023/04/07/Ubuntu安装MySQL及常用操作/","link":"","permalink":"http://example.com/2023/04/07/Ubuntu%E5%AE%89%E8%A3%85MySQL%E5%8F%8A%E5%B8%B8%E7%94%A8%E6%93%8D%E4%BD%9C/","excerpt":"","text":"MySQL是一个关系型数据库管理系统，由瑞典MySQL AB 公司开发，目前属于 Oracle 旗下产品。MySQL 最流行的关系型数据库管理系统，在 WEB 应用方面MySQL是最好的 RDBMS (Relational Database Management System，关系数据库管理系统) 应用软件之一。 一、安装MySQL使用以下命令即可进行mysql安装，注意安装前先更新一下软件源以获得最新版本： 12sudo apt-get update #更新软件源sudo apt-get install mysql-server #安装mysql 上述命令会安装以下包：apparmormysql-client-5.7mysql-commonmysql-servermysql-server-5.7mysql-server-core-5.7因此无需再安装mysql-client等。安装过程会提示设置mysql root用户的密码，设置完成后等待自动安装即可。默认安装完成就启动了mysql。 启动和关闭mysql服务器： 12service mysql startservice mysql stop 确认是否启动成功，mysql节点处于LISTEN状态表示启动成功： 1sudo netstat -tap | grep mysql 进入mysql shell界面： 1mysql -u root -p 解决利用sqoop导入MySQL中文乱码的问题（可以插入中文，但不能用sqoop导入中文）导致导入时中文乱码的原因是character_set_server默认设置是latin1，如下图。 1show variables like &quot;char%&quot;; 可以单个设置修改编码方式set character_set_server=utf8;但是重启会失效，建议按以下方式修改编码方式。(1)编辑配置文件。sudo vi /etc/mysql/mysql.conf.d/mysqld.cnf(2)在[mysqld]下添加一行character_set_server=utf8。如下图 (3)重启MySQL服务。service mysql restart(4)登陆MySQL，并查看MySQL目前设置的编码。show variables like &quot;char%&quot;; 但是我的就直接是这样子的了： 二、MySQL常用操作注意：MySQL中每个命令后都要以英文分号；结尾。1、显示数据库mysql&gt; show databases;MySql刚安装完有两个数据库：mysql和test。mysql库非常重要，它里面有MySQL的系统信息，我们改密码和新增用户，实际上就是用这个库中的相关表进行操作。 2、显示数据库中的表mysql&gt; use mysql; （打开库，对每个库进行操作就要打开此库）Database changedmysql&gt; show tables; 3、显示数据表的结构：describe 表名; 4、显示表中的记录：select * from 表名;例如：显示mysql库中user表中的纪录。所有能对MySQL用户操作的用户都在此表中。select * from user; 5、建库：create database 库名;例如：创建一个名字位aaa的库mysql&gt; create database aaa; 6、建表：use 库名；create table 表名 (字段设定列表)；例如：在刚创建的aaa库中建立表person,表中有id(序号，自动增长)，xm（姓名）,xb（性别）,csny（出身年月）四个字段use aaa;mysql&gt; create table person (id int(3) auto_increment not null primary key, xm varchar(10),xb varchar(2),csny date);可以用describe命令察看刚建立的表结构。mysql&gt; describe person; 7、增加记录例如：增加几条相关纪录。mysql&gt;insert into person values(null,’张三’,’男’,’1997-01-02’);mysql&gt;insert into person values(null,’李四’,’女’,’1996-12-02’);注意，字段的值（’张三’,’男’,’1997-01-02’）是使用两个英文的单撇号包围起来，后面也是如此。因为在创建表时设置了id自增，因此无需插入id字段，用null代替即可。可用select命令来验证结果。mysql&gt; select * from person; 8、修改纪录例如：将张三的出生年月改为1971-01-10mysql&gt; update person set csny&#x3D;’1971-01-10’ where xm&#x3D;’张三’; 9、删除纪录例如：删除张三的纪录。mysql&gt; delete from person where xm&#x3D;’张三’; 10、删库和删表drop database 库名;drop table 表名； 11、查看mysql版本在mysql5.0中命令如下：show variables like ‘version’;或者：select version(); https://dblab.xmu.edu.cn/blog/1002/","categories":[{"name":"2023","slug":"2023","permalink":"http://example.com/categories/2023/"}],"tags":[{"name":"Spark","slug":"Spark","permalink":"http://example.com/tags/Spark/"}]},{"title":"实验4  Spark SQL编程初级实践","slug":"实验4-Spark-SQL编程初级实践","date":"2023-04-07T00:49:20.912Z","updated":"2023-04-07T00:49:20.912Z","comments":true,"path":"2023/04/07/实验4-Spark-SQL编程初级实践/","link":"","permalink":"http://example.com/2023/04/07/%E5%AE%9E%E9%AA%8C4-Spark-SQL%E7%BC%96%E7%A8%8B%E5%88%9D%E7%BA%A7%E5%AE%9E%E8%B7%B5/","excerpt":"","text":"1．Spark SQL基本操作将下列JSON格式数据复制到Linux系统中，并保存命名为employee.json。 为employee.json创建DataFrame，并写出Python语句完成下列操作： (1) 查询所有数据； (2) 查询所有数据，并去除重复的数据； (3) 查询所有数据，打印时去除id字段； (4) 筛选出age&gt;30的记录； (5) 将数据按age分组； (6) 将数据按name升序排列； (7) 取出前3行数据； (8) 查询所有记录的name列，并为其取别名为username； (9) 查询年龄age的平均值； (10) 查询年龄age的最小值。 1234567891011121314151617181920212223242526首先为employee.json创建DataFrame，并写出Python语句完成下列操作：创建DataFrame答案：&gt;&gt;&gt; spark=SparkSession.builder().getOrCreate()&gt;&gt;&gt; df = spark.read.json(&quot;file:///usr/local/spark/employee.json&quot;)(1) 查询DataFrame的所有数据答案：&gt;&gt;&gt; df.show()(2) 查询所有数据，并去除重复的数据答案：&gt;&gt;&gt; df.distinct().show()(3) 查询所有数据，打印时去除id字段答案：&gt;&gt;&gt; df.drop(&quot;id&quot;).show()(4) 筛选age&gt;20的记录答案：&gt;&gt;&gt; df.filter(df.age &gt; 30 ).show()(5) 将数据按name分组答案：&gt;&gt;&gt; df.groupBy(&quot;name&quot;).count().show()(6) 将数据按name升序排列答案：&gt;&gt;&gt; df.sort(df.name.asc()).show()(7)取出前3行数据答案：&gt;&gt;&gt; df.take(3) 或python&gt; df.head(3)(8)查询所有记录的name列，并为其取别名为username答案：&gt;&gt;&gt; df.select(df.name.alias(&quot;username&quot;)).show()(9)查询年龄age的平均值答案：&gt;&gt;&gt; df.agg(&#123;&quot;age&quot;: &quot;mean&quot;&#125;).show()(10)查询年龄age的最大值答案：&gt;&gt;&gt; df.agg(&#123;&quot;age&quot;: &quot;max&quot;&#125;).show() 2．编程实现将RDD转换为DataFrame源文件内容如下（包含id,name,age）： ​ 请将数据复制保存到Linux系统中，命名为employee.txt，实现从RDD转换得到DataFrame，并按“id:1,name:Ella,age:36”的格式打印出DataFrame的所有数据。请写出程序代码。 假设当前目录为&#x2F;usr&#x2F;local&#x2F;spark&#x2F;mycode&#x2F;rddtodf，在当前目录下新建一个目录mkdir -p src&#x2F;main&#x2F;python，然后在目录&#x2F;usr&#x2F;local&#x2F;spark&#x2F;mycode&#x2F;rddtodf&#x2F;src&#x2F;main&#x2F;python下新建一个rddtodf.py，复制下面代码；（下列两种方式任选其一） 方法一：利用反射来推断包含特定类型对象的RDD的schema，适用对已知数据结构的RDD转换； 123456789101112from pyspark.conf import SparkConffrom pyspark.sql.session import SparkSessionfrom pyspark import SparkContextfrom pyspark.sql.types import Rowif __name__ == &quot;__main__&quot;:sc = SparkContext(&quot;local&quot;,&quot;Simple App&quot;)peopleRDD = sc.textFile(&quot;file:///usr/local/spark/employee.txt&quot;)rowRDD = peopleRDD.map(lambda line : line.split(&quot;,&quot;)).map(lambda attributes : Row(int(attributes[0]),attributes[1],int(attributes[2]))).toDF()rowRDD.createOrReplaceTempView(&quot;employee&quot;)personsDF = spark.sql(&quot;select * from employee&quot;)personsDF.rdd.map(lambda t : &quot;id:&quot;+str(t[0])+&quot;,&quot;+&quot;Name:&quot;+t[1]+&quot;,&quot;+&quot;age:&quot;+str(t[2])).foreach(print) 方法二：使用编程接口，构造一个schema并将其应用在已知的RDD上。 12345678910111213141516171819from pyspark.sql.types import Rowfrom pyspark.sql.types import StructTypefrom pyspark.sql.types import StructFieldfrom pyspark.sql.types import StringTypefrom pyspark.conf import SparkConffrom pyspark import SparkContextfrom pyspark.sql.session import SparkSessionif __name__ == &quot;__main__&quot;:sc = SparkContext(&quot;local&quot;,&quot;Simple App&quot;)peopleRDD = sc.textFile(&quot;file:///usr/local/spark/employee.txt&quot;)schemaString = &quot;id name age&quot;fields = list(map( lambda fieldName : StructField(fieldName, StringType(), nullable = True), schemaString.split(&quot; &quot;)))schema = StructType(fields)rowRDD = peopleRDD.map(lambda line : line.split(&quot;,&quot;)).map(lambda attributes : Row(int(attributes[0]),attributes[1],int(attributes[2])))employeeDF = spark.createDataFrame(rowRDD, schema)employeeDF.createOrReplaceTempView(&quot;employee&quot;)results = spark.sql(&quot;SELECT * FROM employee&quot;)results.rdd.map(lambda t : &quot;id:&quot;+str(t[0])+&quot;,&quot;+&quot;Name:&quot;+t[1]+&quot;,&quot;+&quot;age:&quot;+str(t[2])).foreach(print) 1`python3 ./ rddtodf.py` 3. 编程实现利用DataFrame读写MySQL的数据（1）在MySQL数据库中新建数据库sparktest，再创建表employee，包含如表5-2所示的两行数据。 表5-2 employee表原有数据 id name gender Age 1 Alice F 22 2 John M 25 123456mysql&gt; create database sparktest;mysql&gt; use sparktest;mysql&gt; create table employee (id int(4), name char(20), gender char(4), age int(4));mysql&gt; insert into employee values(1,&#x27;Alice&#x27;,&#x27;F&#x27;,22);mysql&gt; insert into employee values(2,&#x27;John&#x27;,&#x27;M&#x27;,25); （2）配置Spark通过JDBC连接数据库MySQL，编程实现利用DataFrame插入如表5-3所示的两行数据到MySQL中，最后打印出age的最大值和age的总和。 表5-3 employee表新增数据 id name gender age 3 Mary F 26 4 Tom M 23 1答案：假设当前目录为/usr/local/spark/mycode/testmysql，在当前目录下新建一个目录mkdir -p src/main/python，然后在目录/usr/local/spark/mycode/testmysql/src/main/python下新建一个testmysql.py，复制下面代码； 123456789101112131415161718192021222324252627from pyspark import SparkContextfrom pyspark.sql import SQLContextfrom pyspark.sql.types import Rowfrom pyspark.sql.types import StructTypefrom pyspark.sql.types import StructFieldfrom pyspark.sql.types import StringTypefrom pyspark.sql.types import IntegerTypeif __name__ == &quot;__main__&quot;:sc = SparkContext( &#x27;local&#x27;, &#x27;test&#x27;)spark=SQLContext(sc)jdbcDF=spark.read.format(&quot;jdbc&quot;).option(&quot;url&quot;,&quot;jdbc:mysql://localhost:3306/sparktest&quot;).option(&quot;driver&quot;,&quot;com.mysql.jdbc.Driver&quot;).option(&quot;dbtable&quot;,&quot;employee&quot;).option(&quot;user&quot;, &quot;root&quot;).option(&quot;password&quot;, &quot;123&quot;).load()jdbcDF.filter(jdbcDF.age&gt;20).collect()//检测是否连接成功studentRDD = sc.parallelize([&quot;3 Mary F 26&quot;,&quot;4 Tom M 23&quot;]).map(lambda line : line.split(&quot; &quot;))schema = StructType([StructField(&quot;id&quot;,IntegerType(),True),StructField(&quot;name&quot;, StringType(), True),StructField(&quot;gender&quot;, StringType(), True),StructField(&quot;age&quot;,IntegerType(), True)])rowRDD = studentRDD.map(lambda p : Row(int(p[0]),p[1].strip(), p[2].strip(),int(p[3])))employeeDF = spark.createDataFrame(rowRDD, schema)prop = &#123;&#125;prop[&#x27;user&#x27;] = &#x27;root&#x27;prop[&#x27;password&#x27;] = &#x27;123&#x27;prop[&#x27;driver&#x27;] = &quot;com.mysql.jdbc.Driver&quot;employeeDF.write.jdbc(&quot;jdbc:mysql://localhost:3306/sparktest&quot;,&#x27;employee&#x27;,&#x27;append&#x27;, prop) jdbcDF.collect() jdbcDF.agg(&#123;&quot;age&quot;: &quot;max&quot;&#125;).show() jdbcDF.agg(&#123;&quot;age&quot;: &quot;sum&quot;&#125;).show() 然后我们，执行以下指令 123 python3 ./ rddtodf.py 在终端下，我们就可以看到结果了。","categories":[{"name":"2023","slug":"2023","permalink":"http://example.com/categories/2023/"}],"tags":[{"name":"Spark","slug":"Spark","permalink":"http://example.com/tags/Spark/"}]},{"title":"4-6-2023","slug":"4-6-2023","date":"2023-04-05T16:35:26.341Z","updated":"2023-04-05T16:44:05.615Z","comments":true,"path":"2023/04/06/4-6-2023/","link":"","permalink":"http://example.com/2023/04/06/4-6-2023/","excerpt":"反思三月","text":"反思三月 三月单词全勤 三月末制定了个学习计划分为①数学②数据结构③coding④单词。具体罗列出每天除去上课之后的空闲时间，然后安排这些内容。单词水课上可以背（但是早课太困用来睡觉为主），固定为21：00-23：00背，实现了三天（orz）。coding实现了0天（只把登录给写了），没实现是因为0：00之后的时间背没背完单词。数学重新看绿色同济书，目前看完了两章，并且把课后习题写完了，找回自信，但是错误率很高。回头看武忠祥的书，感觉总结的不错。接下来就是先看书，再看武忠祥。不得不说，书上的定义证明真的不错。数据结构进展为0 需要再安排时间实现②③ 每天至多6h空闲时间，做到晚上不熬夜，不报复性看手机，我的计划就能实现80%（我做得到有鬼） 和老爸交流了一下留学，还是不出去的好。考得上就上，考不上就上班。我的学校层次就在这边，出了国能证明自己有能力吗？不能。找捷径穿了一层华丽的衣服，回来还是草包。如果出去了回来，说是说留过学的，这样不就拉不下面子进厂了吗？哈哈哈。初中数学老师说过一句话：“人在做，天在看。”这一天天的到底学没学，学习的效果怎么样，我用每周博客来记录，算是对我自己的鞭策。","categories":[{"name":"2023","slug":"2023","permalink":"http://example.com/categories/2023/"}],"tags":[{"name":"casual_talk","slug":"casual-talk","permalink":"http://example.com/tags/casual-talk/"}]},{"title":"访问者模式","slug":"访问者模式","date":"2023-03-29T12:04:14.129Z","updated":"2023-03-29T12:04:41.972Z","comments":true,"path":"2023/03/29/访问者模式/","link":"","permalink":"http://example.com/2023/03/29/%E8%AE%BF%E9%97%AE%E8%80%85%E6%A8%A1%E5%BC%8F/","excerpt":"","text":"访问者模式访问者模式是一种行为设计模式， 它能将算法与其所作用的对象隔离开来。 模式动机假如某个软件团队开发了一款能够使用巨型图像中地理信息的应用程序。 图像中的每个节点既能代表复杂实体 （例如一座城市）， 也能代表更精细的对象 （例如工业区和旅游景点等）。 如果节点代表的真实对象之间存在公路， 那么这些节点就会相互连接。 在程序内部， 每个节点的类型都由其所属的类来表示， 每个特定的节点则是一个对象。 一段时间后， 软件团队接到了实现将图像导出到 XML 文件中的任务，如下图所示。 图8.2.1 将图像导出为 XML。 这些工作最初看上去非常简单。 该团队计划为每个节点类添加导出函数， 然后递归执行图像中每个节点的导出函数。 解决方案简单且优雅： 使用多态机制可以让导出方法的调用代码不会和具体的节点类相耦合。 但团队的系统架构师拒绝批准对已有节点类进行修改。 他认为这些代码已经是产品了， 不想冒险对其进行修改， 因为修改可能会引入潜在的缺陷。 所有节点的类中都必须添加导出至 XML 文件的方法， 但如果在修改代码的过程中引入了任何缺陷， 那么整个程序都会面临风险。 此外， 他还质疑在节点类中包含导出 XML 文件的代码是否有意义。 这些类的主要工作是处理地理数据。 导出 XML 文件的代码放在这里并不合适。 还有另一个原因， 那就是在此项任务完成后， 营销部门很有可能会要求程序提供导出其他类型文件的功能， 或者提出其他奇怪的要求。 这样你很可能会被迫再次修改这些重要但脆弱的类。 该模式适用场景：如果我们想为一个现有的类增加新功能，不得不考虑几个事情： 新功能会不会与现有功能出现兼容性问题？ 以后会不会再需要添加？ 如果类不允许修改代码怎么办？ 面对这些问题，最好的解决方法就是使用访问者模式，访问者模式适用于数据结构相对稳定的系统，把数据结构和算法解耦。 总结来说，在软件设计中，下面的情况可以使用访问者模式。 在实际使用时，对同一集合对象的操作并不是唯一的，对相同的元素对象可能存在多种不同的操作方式。而且这些操作方式并不稳定，可能还需要增加新的操作，以满足新的业务需求。此时，访问者模式就是一个值得考虑的解决方案。 访问者模式的目的是封装一些施加于某种数据结构元素之上的操作，一旦这些操作需要修改的话，接受这个操作的数据结构可以保持不变。为不同类型的元素提供多种访问操作方式，且可以在不修改原有系统的情况下增加新的操作方式。 简单来说，访问者模式就是一种分离****对象数据结构与行为的方法，通过这种分离，可达到为一个被访问者动态添加新的操作而无需做其它的修改的效果。 模式定义将作用于某种数据结构中的各元素的操作分离出来封装成独立的类，使其在不改变数据结构的前提下可以添加作用于这些元素的新的操作，为数据结构中的每个元素提供多种访问方式。 模式结构 访问者模式包含如下角色： Vistor: 抽象访问者。定义了对每一个元素（Element）访问的行为，它的参数就是可以访问的元素，它的方法个数理论上来讲与元素类个数（Element的实现类个数）是一样的。 ConcreteVisitor: 具体访问者。给出对每一个元素类访问时所产生的具体行为。 Element: 抽象元素。定义了一个接受访问者的方法（accept），其意义是指，每一个元素都要可以被访问者访问。 ConcreteElement: 具体元素。提供接受访问方法的具体实现，而这个具体的实现，通常情况下是使用访问者提供的访问该元素类的方法。 ObjectStructure: 对象结构。定义当中所提到的对象结构，对象结构是一个抽象表述，具体点可以理解为一个具有容器性质或者复合对象特性的类，它会含有一组元素（Element），并且可以迭代这些元素，供访问者访问。 模式时序图 模式抽象代码分析抽象访问者类： 具体访问者类： 抽象元素： 具体元素： 对象结构： 模式分析 访问者模式中对象结构存储了不同类型的元素对象，以供不同访问者访问。 访问者模式包括两个层次结构，一个是访问者层次结构，提供了抽象访问者和具体访问者，一个是元素层次结构，提供了抽象元素和具体元素。 相同的访问者可以以不同的方式访问不同的元素，相同的元素可以接受不同访问者以不同访问方式访问。在访问者模式中，增加新的访问者无须修改原有系统，系统具有较好的可扩展性 模式实例在本示例中，希望将一组几何形状导出到 XML文件。 存在的问题是，不能直接更改形状的代码，或者尽量少地修改形状代码。为此，使用访问者模式建立了一个基类，允许将任何行为添加到形状层次结构中，而无需更改这些类的现有代码。 Shape.java Dot.java Circle.java Rectangle.java CompoundShape.java Visitor.java Visitor.java Client.java 模式优点 使得增加新的访问操作变得很容易。 将有关元素对象的访问行为集中到一个访问者对象中，而不是分散到一个个的元素类中。 可以跨过类的等级结构访问属于不同的等级结构的元素类。 让用户能够在不修改现有类层次结构的情况下，定义该类层次结构的操作。 模式缺点 增加新的元素类很困难。在访问者模式中，每增加一个新的元素类都意味着要在抽象访问者角色中增加一个新的抽象操作，并在每一个具体访问者类中增加相应的具体操作，违背了开闭原则的要求。 破坏封装。访问者模式要求访问者对象访问并调用每一个元素对象的操作，这意味着元素对象有时候必须暴露一些自己的内部操作和内部状态，否则无法供访问者访问。 模式适用环境 一个对象结构包含很多类型的对象，希望对这些对象实施一些依赖其具体类型的操作。在访问者中针对每一种具体的类型都提供了一个访问操作，不同类型的对象可以有不同的访问操作。 需要对一个对象结构中的对象进行很多不同的并且不相关的操作，而需要避免让这些操作污染这些对象的类，也不希望在增加新操作时修改这些类。访问者模式使得我们可以将相关的访问操作集中起来定义在访问者类中，对象结构可以被多个不同的访问者类所使用，将对象本身与对象的访问操作分离。 对象结构中对象对应的类很少改变，但经常需要在此对象结构上定义新的操作。 模式应用 Java类库实例 javax.lang.model.element.AnnotationValue和AnnotationValueVisitor javax.lang.model.element.Element和ElementVisitor javax.lang.model.type.TypeMirror和TypeVisitor java.nio.file.FileVisitor和SimpleFileVisitor javax.faces.component.visit.VisitContext和VisitCallback 在一些编译器的设计中运用了访问者模式，程序代码是被访问的对象，它包括变量定义、变量赋值、逻辑运算、算术运算等语句，编译器需要对代码进行分析，如检查变量是否定义、变量是否赋值、算术运算是否合法等，可以将不同的操作封装在不同的类中，如检查变量定义的类、检查变量赋值的类、检查算术运算是否合法的类，这些类就是具体访问者，可以访问程序代码中不同类型的语句。在编译过程中除了代码分析外，还包含代码优化、空间分配和代码生成等部分，也可以将每一个不同编译阶段的操作封装到了跟该阶段有关的一个访问者类中。 在常用的Java XML处理技术DOM4J中，可以通过访问者模式的方式来读取并解析XML文档，VisitorSupport是DOM4J提供的Visitor接口的默认适配器，具体访问者只需继承VisitorSupport类即可。 模式扩展\\1. 与其他模式联用 由于访问者模式需要对对象结构进行操作，而对象结构本身是一个元素对象的集合，因此访问者模式经常需要与迭代器模式联用，在对象结构中使用迭代器来遍历元素对象。 在访问者模式中，元素对象可能存在容器对象和叶子对象，因此可以结合组合模式来进行设计。 \\2. 访问者模式以一种倾斜的方式支持开闭原则，增加新的访问者方便，但是增加新的元素很困难。","categories":[{"name":"2023","slug":"2023","permalink":"http://example.com/categories/2023/"}],"tags":[{"name":"设计模式","slug":"设计模式","permalink":"http://example.com/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"}]},{"title":"行为型软件设计模式","slug":"行为型软件设计模式","date":"2023-03-29T08:29:43.716Z","updated":"2023-03-29T11:17:45.189Z","comments":true,"path":"2023/03/29/行为型软件设计模式/","link":"","permalink":"http://example.com/2023/03/29/%E8%A1%8C%E4%B8%BA%E5%9E%8B%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/","excerpt":"","text":"行为型软件设计模式行为型模式(Behavioral Pattern)是对在不同的对象之间划分责任和算法的抽象化。 行为型模式不仅仅关注类和对象的结构，而且重点关注它们之间的相互作用。 通过行为型模式，可以更加清晰地划分类与对象的职责，并研究系统在运行时实例对象 之间的交互。在系统运行时，对象并不是孤立的，它们可以通过相互通信与协作完成某些复杂功能，一个对象在运行时也将影响到其他对象的运行。 行为型模式分为类行为型模式和对象行为型模式两种： 类行为型模式：类的行为型模式使用继承关系在几个类之间分配行为，类行为型模式主要通过多态等方式来分配父类与子类的职责。 对象行为型模式：对象的行为型模式则使用对象的聚合关联关系来分配行为，对象行为型模式主要是通过对象关联等方式来分配两个或多个类的职责。根据“合成复用原则”，系统中要尽量使用关联关系来取代继承关系，因此大部分行为型设计模式都属于对象行为型设计模式。 迭代器模式 迭代器模式是一种行为设计模式， 让你能在不暴露集合底层表现形式 （列表、 栈和树等） 的情况下遍历集合中所有的元素。 模式动机集合是编程中最常使用的数据类型之一，通常可以被认为是一组对象的容器。 大部分集合使用简单列表存储元素。 但有些集合还会使用栈、 树、 图和其他复杂的数据结构，如下图所示。 集合这种数据类型虽然是一种用于存储的数据结构，但同时需要提供访问其存储数据的方法，特别是一种可以遍历其存储所有数据的方法。 也就是说，无论集合的构成方式如何， 它都必须提供某种访问元素的方式， 便于其他代码使用其中的元素。 集合应提供一种能够遍历元素的方式， 且保证它不会周而复始地访问同一个元素。 对于基于数组或者列表的集合而言， 访问或者遍历其元素可以直接通过下标完成，这种对象遍历的方法是简单且唯一的。 但对于树和图这种复杂数据结构，应该如何遍历其中的元素呢？ 而且复杂数据结构的遍历方法是多样的。比如对于树形数据结构，就可以适用深度优先算法、广度优先或者随机存取等算法来遍历树结构。 一种简单的做法是，将这些遍历算法作为这些集合数据结构类的公共成员函数。但不断向集合类中添加遍历算法，首先会导致单个类的功能过于臃肿，集合数据结构类承担太多的功能，一方面提供添加和删除等功能，还要提供遍历访问功能。其次，集合数据结构类的首要功能是 “高效存储数据”，在遍历过程中，需要保存遍历状态，其和元素的添加和删除混杂在一起，容易引起混乱；添加过多的遍历算法会导致类的职责模糊问题，违反单一职责的设计原则。最后，不论是列表，还是树或者图，一般都会继承自共有的父类——泛型类，有些算法可能是根据特定应用订制的， 将其加入泛型集合类中会显得非常奇怪。 另一方面，从客户端来看，使用多种集合的客户端代码可能并不关心存储数据的方式（如同SQL数据库的使用者并不会关心底层数据库是MySql、SQL Server，还是Oracle一样），其更关心的是用这些数据结构存储数据后，如何访问（遍历）其中的所有数据。 不过由于不同的集合数据结构类提供不同的元素访问方式， 客户端代码将不得不与特定集合类进行耦合。 在这样的场景下，动态变化的是遍历数据对象的方法。一个自然而然的想法是，将遍历数据功能抽象形成单独的类，其专门负责遍历集合数据结构类中数据——这就是迭代器设计模式。 总结 一个聚合对象，如一个列表(List)或者一个集合(Set)，应该提供一种方法来让别人可以访问它的元素，而又不需要暴露它的内部结构。 针对不同的需要，可能还要以不同的方式遍历整个聚合对象，但是我们并不希望在聚合对象的抽象层接口中充斥着各种不同遍历的操作。 在迭代器模式中，提供一个外部的迭代器来对聚合对象进行访问和遍历，迭代器定义了一个访问该聚合元素的接口，并且可以跟踪当前遍历的元素，了解哪些元素已经遍历过而哪些没有。 模式定义迭代器模式(Iterator Pattern) ：提供一种方法来访问聚合对象，而不用暴露这个对象的内部表示，其别名为游标(Cursor)。 迭代器模式是一种对象行为型模式。 迭代器模式就是顺序访问聚集中的对象，这是集合中非常常见的一种操作。其包含两层意思： 需要遍历的对象，即聚集对象， 迭代器对象，用于对聚集对象进行遍历访问。 模式结构 模式时序图 模式抽象代码分析 迭代器接口 具体迭代器 集合接口声明 具体集合类 模式分析 聚合是一个管理和组织数据对象的数据结构。聚合对象主要拥有两个职责：一是存储内部数据；二是遍历内部数据。 将遍历聚合对象中数据的行为提取出来，封装到一个迭代器中，通过专门的迭代器来遍历聚合对象的内部数据，这就是迭代器模式的本质。迭代器模式是“单一职责原则”的完美体现。 在迭代器模式中应用了工厂方法模式，聚合类充当工厂类，而迭代器充当产品类，由于定义了抽象层，系统的扩展性很好，在客户端可以针对抽象聚合类和抽象迭代器进行编程。 java编程语言的类库都已经实现了迭代器模式，因此在实际使用中很少自定义迭代器，只需要直接使用Java语言中已定义好的迭代器即可。 模式实例在本例中， 迭代器模式用于遍历一个封装了访问微信好友关系功能的特殊集合。 该集合提供使用不同方式遍历档案资料的多个迭代器。 “好友 （friends）” 迭代器可用于遍历指定档案的好友。 “同事 （colleagues）” 迭代器也提供同样的功能， 但仅包括与目标用户在同一家公司工作的好友。 这两个迭代器都实现了同一个通用接口， 客户端能在不了解认证和发送 REST 请求等实现细节的情况下获取档案。 客户端仅通过接口与集合和迭代器交互， 也就不会同具体类耦合。 如果你决定将应用连接到全新的社交网络， 只需提供新的集合和迭代器类即可， 无需修改现有代码。 SocialNetwork.java Webchat.java LinkedIn.java ProfileIterator.java WebchatIterator.java LinkedInIterator.java Profile.java SocialSpammer.java Client.java 模式优点 单一职责原则。 通过将体积庞大的遍历算法代码抽取为独立的类， 可对客户端代码和集合进行整理。 开闭原则。 可实现新型的集合和迭代器并将其传递给现有代码， 无需修改现有代码。 可以并行遍历同一集合， 因为每个迭代器对象都包含其自身的遍历状态。 相似的， 可以暂停遍历并在需要时继续。 模式缺点 如果你的程序只与简单的集合进行交互， 应用该模式可能会矫枉过正。 对于某些特殊集合， 使用迭代器可能比直接遍历的效率低。 模式适用环境 访问一个聚合对象的内容而无须暴露它的内部表示。 需要为聚合对象提供多种遍历方式。 为遍历不同的聚合结构提供一个统一的接口。 模式应用该模式在 Java 代码中很常见。 许多框架和程序库都会使用它来提供遍历其集合的标准方式。 \\1. 下面是该模式在核心 Java 程序库中的一些示例： java.util.Iterator的所有实现 （还有 java.util.Scanner）。 java.util.Enumeration的所有实现 \\2. JDK1.2 引入了新的Java聚合框架Collections Collection是所有Java聚合类的根接口。 在JDK类库中，Collection的iterator()方法返回一个java.util.Iterator类型的对象，而其子接口java.util.List的listIterator()方法返回一个java.util.ListIterator类型的对象，ListIterator是Iterator的子类。它们构成了Java语言对迭代器模式的支持，Java语言的java.util.Iterator接口就是迭代器模式的应用。 识别方法： 迭代器可以通过导航方法 （例如 next和 previous等） 来轻松识别。 使用迭代器的客户端代码可能没有其所遍历的集合的直接访问权限。 模式扩展Java迭代器，•在JDK中，Iterator接口具有如下3个基本方法： Object next()：通过反复调用next()方法可以逐个访问聚合中的元素。 boolean hasNext()：hasNext()方法用于判断聚合对象中是否还存在下一个元素，为了不抛出异常，必须在调用next()之前先调用hasNext()。如果迭代对象仍然拥有可供访问的元素，那么hasNext()返回true。 void remove()：用于删除上次调用next()时所返回的元素 总结 声明迭代器接口。 该接口必须提供至少一个方法来获取集合中的下个元素。 但为了使用方便， 你还可以添加一些其他方法， 例如获取前一个元素、 记录当前位置和判断迭代是否已结束。 声明集合接口并描述一个获取迭代器的方法。 其返回值必须是迭代器接口。 如果你计划拥有多组不同的迭代器， 则可以声明多个类似的方法。 为希望使用迭代器进行遍历的集合实现具体迭代器类。 迭代器对象必须与单个集合实体链接。 链接关系通常通过迭代器的构造函数建立。 在你的集合类中实现集合接口。 其主要思想是针对特定集合为客户端代码提供创建迭代器的快捷方式。 集合对象必须将自身传递给迭代器的构造函数来创建两者之间的链接。 检查客户端代码， 使用迭代器替代所有集合遍历代码。 每当客户端需要遍历集合元素时都会获取一个新的迭代器。","categories":[{"name":"2023","slug":"2023","permalink":"http://example.com/categories/2023/"}],"tags":[{"name":"设计模式","slug":"设计模式","permalink":"http://example.com/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"}]},{"title":"No module named 'pyspark'","slug":"ModuleNotFoundError No module named 'pyspark'","date":"2023-03-27T17:03:55.971Z","updated":"2023-03-27T17:09:12.063Z","comments":true,"path":"2023/03/28/ModuleNotFoundError No module named 'pyspark'/","link":"","permalink":"http://example.com/2023/03/28/ModuleNotFoundError%20No%20module%20named%20'pyspark'/","excerpt":"","text":"ModuleNotFoundError: No module named ‘pyspark’root@gu-virtual-machine:&#x2F;usr&#x2F;local&#x2F;spark&#x2F;mycode&#x2F;remdup# python3 remdup.pyTraceback (most recent call last):File “&#x2F;usr&#x2F;local&#x2F;spark&#x2F;mycode&#x2F;remdup&#x2F;remdup.py”, line 1, in from pyspark import SparkContextModuleNotFoundError: No module named ‘pyspark’ 1.找到.bashrc文件在哪 1/home/hadoop 编辑环境变量 123export PYSPARK_HOME=/usr/local/sparkexport PYTHONPATH=$PYSPARK_HOME/python:$PYTHONPATHexport PYTHONPATH=$PYSPARK_HOME/python/lib/py4j-0.10.9.5-src.zip:$PYTHONPATH 其中&#96;&#96;&#96;py4j-0.10.9.5-src.zip&#96;&#96; 需要在/usr/local/spark/python/lib/中自己找自己的是啥版本 然后 source .bashrc chatgpt 的prompt 怎么将PySpark安装目录添加到PYTHONPATH环境变量中 https://spark.apache.org/docs/latest/api/python/getting_started/install.html","categories":[{"name":"2023","slug":"2023","permalink":"http://example.com/categories/2023/"}],"tags":[{"name":"spark","slug":"spark","permalink":"http://example.com/tags/spark/"}]},{"title":"Spark入门：初级编程实践","slug":"Spark入门：初级编程实践","date":"2023-03-27T13:10:51.026Z","updated":"2023-03-27T16:57:31.129Z","comments":true,"path":"2023/03/27/Spark入门：初级编程实践/","link":"","permalink":"http://example.com/2023/03/27/Spark%E5%85%A5%E9%97%A8%EF%BC%9A%E5%88%9D%E7%BA%A7%E7%BC%96%E7%A8%8B%E5%AE%9E%E8%B7%B5/","excerpt":"","text":"1.pyspark交互式编程 （1） 该系总共有多少学生； 12345lines = sc.textFile(&quot;file:///usr/local/spark/sparksqldata/Data01.txt&quot;) res = lines.map(lambda x:x.split(&quot;,&quot;)).map(lambda x: x[0]) //获取每行数据的第1列 distinct_res = res.distinct() //去重操作 distinct_res.count()//取元素总个数 //265 答案为：265人 （2） 该系共开设了多少门课程； 1234lines = sc.textFile(&quot;file:///usr/local/spark/sparksqldata/Data01.txt&quot;) res = lines.map(lambda x:x.split(&quot;,&quot;)).map(lambda x:x[1]) //获取每行数据的第2列distinct_res = res.distinct()//去重操作 distinct_res.count()//取元素总个数 //8 答案为8门 （3） Tom同学的总成绩平均分是多少； 1234567lines = sc.textFile(&quot;file:///usr/local/spark/sparksqldata/Data01.txt&quot;)res = lines.map(lambda x:x.split(&quot;,&quot;)).filter(lambda x:x[0]==&quot;Tom&quot;) //筛选Tom同学的成绩信息 res.foreach(print) score = res.map(lambda x:int(x[2])) //提取Tom同学的每门成绩，并转换为int类型 num = res.count() //Tom同学选课门数 sum_score = score.reduce(lambda x,y:x+y) //Tom同学的总成绩 avg = sum_score/num // 总成绩/门数=平均分print(avg) //30.8 Tom同学的平均分为30.8分 （4） 求每名同学的选修的课程门数； 1234lines = sc.textFile(&quot;file:///usr/local/spark/sparksqldata/Data01.txt&quot;) res = lines.map(lambda x:x.split(&quot;,&quot;)).map(lambda x:(x[0],1)) //学生每门课程都对应(学生姓名,1)，学生有n门课程则有n个(学生姓名,1) each_res = res.reduceByKey(lambda x,y: x+y) //按学生姓名获取每个学生的选课总数 each_res.foreach(print) 答案共265行 (‘Lewis’, 4) (‘Mike’, 3) (‘Walter’, 4) (‘Conrad’, 2) (‘Borg’, 4) …… （5） 该系DataBase课程共有多少人选修； 123lines = sc.textFile(&quot;file:///usr/local/spark/sparksqldata/Data01.txt&quot;) res = lines.map(lambda x:x.split(&quot;,&quot;)).filter(lambda x:x[1]==&quot;DataBase&quot;) res.count() //126 答案为126人 （6） 各门课程的平均分是多少； 12345lines = sc.textFile(&quot;file:///usr/local/spark/sparksqldata/Data01.txt&quot;) res = lines.map(lambda x:x.split(&quot;,&quot;)).map(lambda x:(x[1],(int(x[2]),1))) //为每门课程的分数后面新增一列1，表示1个学生选择了该课程。格式如(&#x27;ComputerNetwork&#x27;, (44, 1))temp = res.reduceByKey(lambda x,y:(x[0]+y[0],x[1]+y[1])) //按课程名聚合课程总分和选课人数。格式如(&#x27;ComputerNetwork&#x27;, (7370, 142)) avg = temp.map(lambda x:(x[0], round(x[1][0]/x[1][1],2)))//课程总分/选课人数 = 平均分，并利用round(x,2)保留两位小数 avg.foreach(print) 答案为： (‘ComputerNetwork’, 51.9) (‘Software’, 50.91) (‘DataBase’, 50.54) (‘Algorithm’, 48.83) (‘OperatingSystem’, 54.94) (‘Python’, 57.82) (‘DataStructure’, 47.57) (‘CLanguage’, 50.61) （7）使用累加器计算共有多少人选了DataBase这门课。 123456lines = sc.textFile(&quot;file:///usr/local/spark/sparksqldata/Data01.txt&quot;) res = lines.map(lambda x:x.split(&quot;,&quot;)).filter(lambda x:x[1]==&quot;DataBase&quot;)//筛选出选了DataBase课程的数据 accum = sc.accumulator(0) //定义一个从0开始的累加器accum res.foreach(lambda x:accum.add(1))//遍历res，每扫描一条数据，累加器加1 accum.value //输出累加器的最终值 //126 2.编写独立应用程序实现数据去重对于两个输入文件A和B，编写Spark独立应用程序，对两个文件进行合并，并剔除其中重复的内容，得到一个新文件C。下面是输入文件和输出文件的一个样例，供参考。 输入文件A的样例如下： 20170101 x 20170102 y 20170103 x 20170104 y 20170105 z 20170106 z 输入文件B的样例如下： 20170101 y 20170102 y 20170103 x 20170104 z 20170105 y 根据输入的文件A和B合并得到的输出文件C的样例如下： 20170101 x 20170101 y 20170102 y 20170103 x 20170104 y 20170104 z 20170105 y 20170105 z 20170106 z 【参考答案】 实验答案参考步骤如下： 1（1）假设当前目录为/usr/local/spark/mycode/remdup，在当前目录下新建一个remdup.py文件，复制下面代码； 123（2）最后在目录/usr/local/spark/mycode/remdup下执行下面命令执行程序（注意执行程序时请先退出pyspark shell，否则会出现“地址已在使用”的警告）；$ python3 remdup.py（3）在目录/usr/local/spark/mycode/remdup/result下即可得到结果文件part-00000。","categories":[{"name":"2023","slug":"2023","permalink":"http://example.com/categories/2023/"}],"tags":[{"name":"Spark","slug":"Spark","permalink":"http://example.com/tags/Spark/"}]},{"title":"Cookie和Session用户认证","slug":"用户认证-Cookie和Session","date":"2023-03-27T09:44:25.116Z","updated":"2023-03-27T11:29:32.607Z","comments":true,"path":"2023/03/27/用户认证-Cookie和Session/","link":"","permalink":"http://example.com/2023/03/27/%E7%94%A8%E6%88%B7%E8%AE%A4%E8%AF%81-Cookie%E5%92%8CSession/","excerpt":"","text":"什么是cookie和session 12http://127.0.0.1:8000/admin/list/https://127.0.0.1:8000/admin/list/ 无状态&amp;短链接","categories":[{"name":"2023","slug":"2023","permalink":"http://example.com/categories/2023/"}],"tags":[{"name":"django","slug":"django","permalink":"http://example.com/tags/django/"}]},{"title":"操作系统——进程同步——哲学家进餐问题","slug":"操作系统——进程同步——哲学家进餐问题","date":"2023-03-24T00:43:48.827Z","updated":"2023-04-05T16:18:50.106Z","comments":true,"path":"2023/03/24/操作系统——进程同步——哲学家进餐问题/","link":"","permalink":"http://example.com/2023/03/24/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E2%80%94%E2%80%94%E8%BF%9B%E7%A8%8B%E5%90%8C%E6%AD%A5%E2%80%94%E2%80%94%E5%93%B2%E5%AD%A6%E5%AE%B6%E8%BF%9B%E9%A4%90%E9%97%AE%E9%A2%98/","excerpt":"哲学家进餐问题复习一下 pv操作 互斥锁 1234P --wait(信号量S)&#123; S&lt;=0 S-- //上锁&#125; 123V --signal(信号量)&#123; S++ //开锁&#125;","text":"哲学家进餐问题复习一下 pv操作 互斥锁 1234P --wait(信号量S)&#123; S&lt;=0 S-- //上锁&#125; 123V --signal(信号量)&#123; S++ //开锁&#125; 12345678910semaphpore chopstick[5]=&#123;1,1,1,1,1&#125;; // 所有信号量均被初始化为1,第i位哲学家的活动可描述为do&#123; P(chopstick[i]); //取左筷子 当所有哲学家都拿起左筷子 P(chopstick[i+1]%5); //取右筷子 右筷子被阻碍 eat; V(chopstick[i]); //放左筷子 V(chopstick[(i+1)%5]);//放右筷子 think;&#125;while(true) 方法一 至多只允许有4位哲学家同时去拿左边的筷子，仅当一名哲学家左右两边的筷子都可以使用时，才允许他抓筷子。 123456789101112semaphpore chopstick[5]=&#123;1,1,1,1,1&#125;; //筷子semaphpore count=4; //控制最多只允许4名哲学家同时进餐do&#123; P(count); //判断是否超过4个人进餐 P(chopstick[i]); //取左筷子 P(chopstick[i+1]%5); // 取右筷子 eating; V(chopstick[i]); //放左筷子 V(chopstick[i+1]%5); //放右筷子 V(count); //用餐完毕 thinking;&#125;while(True); 123456A count=3B count=2C count=1D count=0E (负数阻塞)保证了四个同时进餐 方法二 对哲学家进行编号， 奇数哲学家，先拿左边筷子，再拿右边筷子 偶数哲学家，先拿右边筷子，再拿左边筷子 123456789101112131415semaphpore chopstick[5]=&#123;1,1,1,1,1&#125;; //筷子do&#123; if(i%2==1)&#123;//奇数 P(chopstick[i]); //取左筷子 P(chopstick[i+1]%5); // 取右筷子 &#125; else&#123; //偶数 P(chopstick[i]); //取左筷子 P(chopstick[i+1]%5); // 取右筷子 &#125; eating; V(chopstick[i]); //放左筷子 V(chopstick[i+1]%5); //放右筷子 thinking;&#125;while(True) 作业第1关：03哲学家进餐同步控制问题 任务要求 评论 关卡排行榜 任务描述 相关知识 哲学家进餐问题 哲学家问题死锁模拟 程序编程说明 测试说明 任务描述本关任务：编写程序实现哲学家进餐同步控制。 相关知识为了完成本关任务，你需要掌握： 1.多个哲学家进餐同步模型与死锁的产生。 2.同步控制避免哲学家进餐产生死锁。 3.sem_timedwait函数的使用。 哲学家进餐问题哲学家进餐问题是计算机操作系统中一个典型的同步问题，有五个哲学家在同一张圆桌，它们间隔放置了五只筷子，每个哲学家只有拿到两只筷子才可进餐，进餐完就进行思考。在该问题中筷子是一种临界资源，会被两个哲学家进行争用，在并发条件下，如果不进行适当控制，则线程发生死锁，可能产生所有哲学家无法进餐的情况。这样产生的死锁状态对计算机系统是不利的。 该线程运行模型如图： 哲学家问题死锁模拟原始的哲学家线程是无限等待的，这不利于在线测评(限定程序的运行时长)，因此本实训限定五个哲学家线程持续固定长的时间(无论成功或失败)即退出运行。 在本项目中有两种情况：一是不进行同步控制的哲学家线程，每个哲学家线程如果不进行控制，则所有哲学家线程都无法进行，这就是发生了死锁。二是对哲学家线程执行同步控制，每个哲学家线程不能取比自己编号大的信号量，经过控制的哲学家线程则不会发生死锁。 为了区分两种模式的运行效果不同，哲学家线程运行时还有一个统计线程Reporter，用于统计已经成功执行的线程数目。该实训项目说明访问临界资源进行限制后各线程可以执行完毕。 两种情况要有相同的开局，哲学家线程获得信号量后都持有信号量资源一段时间(200MS)，第一种情况是不控制线程直接再申请新资源，在1.5秒后进行完成情况统计。第二种情况是奇数编号的线程首先判断下一个编号资源是否可用，如果不可用，则马上释放已有资源。等100*编号(100MS或300MS)后再申请资源，经过控制的哲学家线程全部可以执行完成。 程序编程说明本项目采用C语言进行编写，采用的是linux平台的gcc编译器，主线程先执行未受控制的哲学家线程，并输出完成统计。再执行受控制的哲学家线程，也输出完成统计。 两种情况中，主线程初始化信号量资源，启动五个哲学家线程，主线程ReporterPhi函数第一次启动五个哲学家线程(Philosopher)，这五个哲学家线程在获得一个筷子后，都保持一段时间。然后试图再去获得新的筷子，发生死锁，造成所有线程都无法完成任务。五个线程结束后，统计成功的数目。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203![交错获取筷子](/images/操作系统/9.png) 执行完毕的哲学家进程马上归还筷子资源， ![归还资源的哲学家线程](/images/操作系统/10.png) 这样就使线程间可以依次执行完毕。主线程最后统计成功的数目。如果哲学家线程发生了死锁，则统计数会是0。经过同步控制的哲学家线程具有相互协调资源的能力，而不发生死锁，统计数会是5。这里对信号量的操作使用的是```sem_timedwait```函数，它在一个规定的时间尝试获取信号量，如果信号量值是可用的(大于0)，则该函数马上返回0值，如果信号量值是不可用的(不大于0)，则该方法会等待指定的时长，在阻塞指定时长后返回值是-1。```sem_timedwait```函数使用的是绝时间值。```sem_getvalue(&amp;sem, &amp;semvalue)```;该方法直接查看信号量的值。```sem_post(&amp;sem)```方法增加信号量的值，相当于归还资源;```gettimeofday```方法获得机器当前时间绝对值。```time_add_ms```对指定时间变量增加给定的时长。本实训核心内容是要求学生理解哲学家线程死锁的发生，以及如何避免发生死锁，要求学生对并发线程有较深刻的理解，了解linux平台线程的运用和信号量的使用。#### 测试说明项目没有输入数据，输出数据是两种情况下线程成功运行的数目。 测试输入：无 预期输出：1,1(非真正结果)------开始你的任务吧，祝你成功！```c++//stu001.c 哲学家进餐问题，程序模板，由学生完成缺失代码 #include &lt;stdio.h&gt;#include &lt;stdlib.h&gt; #include &lt;pthread.h&gt;#include &lt;semaphore.h&gt; static sem_t sem_chops[5];//筷子信号量 static sem_t sem_stop;//该信号量用于等待。//时间递增方法 void time_add_ms(struct timeval *time, uint ms)&#123; time-&gt;tv_usec += ms * 1000; // 微秒 = 毫秒 * 1000 if(time-&gt;tv_usec &gt;= 1000000) // 进位，1000 000 微秒 = 1 秒 &#123; time-&gt;tv_sec += time-&gt;tv_usec / 1000000; time-&gt;tv_usec %= 1000000; &#125;&#125;//100毫秒#define TIMEOUT_FIRST 100//200毫秒#define TIMEOUT_HOLD 200//200毫秒#define TIMEOUT_PHIEND 200//200毫秒 #define TIME_REPORT 200struct timeval begintime; //获取的机器初始开始时间值struct timespec first_time; //首次获取筷子信号量struct timespec phi_holdtime; //保持一段时间struct timespec report_time; //汇报线程完成情况时间struct timespec phi_endtime; //哲学家线程结束绝对时间值static int finish[5]; //哲学家线程没有进行有效同步控制void* Philosopher(void *arg)&#123; int iIndex=*((int*)arg); int iRetWait1=-1,iRetWait2=-1; //iRetWait1是获取筷子资源1的结果，成功返回0，失败返回-1 //iRetWait2是获取筷子资源2的结果，成功返回0，失败返回-1 //获取第一个筷子成功后还要保持一段时间，继续请求下一个新筷子 //begin ******哲学家线程获取筷子资源进餐 //筷子信号量 //首次获取筷子信号量 iRetWait1=sem_timedwait(sem_chops+iIndex,&amp;first_time);//获取筷子时间结束 //该信号量用于等待 //保持一段时间 sem_timedwait(&amp;sem_stop,&amp;phi_holdtime); //筷子信号量 //首次获取筷子信号量 iRetWait2=sem_timedwait(sem_chops+(iIndex+1)%5,&amp;first_time); //获取筷子时间结束 //end if((iRetWait1==0)&amp;&amp;(iRetWait2==0))&#123; //检查获得两个筷子资源结果，都成功则为就餐成功 //设置任务完成标志为1，线程结束 finish[iIndex]=1; //释放筷子资源iIndex sem_post(&amp;sem_chops[iIndex]); //释放筷子资源 sem_post(&amp;sem_chops[(iIndex+1)%5]); &#125; //线程结束时间点：约为700MS return;&#125;//哲学家线程进行有效同步控制void* PhilosopherGood(void *arg)&#123; int iIndex=*((int*)arg); int iRetWait1=-1,iRetWait2=-1; int i=0; /*begin ******哲学家线程获取筷子资源进餐-受同步控制********************* //根据线程编号选择筷子编号并尝试获取第一个筷子,未成功获取则等待一段时间后重试 //成功后继续请求下一个新筷子 ****end*****************************************/ for(i=0;(i&lt;5)&amp;&amp;(iRetWait1!=0);i++)&#123; //获取第一根筷子 if(iIndex%2==1)&#123; iRetWait1=sem_timedwait(sem_chops+iIndex,&amp;first_time); &#125; iRetWait2=sem_timedwait(sem_chops+(iIndex+1)%5,&amp;first_time); //设置任务完成标志为1，线程结束 finish[iIndex]=1; //释放筷子资源iIndex sem_post(&amp;sem_chops[iIndex]); //释放筷子资源 sem_post(&amp;sem_chops[(iIndex+1)%5]); &#125; //线程结束时间点：约为700MS return;&#125; //该线程用于检测哲学家未经同步控制完成任务的数量int ReporterPhi(void*(*phiFunc)(void*))&#123; int iFinishCount=0; pthread_t pids[5]; int arg[5]; int iRetWait1=-1,iRetWait2=-1,retVal=-1; int i=0; gettimeofday(&amp;begintime, NULL); //第一次获取筷子资源时间点:100MS time_add_ms(&amp;begintime, TIMEOUT_FIRST); first_time.tv_sec = begintime.tv_sec; first_time.tv_nsec = begintime.tv_usec * 1000; //保持获取筷子资源到时间点:300MS time_add_ms(&amp;begintime, TIMEOUT_HOLD); phi_holdtime.tv_sec = begintime.tv_sec; phi_holdtime.tv_nsec = begintime.tv_usec * 1000; //哲学家线程结束时间点:500毫秒 time_add_ms(&amp;begintime, TIMEOUT_PHIEND); phi_endtime.tv_sec= begintime.tv_sec; phi_endtime.tv_nsec= begintime.tv_usec * 1000; //汇报线程完成情况时间点：700MS time_add_ms(&amp;begintime, TIME_REPORT); report_time.tv_sec = begintime.tv_sec; report_time.tv_nsec = begintime.tv_usec * 1000; sem_init(&amp;sem_stop,0,0);//该信号量初值为0 //初始化完成数组为0，筷子信号量值为1 for(i=0;i&lt;5;i++) &#123; finish[i]=0; //设置信量初值为1 sem_init(sem_chops+i,0,1); &#125; for(i=0;i&lt;5;i++) &#123; arg[i]=i;//传给线程的参数值，用来区分线程实体 //创建消费者线程,pids+i是线程ID的保存地址，arg+i是线程的参数指针 pthread_create(pids+i,NULL,phiFunc,(void *)(&amp;arg[i])); &#125; //等待哲学家线程结束,但都没有完成任务。 for(i=0;i&lt;5;i++) &#123; pthread_join(pids[i],NULL); //主线程等待生产者线程结束 &#125; //等待到报告时间点：700MS retVal = sem_timedwait(&amp;sem_stop, &amp;report_time); iFinishCount=0; for(i=0;i&lt;5;i++) &#123; if(finish[i]==1) &#123;iFinishCount++;&#125; &#125; return iFinishCount;&#125;int main(int argc,char * argv[])&#123; int i=0; int phi1=-1,phi2=-1; //调用无同步控制的哲学家线程 phi1=ReporterPhi(Philosopher); //调用有同步控制的哲学家线程 phi2=ReporterPhi(PhilosopherGood); //输出两种情况下完成任务的线程数 printf(&quot;%d,%d&quot;,phi1,phi2); //销毁信号量资源 for(i=0;i&lt;5;i++) &#123; sem_destroy(sem_chops+i); &#125; sem_destroy(&amp;sem_stop); return 0;&#125;","categories":[{"name":"2023","slug":"2023","permalink":"http://example.com/categories/2023/"}],"tags":[{"name":"操作系统","slug":"操作系统","permalink":"http://example.com/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"}]},{"title":"3-23-2023","slug":"3-23-2023","date":"2023-03-23T08:42:33.569Z","updated":"2023-03-23T08:59:22.581Z","comments":true,"path":"2023/03/23/3-23-2023/","link":"","permalink":"http://example.com/2023/03/23/3-23-2023/","excerpt":"放平心态不焦虑","text":"放平心态不焦虑 加油咯 1.接下来目标，确定中介，交钱，保底。 2.加油把手上的东西学完（这周把它干掉交比赛） 3.刷数据结构算法&&慢慢看数学慢慢刷题(方平心态) 4.美团笔试准备摆烂","categories":[{"name":"2023","slug":"2023","permalink":"http://example.com/categories/2023/"}],"tags":[{"name":"casual_talk","slug":"casual-talk","permalink":"http://example.com/tags/casual-talk/"}]},{"title":"设计模式--外观模式","slug":"外观模式","date":"2023-03-22T09:24:51.046Z","updated":"2023-03-23T08:59:49.480Z","comments":true,"path":"2023/03/22/外观模式/","link":"","permalink":"http://example.com/2023/03/22/%E5%A4%96%E8%A7%82%E6%A8%A1%E5%BC%8F/","excerpt":"外观模式","text":"外观模式 模式动机为子系统中的一组接口提供一个一致的界面，外观模式定义了一个高层接口，这个接口使得这一子系统更加容易使用。 外观模式是为了解决类与类之间的依赖关系的，像spring一样，可以将类和类之间的关系配置到配置文件中，而外观模式就是将其关系放在一个Facade类中，降低了类类之间的耦合度，该模式中没有涉及到接口。 模式定义外观模式(Facade Pattern)：外部与一个子系统的通信必须通过一个统一的外观对象进行，为子系统中的一组接口提供一个一致的界面，外观模式定义了一个高层接口，这个接口使得这一子系统更加容易使用。外观模式又称为门面模式，它是一种对象结构型模式。 该模式对外有一个统一接口，外部应用程序不用关心内部子系统的具体的细节，这样会大大降低应用程序的复杂度，提高了程序的可维护性。 外观（Facade）模式是“迪米特法则”的典型应用 模式结构 Facade: 外观角色。为多个子系统对外提供一个共同的接口。 SubSystem:子系统角色。实现系统的部分功能，客户可以通过外观角色访问它。 Client：客户 角色 时序图 外观模式抽象代码 外观模式分析 根据“单一职责原则”，在软件中将一个系统划分为若干个子系统有利于降低整个系统的复杂性，一个常见的设计目标是使子系统间的通信和相互依赖关系达到最小，而达到该目标的途径之一就是引入一个外观对象，它为子系统的访问提供了一个简单而单一的入口。 外观模式也是“迪米特法则”的体现，通过引入一个新的外观类可以降低原有系统的复杂度，同时降低客户类与子系统类的耦合度。 外观模式要求一个子系统的外部与其内部的通信通过一个统一的外观对象进行，外观类将客户端与子系统的内部复杂性分隔开，使得客户端只需要与外观对象打交道，而不需要与子系统内部的很多对象打交道。 外观模式的目的在于降低系统的复杂程度。 外观模式从很大程度上提高了客户端使用的便捷性，使得客户端无须关心子系统的工作细节，通过外观角色即可调用相关功能。 外观模式实例比如电脑是由CPU、内存、磁盘等部件组成，当启动电脑的时候，需要依次启动CPU、内存和磁盘等部件。CPU、Memory、Disk他们之间将会相互持有实例，产生关系，这样会造成严重的依赖，修改一个类，可能会带来其他类的修改。对于用户而言，其只需要知道可以把电脑打开即可。可以适用外观模式来设计该实例。类图如下图所示。 代码文件，CPU.java Memory.java Disk.java Computer.java（外观类） Client.java 引入外观角色之后，用户只需要直接与外观角色交互，用户与子系统之间的复杂关系由外观角色来实现，从而降低了系统的耦合度。 外观模式优点 对客户屏蔽子系统组件，减少了客户处理的对象数目并使得子系统使用起来更加容易。通过引入外观模式，客户代码将变得很简单，与之关联的对象也很少。 实现了子系统与客户之间的松耦合关系，这使得子系统的组件变化不会影响到调用它的客户类，只需要调整外观类即可。 降低了大型软件系统中的编译依赖性，并简化了系统在不同平台之间的移植过程，因为编译一个子系统一般不需要编译所有其他的子系统。一个子系统的修改对其他子系统没有任何影响，而且子系统内部变化也不会影响到外观对象。 只是提供了一个访问子系统的统一入口，并不影响用户直接使用子系统类。 外观模式缺点 不能很好地限制客户使用子系统类，如果对客户访问子系统类做太多的限制则减少了可变性和灵活性。 在不引入抽象外观类的情况下，增加新的子系统可能需要修改外观类或客户端的源代码，违背了“开闭原则”。 外观模式适用环境 当要为一个复杂子系统提供一个简单接口时可以使用外观模式。该接口可以满足大多数用户的需求，而且用户也可以越过外观类直接访问子系统。 客户程序与多个子系统之间存在很大的依赖性。引入外观类将子系统与客户以及其他子系统解耦，可以提高子系统的独立性和可移植性。 在层次化结构中，可以使用外观模式定义系统中每一层的入口，层与层之间不直接产生联系，而通过外观类建立联系，降低层之间的耦合度。 外观模式应用在Java核心库中，下面的类使用了外观模式。 javax.faces.context.FacesContext。该类使用了LifeCycle、ViewHandler、NavigationHandler等类。但用户直接使用FacesContext，并不觉得使用了后面的三个类。 javax.faces.context.ExternalContext 。该类使用了ServletContext，HttpSession，HttpServletRequest，HttpServletResponse等类。 JDBCFacade 识别方法： 如果一个类提供了一个简单的接口，但是其工作实际由其它类来完成，则可以认为是个外观类。通常外观类管理其使用对象的整个生命周期。 外观模式扩展 在外观模式中，通常只需要一个外观类，并且此外观类只有一个实例，换言之它是一个单例类。在很多情况下为了节约系统资源，一般将外观类设计为单例类。当然这并不意味着在整个系统里只能有一个外观类，在一个系统中可以设计多个外观类，每个外观类都负责和一些特定的子系统交互，向用户提供相应的业务功能。 不要通过继承一个外观类在子系统中加入新的行为，这种做法是错误的。外观模式的用意是为子系统提供一个集中化和简化的沟通渠道，而不是向子系统加入新的行为，新的行为的增加应该通过修改原有子系统类或增加新的子系统类来实现，不能通过外观类来实现。 外观模式最大的缺点在于违背了“开闭原则”，当增加新的子系统或者移除子系统时需要修改外观类，可以通过引入抽象外观类在一定程度上解决该问题，客户端针对抽象外观类进行编程。对于新的业务需求，不修改原有外观类，而对应增加一个新的具体外观类，由新的具体外观类来关联新的子系统对象，同时通过修改配置文件来达到不修改源代码并更换外观类的目的。 外观模式总结 在外观模式中，外部与一个子系统的通信必须通过一个统一的外观对象进行，为子系统中的一组接口提供一个一致的界面，外观模式定义了一个高层接口，这个接口使得这一子系统更加容易使用。外观模式又称为门面模式，它是一种对象结构型模式。 外观模式包含两个角色：外观角色是在客户端直接调用的角色，在外观角色中可以知道相关的(一个或者多个)子系统的功能和责任，它将所有从客户端发来的请求委派到相应的子系统去，传递给相应的子系统对象处理；在软件系统中可以同时有一个或者多个子系统角色，每一个子系统可以不是一个单独的类，而是一个类的集合，它实现子系统的功能。 外观模式要求一个子系统的外部与其内部的通信通过一个统一的外观对象进行，外观类将客户端与子系统的内部复杂性分隔开，使得客户端只需要与外观对象打交道，而不需要与子系统内部的很多对象打交道。 外观模式主要优点在于对客户屏蔽子系统组件，减少了客户处理的对象数目并使得子系统使用起来更加容易，它实现了子系统与客户之间的松耦合关系，并降低了大型软件系统中的编译依赖性，简化了系统在不同平台之间的移植过程；其缺点在于不能很好地限制客户使用子系统类，而且在不引入抽象外观类的情况下，增加新的子系统可能需要修改外观类或客户端的源代码，违背了“开闭原则”。 外观模式适用情况包括：要为一个复杂子系统提供一个简单接口；客户程序与多个子系统之间存在很大的依赖性；在层次化结构中，需要定义系统中每一层的入口，使得层与层之间不直接产生联系。","categories":[{"name":"2023","slug":"2023","permalink":"http://example.com/categories/2023/"}],"tags":[{"name":"设计模式","slug":"设计模式","permalink":"http://example.com/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"}]},{"title":"django_搜索校验分页","slug":"django_搜索校验分页","date":"2023-03-21T14:12:05.357Z","updated":"2023-03-22T14:06:08.804Z","comments":true,"path":"2023/03/21/django_搜索校验分页/","link":"","permalink":"http://example.com/2023/03/21/django_%E6%90%9C%E7%B4%A2%E6%A0%A1%E9%AA%8C%E5%88%86%E9%A1%B5/","excerpt":"","text":"搜索12##搜索PrettyNum.objects.filter&#123;mobile=&#x27;13906135233&#x27;,&quot;id&quot;:123&#125; 1234data_dict=&#123;&quot;mobile&quot;:&quot;13906135233&quot;,&quot;id&quot;:123&#125;PrettyNum.objects.filter(**data_dict) 1234567PrettyNum.objects.filter(id=12) 等于12PrettyNum.objects.filter(id__gt=12) 大于12PrettyNum.objects.filter(id__gte=12) 大于等于12PrettyNum.objects.filter(id__lt=12) 小于12PrettyNum.objects.filter(id__lte=12) 小于等于12data_dict=&#123;&quot;id__lte&quot;:12&#125; 123PrettyNum.objects.filter(mobile=&#x27;233&#x27;) 等于 PrettyNum.objects.filter(mobile__startswitch=&quot;139&quot;) 筛选出以139开头PrettyNum.objects.filter(mobile__endswitch=&quot;233&quot;) 筛选出以233结尾PrettyNum.objects.filter(mobile__contains=&quot;5233&quot;) 筛选出包含5233 123# usedata_dict=&#123;&quot;mobile__contains&quot;:&quot;233&quot;&#125;PrettyNum.objects.filter(**data_dict) 校验1234567from django.core.exceptions import ValidationError# 验证方法一mobile=forms.CharField( label=&quot;手机号&quot;, disabled=True, validators=[RegexValidator(r&#x27;^1[3-9]\\d&#123;9&#125;$&#x27;,&#x27;手机号格式错误&#x27;)], ) 12345678910111213from django.core.validators import RegexValidator# 验证方法二 def clean_mobile(self): txt_mobile=self.cleaned_data[&quot;mobile&quot;] exists=PrettyNum.objects.filter(mobile=txt_mobile).exists() if len(txt_mobile)!=11: #验证不通过 raise ValidationError(&quot;格式错误&quot;) if exists: #验证不通过 raise ValidationError(&quot;手机号已存在&quot;) return txt_mobile 123456789101112131415161718192021222324252627282930class PrettyForm(forms.ModelForm): # 验证方法一 # mobile=forms.CharField( # label=&quot;手机号&quot;, # validators=[RegexValidator(r&#x27;^1[3-9]\\d&#123;9&#125;$&#x27;,&#x27;手机号格式错误&#x27;)] # ) class Meta: model=PrettyNum fields=[&#x27;mobile&#x27;,&#x27;price&#x27;,&#x27;level&#x27;,&#x27;status&#x27;] # fields=&quot;__all__&quot; # exclude=[&#x27;level&#x27;] widgets=&#123; &quot;mobile&quot;:forms.TextInput(attrs=&#123;&quot;class&quot;:&quot;form-control&quot;&#125;), &quot;price&quot;:forms.TextInput(attrs=&#123;&quot;class&quot;:&quot;form-control&quot;&#125;), &quot;level&quot;:forms.TextInput(attrs=&#123;&quot;class&quot;:&quot;form-control&quot;&#125;), &quot;status&quot;:forms.TextInput(attrs=&#123;&quot;class&quot;:&quot;form-control&quot;&#125;), &#125;# 验证方法二 def clean_mobile(self): txt_mobile=self.cleaned_data[&quot;mobile&quot;] exists=PrettyNum.objects.filter(mobile=txt_mobile).exists() if len(txt_mobile)!=11: #验证不通过 raise ValidationError(&quot;格式错误&quot;) if exists: #验证不通过 raise ValidationError(&quot;手机号已存在&quot;) return txt_mobile 1234data_dict=&#123;&#125;value=request.GET.get(&#x27;q&#x27;,&#x27;&#x27;)if value: data_dict[&quot;mobile__contains&quot;] = value qurylist=PrettyNum.objects.filter(**data_dict).order_by(&quot;-level&quot;) 分页1qurylist=PrettyNum.objects.all()#所有的 1qurylist=PrettyNum.objects.filter(id=4)[0:10]#id为4的前十页 1qurylist=PrettyNum.objects.all()[0:10]#第一页 1qurylist=PrettyNum.objects.all()[10:20]#第二页 1qurylist=PrettyNum.objects.all()[20:30]#第三页 12345page=int(request.GET.get(&#x27;page&#x27;,1))start=(page-1)*10end=page*10qurylist=PrettyNum.objects.filter(**data_dict).order_by(&quot;-level&quot;)[start:end]return render(request,&#x27;pretty_list.html&#x27;,&#123;&#x27;qurylist&#x27;:qurylist,&quot;search_data&quot;:value&#125;) 12345678910111213141516171819&lt;nav aria-label=&quot;Page navigation&quot;&gt; &lt;ul class=&quot;pagination&quot;&gt; &lt;li&gt; &lt;a href=&quot;#&quot; aria-label=&quot;Previous&quot;&gt; &lt;span aria-hidden=&quot;true&quot;&gt;«&lt;/span&gt; &lt;/a&gt; &lt;/li&gt; &lt;li&gt;&lt;a href=&quot;/pretty/list/?page=1&quot;&gt;1&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=&quot;?page=2&quot;&gt;2&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=&quot;?page=3&quot;&gt;3&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=&quot;?page=4&quot;&gt;4&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=&quot;?page=5&quot;&gt;5&lt;/a&gt;&lt;/li&gt; &lt;li&gt; &lt;a href=&quot;#&quot; aria-label=&quot;Next&quot;&gt; &lt;span aria-hidden=&quot;true&quot;&gt;»&lt;/span&gt; &lt;/a&gt; &lt;/li&gt; &lt;/ul&gt;&lt;/nav&gt; 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869#分页 # qurylist=PrettyNum.objects.all() # qurylist=PrettyNum.objects.filter(id=4)[0:10] # qurylist=PrettyNum.objects.all()[0:10] # qurylist=PrettyNum.objects.all()[10:20] # qurylist=PrettyNum.objects.all()[20:30] page=int(request.GET.get(&#x27;page&#x27;,1)) pageSize=10 start=(page-1)*pageSize end=page*pageSize qurylist=PrettyNum.objects.filter(**data_dict).order_by(&quot;-level&quot;)[start:end] #总数据条数 total_count=PrettyNum.objects.filter(**data_dict).order_by(&quot;-level&quot;).count() #总页码 total_page_count,div=divmod(total_count,pageSize) if div: total_page_count+=1 # 计算出，显示当前页的前5页、后5页 plus=5 if total_page_count&lt;=2*plus+1: #数据库中的数据比较少，都没有达到11页 start_page=1 end_page=total_page_count else: #数据库中的数据比较多 &gt;11页 #当前页&lt;5时(极小值) if page&lt;=plus: start_page=1 end_page=2*plus+1 else: #当前页&gt;5 #当前页+5&gt;总页面 if (page+plus)&gt;total_page_count: start_page=total_page_count-2*plus end_page=total_page_count else: start_page=page-plus end_page=page+plus #页码 page_str_list=[] #首页 page_str_list.append(&#x27;&lt;li&gt;&lt;a href=&quot;?page=&#123;&#125;&quot;&gt;首页&lt;/a&gt;&lt;/li&gt;&#x27;.format(1)) #上一页 if page&gt;1: prev=&#x27;&lt;li&gt;&lt;a href=&quot;?page=&#123;&#125;&quot;&gt;上一页&lt;/a&gt;&lt;/li&gt;&#x27;.format(page-1) else: prev=&#x27;&lt;li&gt;&lt;a href=&quot;?page=&#123;&#125;&quot;&gt;上一页&lt;/a&gt;&lt;/li&gt;&#x27;.format(1) page_str_list.append(prev) for i in range(start_page,end_page+1): if i==page: ele=&#x27;&lt;li class=&quot;active&quot;&gt;&lt;a href=&quot;?page=&#123;&#125;&quot;&gt;&#123;&#125;&lt;/a&gt;&lt;/li&gt;&#x27;.format(i,i) else: ele=&#x27;&lt;li&gt;&lt;a href=&quot;?page=&#123;&#125;&quot;&gt;&#123;&#125;&lt;/a&gt;&lt;/li&gt;&#x27;.format(i,i) page_str_list.append(ele) #下一页 if page&lt;total_page_count: prev=&#x27;&lt;li&gt;&lt;a href=&quot;?page=&#123;&#125;&quot;&gt;下一页&lt;/a&gt;&lt;/li&gt;&#x27;.format(page+1) else: prev=&#x27;&lt;li&gt;&lt;a href=&quot;?page=&#123;&#125;&quot;&gt;下一页&lt;/a&gt;&lt;/li&gt;&#x27;.format(total_page_count) page_str_list.append(prev) #尾页 page_str_list.append(&#x27;&lt;li&gt;&lt;a href=&quot;?page=&#123;&#125;&quot;&gt;尾页&lt;/a&gt;&lt;/li&gt;&#x27;.format(total_page_count)) page_string =mark_safe(&quot;&quot;.join(page_str_list)) return render(request,&#x27;pretty_list.html&#x27;,&#123;&#x27;qurylist&#x27;:qurylist,&quot;search_data&quot;:value,&quot;page_string&quot;:page_string&#125;) 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115def pretty_list(request):##搜索# --------------------# 1.PrettyNum.objects.filter&#123;mobile=&#x27;13906135233&#x27;,&quot;id&quot;:123&#125;# 2.data_dict=&#123;&quot;mobile&quot;:&quot;13906135233&quot;,&quot;id&quot;:123&#125;# PrettyNum.objects.filter(**data_dict)# --------------------------------# PrettyNum.objects.filter(id=12) 等于12# PrettyNum.objects.filter(id__gt=12) 大于12# PrettyNum.objects.filter(id__gte=12) 大于等于12# PrettyNum.objects.filter(id__lt=12) 小于12# PrettyNum.objects.filter(id__lte=12) 小于等于12# data_dict=&#123;&quot;id__lte&quot;:12&#125;# # -----------------------------------# PrettyNum.objects.filter(mobile=&#x27;233&#x27;) 等于# PrettyNum.objects.filter(mobile__startswitch=&quot;139&quot;) 筛选出以139开头# PrettyNum.objects.filter(mobile__endswitch=&quot;233&quot;) 筛选出以233结尾# PrettyNum.objects.filter(mobile__contains=&quot;5233&quot;) 筛选出包含5233# use# data_dict=&#123;&quot;mobile__contains&quot;:&quot;233&quot;&#125;# PrettyNum.objects.filter(**data_dict)# ----------------------------------------# test # for i in range(300): # PrettyNum.objects.create(mobile=&quot;13906135899&quot;,price=10,level=1,status=1) data_dict=&#123;&#125; value=request.GET.get(&#x27;q&#x27;,&#x27;&#x27;) if value: data_dict[&quot;mobile__contains&quot;] = value # res=PrettyNum.objects.filter(**data_dict) # print(res) # if request.method==&#x27;GET&#x27;: # ****qurylist=PrettyNum.objects.filter(**data_dict).order_by(&quot;-level&quot;)[start:end] #select * from 表 order by level desc # qurylist=PrettyNum.objects.all().order_by(&quot;-level&quot;)#分页 # qurylist=PrettyNum.objects.all() # qurylist=PrettyNum.objects.filter(id=4)[0:10] # qurylist=PrettyNum.objects.all()[0:10] # qurylist=PrettyNum.objects.all()[10:20] # qurylist=PrettyNum.objects.all()[20:30] page=int(request.GET.get(&#x27;page&#x27;,1)) pageSize=10 start=(page-1)*pageSize end=page*pageSize qurylist=PrettyNum.objects.filter(**data_dict).order_by(&quot;-level&quot;)[start:end] #总数据条数 total_count=PrettyNum.objects.filter(**data_dict).order_by(&quot;-level&quot;).count() #总页码 total_page_count,div=divmod(total_count,pageSize) if div: total_page_count+=1 # 计算出，显示当前页的前5页、后5页 plus=5 if total_page_count&lt;=2*plus+1: #数据库中的数据比较少，都没有达到11页 start_page=1 end_page=total_page_count else: #数据库中的数据比较多 &gt;11页 #当前页&lt;5时(极小值) if page&lt;=plus: start_page=1 end_page=2*plus+1 else: #当前页&gt;5 #当前页+5&gt;总页面 if (page+plus)&gt;total_page_count: start_page=total_page_count-2*plus end_page=total_page_count else: start_page=page-plus end_page=page+plus #页码 page_str_list=[] #首页 page_str_list.append(&#x27;&lt;li&gt;&lt;a href=&quot;?page=&#123;&#125;&quot;&gt;首页&lt;/a&gt;&lt;/li&gt;&#x27;.format(1)) #上一页 if page&gt;1: prev=&#x27;&lt;li&gt;&lt;a href=&quot;?page=&#123;&#125;&quot;&gt;上一页&lt;/a&gt;&lt;/li&gt;&#x27;.format(page-1) else: prev=&#x27;&lt;li&gt;&lt;a href=&quot;?page=&#123;&#125;&quot;&gt;上一页&lt;/a&gt;&lt;/li&gt;&#x27;.format(1) page_str_list.append(prev) for i in range(start_page,end_page+1): if i==page: ele=&#x27;&lt;li class=&quot;active&quot;&gt;&lt;a href=&quot;?page=&#123;&#125;&quot;&gt;&#123;&#125;&lt;/a&gt;&lt;/li&gt;&#x27;.format(i,i) else: ele=&#x27;&lt;li&gt;&lt;a href=&quot;?page=&#123;&#125;&quot;&gt;&#123;&#125;&lt;/a&gt;&lt;/li&gt;&#x27;.format(i,i) page_str_list.append(ele) #下一页 if page&lt;total_page_count: prev=&#x27;&lt;li&gt;&lt;a href=&quot;?page=&#123;&#125;&quot;&gt;下一页&lt;/a&gt;&lt;/li&gt;&#x27;.format(page+1) else: prev=&#x27;&lt;li&gt;&lt;a href=&quot;?page=&#123;&#125;&quot;&gt;下一页&lt;/a&gt;&lt;/li&gt;&#x27;.format(total_page_count) page_str_list.append(prev) #尾页 page_str_list.append(&#x27;&lt;li&gt;&lt;a href=&quot;?page=&#123;&#125;&quot;&gt;尾页&lt;/a&gt;&lt;/li&gt;&#x27;.format(total_page_count)) search_string=&quot;&quot;&quot;&quot; &lt;form class=&quot;navbar-form navbar-left&quot; method=&quot;GET&quot;&gt; &lt;div class=&quot;form-group&quot;&gt; &lt;input type=&quot;text&quot; class=&quot;form-control&quot; placeholder=&quot;Search&quot; name=&quot;page&quot;&gt; &lt;/div&gt; &lt;button type=&quot;submit&quot; class=&quot;btn btn-default&quot;&gt;Submit&lt;/button&gt; &lt;/form&gt; &quot;&quot;&quot; page_str_list.append(search_string) page_string =mark_safe(&quot;&quot;.join(page_str_list)) return render(request,&#x27;pretty_list.html&#x27;,&#123;&#x27;qurylist&#x27;:qurylist,&quot;search_data&quot;:value,&quot;page_string&quot;:page_string&#125;) 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677&#123;% extends &#x27;layout.html&#x27; %&#125;&#123;% block content %&#125;&lt;div style=&quot;float: right;&quot;&gt; &lt;form class=&quot;navbar-form navbar-left&quot; method=&quot;GET&quot;&gt; &lt;div class=&quot;form-group&quot;&gt; &lt;input type=&quot;text&quot; class=&quot;form-control&quot; placeholder=&quot;Search&quot; name=&quot;q&quot; value=&quot;&#123;&#123;search_data&#125;&#125;&quot;&gt; &lt;/div&gt; &lt;button type=&quot;submit&quot; class=&quot;btn btn-default&quot;&gt;Search&lt;/button&gt;&lt;/form&gt;&lt;/div&gt;&lt;div&gt; &lt;a href=&quot;/pretty/add/&quot; &gt;&lt;button type=&quot;button&quot; class=&quot;btn btn-success dropdown-toggle&quot; data-toggle=&quot;dropdown&quot; aria-haspopup=&quot;true&quot; aria-expanded=&quot;false&quot;&gt;新建&lt;/button&gt;&lt;/a&gt; &lt;!-- &lt;a href=&quot;/usr/addform&quot;&gt;&lt;button type=&quot;button&quot; class=&quot;btn btn-success dropdown-toggle&quot; data-toggle=&quot;dropdown&quot; aria-haspopup=&quot;true&quot; aria-expanded=&quot;false&quot;&gt;用form新建&lt;/button&gt;&lt;/a&gt; --&gt;&lt;/div&gt;&lt;div class=&quot;panel panel-default &quot;&gt; &lt;/div&gt;&lt;div class=&quot;bs-example&quot; data-example-id=&quot;table-within-panel&quot;&gt; &lt;div class=&quot;panel panel-default&quot;&gt; &lt;!-- Default panel contents --&gt; &lt;div class=&quot;panel-heading&quot;&gt;靓号列表&lt;/div&gt; &lt;!-- &lt;div class=&quot;panel-body&quot;&gt; &lt;/div&gt; --&gt; &lt;!-- Table --&gt; &lt;table class=&quot;table&quot;&gt; &lt;thead&gt; &lt;tr&gt; &lt;th&gt;id&lt;/th&gt; &lt;th&gt;手机号&lt;/th&gt; &lt;th&gt;价格&lt;/th&gt; &lt;th&gt;级别&lt;/th&gt; &lt;th&gt;状态&lt;/th&gt; &lt;/tr&gt; &lt;/thead&gt; &lt;tbody&gt; &#123;% for mp in qurylist %&#125; &lt;tr&gt; &lt;th scope=&quot;row&quot;&gt;&#123;&#123;mp.id&#125;&#125;&lt;/th&gt; &lt;td&gt;&#123;&#123;mp.mobile&#125;&#125;&lt;/td&gt; &lt;td&gt;&#123;&#123;mp.price&#125;&#125;&lt;/td&gt; &lt;!-- &lt;td&gt;&#123;&#123;mp.create_time&#125;&#125;&lt;/td&gt; --&gt; &lt;!-- &lt;td&gt;&#123;&#123;mp.create_time|date:&quot;Y-m-d H:i:s&quot;&#125;&#125;&lt;/td&gt; --&gt; &lt;td&gt;&#123;&#123;mp.get_level_display&#125;&#125;&lt;/td&gt; &lt;td&gt;&#123;&#123;mp.get_status_display&#125;&#125;&lt;/td&gt; &lt;td&gt; &lt;a href=&quot;/pretty/&#123;&#123;mp.id&#125;&#125;/edit/&quot;&gt;&lt;button type=&quot;button&quot; class=&quot;btn btn-warning dropdown-toggle&quot; data-toggle=&quot;dropdown&quot; aria-haspopup=&quot;true&quot; aria-expanded=&quot;false&quot;&gt;编辑&lt;/button&gt;&lt;/a&gt; &lt;!-- &lt;a href=&quot;/dep/delete/?memid=&#123;&#123;mp.id&#125;&#125;&quot;&gt;&lt;button type=&quot;button&quot; class=&quot;btn btn-danger dropdown-toggle&quot; data-toggle=&quot;dropdown&quot; aria-haspopup=&quot;true&quot; aria-expanded=&quot;false&quot; &gt;删除&lt;/button&gt;&lt;/a&gt; --&gt; &lt;!-- &lt;a href=&quot;/dep/delete/?memid=&#123;&#123;mp.id&#125;&#125;&quot;&gt;&lt;button type=&quot;button&quot; class=&quot;btn btn-danger dropdown-toggle&quot; data-toggle=&quot;dropdown&quot; aria-haspopup=&quot;true&quot; aria-expanded=&quot;false&quot; &gt;删除&lt;/button&gt;&lt;/a&gt; --&gt; &lt;a href=&quot;/pretty/&#123;&#123;mp.id&#125;&#125;/delete/&quot;&gt;&lt;button type=&quot;button&quot; class=&quot;btn btn-danger dropdown-toggle&quot; data-toggle=&quot;dropdown&quot; aria-haspopup=&quot;true&quot; aria-expanded=&quot;false&quot; &gt;删除&lt;/button&gt;&lt;/a&gt; &lt;/td&gt; &lt;/tr&gt; &#123;% endfor %&#125; &lt;/tbody&gt; &lt;/table&gt; &lt;/div&gt; &lt;nav aria-label=&quot;Page navigation&quot;&gt; &lt;ul class=&quot;pagination&quot;&gt; &#123;&#123;page_string&#125;&#125; &lt;/ul&gt; &lt;/nav&gt; &lt;!-- &lt;form class=&quot;navbar-form navbar-left&quot; method=&quot;GET&quot;&gt; &lt;div class=&quot;form-group&quot;&gt; &lt;input type=&quot;text&quot; class=&quot;form-control&quot; placeholder=&quot;Search&quot; name=&quot;page&quot;&gt; &lt;/div&gt; &lt;button type=&quot;submit&quot; class=&quot;btn btn-default&quot;&gt;Submit&lt;/button&gt; &lt;/form&gt; --&gt;&#123;% endblock %&#125; BootStrap样式父类123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339from django.shortcuts import render,HttpResponse,redirectfrom .models import Department,Employee,PrettyNumfrom django import formsfrom django.core.exceptions import ValidationErrorfrom django.core.validators import RegexValidatorfrom django.utils.safestring import mark_safefrom app01.utils.pagination import Paginationimport copy# Create your views here.def department_list(request): member_list=Department.objects.all() return render(request,&#x27;dep.html&#x27;,&#123;&#x27;member&#x27;:member_list&#125;)def add_dep(request): if request.method==&#x27;GET&#x27;: return render(request,&#x27;adddep.html&#x27;) elif request.method==&#x27;POST&#x27;: title=request.POST.get(&#x27;aatitle&#x27;) Department.objects.create(tittle=title) return redirect(&quot;/dep/list/&quot;)def delete_dep(request): memid=request.GET.get(&#x27;memid&#x27;) Department.objects.filter(id=memid).delete() return redirect(&quot;/dep/list/&quot;)def edit_dep(request,memid): if request.method==&#x27;GET&#x27;: nnmame=Department.objects.filter(id=memid).first() return render(request,&#x27;editdpt.html&#x27;,&#123;&#x27;nnmame&#x27;:nnmame.tittle&#125;) aatitle=request.POST.get(&#x27;aatitle&#x27;) Department.objects.filter(id=memid).update(tittle=aatitle) return redirect(&quot;/dep/list/&quot;)def test(request): return render(request,&#x27;tt.html&#x27;)def usr_list(request): # for i in range(300): # Employee.objects.create(name=&quot;maomao&quot;,password=123,age=50,create_time=&#x27;2023-10-5&#x27;,depart_id=5) qurylist=Employee.objects.all() page_object=Pagination(request,qurylist) context=&#123; &quot;qurylist&quot;:page_object.page_qurylist, &quot;page_string&quot;:page_object.html(), &#125; return render(request,&#x27;usr.html&#x27;,context)# class MyForm(forms.Form): # usr=forms.CharField(widget=forms.EmailInput) # pwd=forms.CharField(widget=forms.PasswordInput) # age=forms.ImageField(widget=forms.NumberInput)# class MyForm(forms.Form):# class Meta:# model=Employee# fields=[&#x27;name&#x27;,&#x27;password&#x27;,&#x27;age&#x27;]def add_usr(request): context=&#123; &#x27;gender_choice&#x27;:Employee.gender_choices, &#x27;depart_list&#x27;:Department.objects.all() &#125; # form=MyForm() return render(request,&#x27;add_usr.html&#x27;,context) # return render(request,&#x27;add_usr_fro.html&#x27;,&#123;&#x27;form&#x27;:form&#125;)class MyForm(forms.ModelForm): # name=forms.CharField(min_length=3,label=&quot;用户名&quot;) # usr=forms.CharField(widget=forms.EmailInput) # pwd=forms.CharField(widget=forms.PasswordInput) # age=forms.ImageField(widget=forms.NumberInput) class Meta: model=Employee fields=[&#x27;name&#x27;,&#x27;password&#x27;,&#x27;age&#x27;,&#x27;account&#x27;,&#x27;create_time&#x27;,&#x27;depart&#x27;,&#x27;gender&#x27;] widgets=&#123; &quot;name&quot;:forms.TextInput(attrs=&#123;&quot;class&quot;:&quot;form-control&quot;&#125;), &quot;age&quot;:forms.TextInput(attrs=&#123;&quot;class&quot;:&quot;form-control&quot;&#125;), &quot;create-time&quot;:forms.TextInput(attrs=&#123;&quot;type&quot;:&quot;data&quot;&#125;) &#125; # def __init__(self,*args, **kwargs): # super().__init__(*args,**kwargs) # # for name,field in self.fields.items(): # field.Widget.attrs=&#123;&quot;class&quot;:&quot;form-control&quot;,&quot;placeholder&quot;:field.label&#125;def add_usr_form(request): if request.method == &quot;GET&quot;: form=MyForm() return render(request,&#x27;add_usr_fro.html&#x27;,&#123;&#x27;form&#x27;:form&#125;) # post 校验 form=MyForm(data=request.POST) if form.is_valid(): form.save() return redirect(&#x27;/usr/list/&#x27;) else: return render(request,&#x27;add_usr_fro.html&#x27;,&#123;&quot;form&quot;:form&#125;)def usr_edit(request,nid): #获取默认值 row_object=Employee.objects.filter(id=nid).first() if request.method ==&#x27;GET&#x27;: form =MyForm(instance=row_object) return render(request,&#x27;usr_edit.html&#x27;,&#123;&#x27;form&#x27;:form&#125;) #post form=MyForm(data=request.POST,instance=row_object) if form.is_valid(): form.save() return redirect(&#x27;/usr/list/&#x27;) return render(request,&#x27;usr_edit.html&#x27;,&#123;&#x27;form&#x27;:form&#125;)def usr_delete(request,nid): Employee.objects.filter(id=nid).delete() return redirect(&#x27;/usr/list/&#x27;)class PrettyForm(forms.ModelForm): # 验证方法一 # mobile=forms.CharField( # label=&quot;手机号&quot;, # validators=[RegexValidator(r&#x27;^1[3-9]\\d&#123;9&#125;$&#x27;,&#x27;手机号格式错误&#x27;)] # ) class Meta: model=PrettyNum fields=[&#x27;mobile&#x27;,&#x27;price&#x27;,&#x27;level&#x27;,&#x27;status&#x27;] # fields=&quot;__all__&quot; # exclude=[&#x27;level&#x27;] widgets=&#123; &quot;mobile&quot;:forms.TextInput(attrs=&#123;&quot;class&quot;:&quot;form-control&quot;&#125;), &quot;price&quot;:forms.TextInput(attrs=&#123;&quot;class&quot;:&quot;form-control&quot;&#125;), &quot;level&quot;:forms.TextInput(attrs=&#123;&quot;class&quot;:&quot;form-control&quot;&#125;), &quot;status&quot;:forms.TextInput(attrs=&#123;&quot;class&quot;:&quot;form-control&quot;&#125;), &#125;# 验证方法二 def clean_mobile(self): txt_mobile=self.cleaned_data[&quot;mobile&quot;] exists=PrettyNum.objects.filter(mobile=txt_mobile).exists() if len(txt_mobile)!=11: #验证不通过 raise ValidationError(&quot;格式错误&quot;) if exists: #验证不通过 raise ValidationError(&quot;手机号已存在&quot;) return txt_mobiledef pretty_list(request):##搜索# --------------------# 1.PrettyNum.objects.filter&#123;mobile=&#x27;13906135233&#x27;,&quot;id&quot;:123&#125;# 2.data_dict=&#123;&quot;mobile&quot;:&quot;13906135233&quot;,&quot;id&quot;:123&#125;# PrettyNum.objects.filter(**data_dict)# --------------------------------# PrettyNum.objects.filter(id=12) 等于12# PrettyNum.objects.filter(id__gt=12) 大于12# PrettyNum.objects.filter(id__gte=12) 大于等于12# PrettyNum.objects.filter(id__lt=12) 小于12# PrettyNum.objects.filter(id__lte=12) 小于等于12# data_dict=&#123;&quot;id__lte&quot;:12&#125;# # -----------------------------------# PrettyNum.objects.filter(mobile=&#x27;233&#x27;) 等于# PrettyNum.objects.filter(mobile__startswitch=&quot;139&quot;) 筛选出以139开头# PrettyNum.objects.filter(mobile__endswitch=&quot;233&quot;) 筛选出以233结尾# PrettyNum.objects.filter(mobile__contains=&quot;5233&quot;) 筛选出包含5233# use# data_dict=&#123;&quot;mobile__contains&quot;:&quot;233&quot;&#125;# PrettyNum.objects.filter(**data_dict)# ----------------------------------------# test # for i in range(300): # PrettyNum.objects.create(mobile=&quot;13906135899&quot;,price=10,level=1,status=1) # print(request.GET) # request.GET.setlist(&#x27;xx&#x27;,11) # print(request.GET.urlencode()) #q=123&amp;page=2 # get_object=copy.deepcopy(request.GET) # get_object._mutable=True # get_object.setlist(&#x27;page&#x27;,[11]) # print(get_object.urlencode()) qury_dict=copy.deepcopy(request.GET) qury_dict._mutable=True qury_dict.setlist(&#x27;page&#x27;,[11]) print(qury_dict.urlencode()) data_dict=&#123;&#125; value=request.GET.get(&#x27;q&#x27;,&#x27;&#x27;) if value: data_dict[&quot;mobile__contains&quot;] = value qurylist=PrettyNum.objects.filter(**data_dict).order_by(&quot;-level&quot;) page_object= Pagination(request,qurylist) page_qurylist=page_object.page_qurylist page_string=page_object.html() context=&#123;&#x27;qurylist&#x27;:page_qurylist, &quot;search_data&quot;:value, &quot;page_string&quot;:page_string&#125; # res=PrettyNum.objects.filter(**data_dict) # print(res) # if request.method==&#x27;GET&#x27;: # ****qurylist=PrettyNum.objects.filter(**data_dict).order_by(&quot;-level&quot;)[start:end] #select * from 表 order by level desc # qurylist=PrettyNum.objects.all().order_by(&quot;-level&quot;)#分页 # qurylist=PrettyNum.objects.all() # qurylist=PrettyNum.objects.filter(id=4)[0:10] # qurylist=PrettyNum.objects.all()[0:10] # qurylist=PrettyNum.objects.all()[10:20] # qurylist=PrettyNum.objects.all()[20:30] # page=int(request.GET.get(&#x27;page&#x27;,1)) # pageSize=10 # start=(page-1)*pageSize # end=page*pageSize # qurylist=PrettyNum.objects.filter(**data_dict).order_by(&quot;-level&quot;)[page_object.start:page_object.end] #总数据条数# total_count=PrettyNum.objects.filter(**data_dict).order_by(&quot;-level&quot;).count()# #总页码# total_page_count,div=divmod(total_count,pageSize)# if div:# total_page_count+=1 # 计算出，显示当前页的前5页、后5页# plus=5# if total_page_count&lt;=2*plus+1:# #数据库中的数据比较少，都没有达到11页# start_page=1# end_page=total_page_count# else:# #数据库中的数据比较多 &gt;11页# #当前页&lt;5时(极小值)# if page&lt;=plus:# start_page=1# end_page=2*plus+1# else:# #当前页&gt;5# #当前页+5&gt;总页面# if (page+plus)&gt;total_page_count:# start_page=total_page_count-2*plus# end_page=total_page_count# else:# start_page=page-plus# end_page=page+plus# #页码# page_str_list=[]# #首页# page_str_list.append(&#x27;&lt;li&gt;&lt;a href=&quot;?page=&#123;&#125;&quot;&gt;首页&lt;/a&gt;&lt;/li&gt;&#x27;.format(1))# #上一页# if page&gt;1:# prev=&#x27;&lt;li&gt;&lt;a href=&quot;?page=&#123;&#125;&quot;&gt;上一页&lt;/a&gt;&lt;/li&gt;&#x27;.format(page-1)# else:# prev=&#x27;&lt;li&gt;&lt;a href=&quot;?page=&#123;&#125;&quot;&gt;上一页&lt;/a&gt;&lt;/li&gt;&#x27;.format(1)# page_str_list.append(prev) # for i in range(start_page,end_page+1):# if i==page:# ele=&#x27;&lt;li class=&quot;active&quot;&gt;&lt;a href=&quot;?page=&#123;&#125;&quot;&gt;&#123;&#125;&lt;/a&gt;&lt;/li&gt;&#x27;.format(i,i)# else:# ele=&#x27;&lt;li&gt;&lt;a href=&quot;?page=&#123;&#125;&quot;&gt;&#123;&#125;&lt;/a&gt;&lt;/li&gt;&#x27;.format(i,i)# page_str_list.append(ele)# #下一页# if page&lt;total_page_count:# prev=&#x27;&lt;li&gt;&lt;a href=&quot;?page=&#123;&#125;&quot;&gt;下一页&lt;/a&gt;&lt;/li&gt;&#x27;.format(page+1)# else:# prev=&#x27;&lt;li&gt;&lt;a href=&quot;?page=&#123;&#125;&quot;&gt;下一页&lt;/a&gt;&lt;/li&gt;&#x27;.format(total_page_count)# page_str_list.append(prev)# #尾页# page_str_list.append(&#x27;&lt;li&gt;&lt;a href=&quot;?page=&#123;&#125;&quot;&gt;尾页&lt;/a&gt;&lt;/li&gt;&#x27;.format(total_page_count))# search_string=&quot;&quot;&quot;&quot;# &lt;form class=&quot;navbar-form navbar-left&quot; method=&quot;GET&quot;&gt;# &lt;div class=&quot;form-group&quot;&gt;# &lt;input type=&quot;text&quot; class=&quot;form-control&quot; placeholder=&quot;Search&quot; name=&quot;page&quot;&gt;# &lt;/div&gt;# &lt;button type=&quot;submit&quot; class=&quot;btn btn-default&quot;&gt;Submit&lt;/button&gt;# &lt;/form&gt;# &quot;&quot;&quot;# page_str_list.append(search_string)# page_string =mark_safe(&quot;&quot;.join(page_str_list)) return render(request,&#x27;pretty_list.html&#x27;,context)def pretty_add(request): if request.method==&#x27;GET&#x27;: form=PrettyForm() return render(request,&#x27;pretty_add.html&#x27;,&#123;&#x27;form&#x27;:form&#125;) #post校验 form=PrettyForm(data=request.POST) if form.is_valid(): form.save() return redirect(&#x27;/pretty/list/&#x27;) else: return render(request,&#x27;pretty_add.html&#x27;,&#123;&quot;form&quot;:form&#125;)class PrettyEditModelForm(forms.ModelForm): # 验证方法一 mobile=forms.CharField( label=&quot;手机号&quot;, # disabled=True, validators=[RegexValidator(r&#x27;^1[3-9]\\d&#123;9&#125;$&#x27;,&#x27;手机号格式错误&#x27;)], ) ## mobile=forms.CharField(disabled=True,label=&quot;手机号&quot;) class Meta: model=PrettyNum fields=[&#x27;mobile&#x27;,&#x27;price&#x27;,&#x27;level&#x27;,&#x27;status&#x27;] def clean_mobile(self): # print(self.instance.pk) txt_mobile=self.cleaned_data[&quot;mobile&quot;] exists=PrettyNum.objects.exclude(id=self.instance.pk).filter(mobile=txt_mobile).exists() # if len(txt_mobile)!=11: # # 验证不通过 # raise ValidationError(&quot;格式错误&quot;) if exists: #验证不通过 raise ValidationError(&quot;手机号已存在&quot;) return txt_mobile def pertty_edit(request,nid): row_object=PrettyNum.objects.filter(id=nid).first() if request.method==&#x27;GET&#x27;: form=PrettyEditModelForm(instance=row_object) return render(request,&#x27;pretty_edit.html&#x27;,&#123;&#x27;form&#x27;:form&#125;) #post form=PrettyEditModelForm(data=request.POST,instance=row_object) if form.is_valid(): form.save() return redirect(&#x27;/pretty/list/&#x27;) else: return render(request,&#x27;pretty_edit.html&#x27;,&#123;&#x27;form&#x27;:form&#125;)def pertty_delete(request,nid): PrettyNum.objects.filter(id=nid).delete() return redirect(&#x27;/pretty/list/&#x27;)","categories":[{"name":"2023","slug":"2023","permalink":"http://example.com/categories/2023/"}],"tags":[{"name":"django","slug":"django","permalink":"http://example.com/tags/django/"}]},{"title":"Spark入门：RDD编程（2）","slug":"Spark入门：RDD编程（2）","date":"2023-03-20T16:28:42.147Z","updated":"2023-03-27T13:09:38.064Z","comments":true,"path":"2023/03/21/Spark入门：RDD编程（2）/","link":"","permalink":"http://example.com/2023/03/21/Spark%E5%85%A5%E9%97%A8%EF%BC%9ARDD%E7%BC%96%E7%A8%8B%EF%BC%882%EF%BC%89/","excerpt":"","text":"Spark入门：RDD编程(2)4.2键值对RDD4.2.1键值对RDD的创建 123456lines=sc.textFile(&quot;file:///usr/local/spark/mycode/rdd/word.txt&quot;)pairRdd=lines.flatMap(lambda line:line.split(&quot; &quot;)).map(lambda word:(word,1))pairRdd.foreach(print) 4.2.2常用键值对转换操作 1.reduceByKey(func) 2.groupByKey() 3.key 4.value 5.sortByKey() 6.sortBy() 7.mapValues(func) 8.join 4.2.3一个综合实例","categories":[{"name":"2023","slug":"2023","permalink":"http://example.com/categories/2023/"}],"tags":[{"name":"Spark","slug":"Spark","permalink":"http://example.com/tags/Spark/"}]},{"title":"Spark入门：RDD编程（1）","slug":"spark","date":"2023-03-20T14:19:48.651Z","updated":"2023-03-27T17:24:03.725Z","comments":true,"path":"2023/03/20/spark/","link":"","permalink":"http://example.com/2023/03/20/spark/","excerpt":"Spark入门：RDD编程(1)","text":"Spark入门：RDD编程(1) 4.1RDD编程基础RDD创建RDD可以通过两种方式创建： 第一种：读取一个外部数据集。比如，从本地文件加载数据集，或者从HDFS文件系统、HBase、Cassandra、Amazon S3等外部数据源中加载数据集。Spark可以支持文本文件、SequenceFile文件（Hadoop提供的 SequenceFile是一个由二进制序列化过的key&#x2F;value的字节流组成的文本存储文件）和其他符合Hadoop InputFormat格式的文件。 第二种：调用SparkContext的parallelize方法，在Driver中一个已经存在的集合（数组）上创建 在即将进行相关的实践操作之前，我们首先要登录Linux系统（本教程统一采用hadoop用户登录），然后，打开命令行“终端”，请按照下面的命令启动Hadoop中的HDFS组件： 创建RDD之前的准备工作在即将进行相关的实践操作之前，我们首先要登录Linux系统（本教程统一采用hadoop用户登录），然后，打开命令行“终端”，请按照下面的命令启动Hadoop中的HDFS组件： 12cd /usr/local/hadoop./sbin/start-dfs.sh 然后，我们按照下面命令启动spark-shell： 12cd /usr/local/spark./bin/pyspark 然后，新建第二个“终端”，方法是，在前面已经建设的第一个终端窗口的左上方，点击“终端”菜单，在弹出的子菜单中选择“新建终端”，就可以打开第二个终端窗口，现在，我们切换到第二个终端窗口，在第二个终端窗口中，执行以下命令，进入之前已经创建好的“&#x2F;usr&#x2F;local&#x2F;spark&#x2F;mycode&#x2F;”目录，在这个目录下新建rdd子目录，用来存放本章的代码和相关文件： 12cd usr/local/spark/mycode/mkdir rdd 然后，使用vim编辑器，在rdd目录下新建一个word.txt文件，你可以在文件里面随便输入几行英文语句用来测试。 经过上面的准备工作以后，我们就可以开始创建RDD了。 从文件系统中加载数据创建RDDSpark采用textFile()方法来从文件系统中加载数据创建RDD，该方法把文件的URI作为参数，这个URI可以是本地文件系统的地址，或者是分布式文件系统HDFS的地址，或者是Amazon S3的地址等等。下面请切换回spark-shell窗口，看一下如何从本地文件系统中加载数据： 12&gt;&gt;&gt;lines = sc.textFile(&quot;file:///usr/local/spark/mycode/rdd/word.txt&quot;) 1&gt;&gt;&gt;lines.foreach(print) 加载HDFS中的文件为了能够读取HDFS中的文件，请首先启动Hadoop中的HDFS组件。注意，之前我们在“Spark安装”这章内容已经介绍了如何安装Hadoop和Spark，所以，这里我们可以使用以下命令直接启动Hadoop中的HDFS组件（由于用不到MapReduce组件，所以，不需要启动MapReduce或者YARN）。请到第二个终端窗口，使用Linux Shell命令提示符状态，然后输入下面命令： 12cd /usr/local/hadoop./sbin/start-dfs.sh 启动结束后，HDFS开始进入可用状态。如果你在HDFS文件系统中，还没有为当前Linux登录用户创建目录(本教程统一使用用户名hadoop登录Linux系统)，请使用下面命令创建： 1./bin/hdfs dfs -mkdir -p /user/hadoop 也就是说，HDFS文件系统为Linux登录用户开辟的默认目录是“&#x2F;user&#x2F;用户名”（注意：是user，不是usr），本教程统一使用用户名hadoop登录Linux系统，所以，上面创建了“&#x2F;user&#x2F;hadoop”目录，再次强调，这个目录是在HDFS文件系统中，不在本地文件系统中。创建好以后，下面我们使用命令查看一下HDFS文件系统中的目录和文件： 1./bin/hdfs dfs -ls . ** 但这个命令我搞不出来，显示的是这个 – 上面命令中，最后一个点号“.”，表示要查看Linux当前登录用户hadoop在HDFS文件系统中与hadoop对应的目录下的文件，也就是查看HDFS文件系统中“&#x2F;user&#x2F;hadoop&#x2F;”目录下的文件，所以，下面两条命令是等价的： – 12./bin/hdfs dfs -ls ../bin/hdfs dfs -ls /user/hadoop 你自己可以试一试，只有第二个可以用 如果要查看HDFS文件系统根目录下的内容，需要使用下面命令： 1./bin/hdfs dfs -ls / 然后输出的东西见上面那个图，有一个items 下面，我们把本地文件系统中的“&#x2F;usr&#x2F;local&#x2F;spark&#x2F;mycode&#x2F;rdd&#x2F;word.txt”上传到分布式文件系统HDFS中（放到hadoop用户目录下）： 1./bin/hdfs dfs -put /usr/local/spark/mycode/rdd/word.txt /user/hadoop 然后，用命令查看一下HDFS的hadoop用户目录下是否多了word.txt文件，可以使用下面命令列出hadoop目录下的内容： 1./bin/hdfs dfs -ls / 可以看到，确实多了一个word.txt文件，我们使用cat命令查看一个HDFS中的word.txt文件的内容，命令如下： 1./bin/hdfs dfs -cat ./word.txt 上面命令执行后，就会看到HDFS中word.txt的内容了。 现在，让我们切换回到spark-shell窗口，编写语句从HDFS中加载word.txt文件，并显示第一行文本内容： 12&gt;&gt;&gt;lines= sc.textFile(&quot;hdfs://localhost:9000/user/hadoop/word.txt&quot;)&gt;&gt;&gt;lines=sc.foreach(print) 注意，上面三条命令是完全等价的命令，只不过使用了不同的目录形式，你可以使用其中任意一条命令完成数据加载操作。 在使用Spark读取文件时，需要说明以下几点：（1）如果使用了本地文件系统的路径，那么，必须要保证在所有的worker节点上，也都能够采用相同的路径访问到该文件，比如，可以把该文件拷贝到每个worker节点上，或者也可以使用网络挂载共享文件系统。（2）textFile()方法的输入参数，可以是文件名，也可以是目录，也可以是压缩文件等。比如，textFile(“&#x2F;my&#x2F;directory”), textFile(“&#x2F;my&#x2F;directory&#x2F;.txt”), and textFile(“&#x2F;my&#x2F;directory&#x2F;.gz”).（3）textFile()方法也可以接受第2个输入参数（可选），用来指定分区的数目。默认情况下，Spark会为HDFS的每个block创建一个分区（HDFS中每个block默认是128MB）。你也可以提供一个比block数量更大的值作为分区数目，但是，你不能提供一个小于block数量的值作为分区数目。 通过并行集合（数组）创建RDD可以调用SparkContext的parallelize方法，在Driver中一个已经存在的集合（数组）上创建。下面请在spark-shell中操作： 123&gt;&gt;&gt;array = [1,2,3,4,5]&gt;&gt;&gt;rdd = sc.parallelize(array)&gt;&gt;&gt;rdd.foreach(print) RDD操作RDD被创建好以后，在后续使用过程中一般会发生两种操作：*  转换（Transformation）： 基于现有的数据集创建一个新的数据集。*  行动（Action）：在数据集上进行运算，返回计算值。 Ⅰ转换操作对于RDD而言，每一次转换操作都会产生不同的RDD，供给下一个“转换”使用。转换得到的RDD是惰性求值的，也就是说，整个转换过程只是记录了转换的轨迹，并不会发生真正的计算，只有遇到行动操作时，才会发生真正的计算，开始从血缘关系源头开始，进行物理的转换操作。下面列出一些常见的转换操作（Transformation API）：* filter(func)：筛选出满足函数func的元素，并返回一个新的数据集* map(func)：将每个元素传递到函数func中，并将结果返回为一个新的数据集* flatMap(func)：与map()相似，但每个输入元素都可以映射到0或多个输出结果* groupByKey()：应用于(K,V)键值对的数据集时，返回一个新的(K, Iterable)形式的数据集* reduceByKey(func)：应用于(K,V)键值对的数据集时，返回一个新的(K, V)形式的数据集，其中的每个值是将每个key传递到函数func中进行聚合 1.filter(func) 好吧，这个书上说要把word.txt写成 12345Hadoop is goodSpark is fastSpark is better 那我们就 1cd /usr/local/spark/mycode/rdd 1gedit word.txt 然后再 123&gt;&gt;&gt;lines=sc.textFile(&quot;file:///usr/local/spark/mycode/rdd/word.txt&quot;)&gt;&gt;&gt;linesWithSpark = lines.filter(lambda line: &quot;Spark&quot; in line)&gt;&gt;&gt;linesWithSpark.foreach(print) 上面的代码中，lines就是一个RDD。lines.filter()会遍历lines中的每行文本，并对每行文本执行括号中的匿名函数，也就是执行Lamda表达式：line &#x3D;&gt; line.contains(“Spark”)，在执行Lamda表达式时，会把当前遍历到的这行文本内容赋值给参数line，然后，执行处理逻辑line.contains(“Spark”)，也就是只有当改行文本包含“Spark”才满足条件，才会被放入到结果集中。最后，等到lines集合遍历结束后，就会得到一个结果集，这个结果集中包含了所有包含“Spark”的行。最后，对这个结果集调用count()，这是一个行动操作，会计算出结果集中的元素个数。 2.map(func) map(func)：将每个元素传递到函数func中，并将结果返回为一个新的数据集 1234&gt;&gt;&gt; data =[1,2,3,4,5]&gt;&gt;&gt; rdd1 = sc.parallelize(data)&gt;&gt;&gt; rdd2 = rdd1.map(lambda x:x+10)&gt;&gt;&gt; rdd2.foreach(print) 上述语句执行过程如图 所示。第 1行语句创建了一个包含 5 个整型元素的列表 data。第2行语句执行 sc.parallelize(data)，从列表 data 中生成一个 RDD，即 rdd1,rdd1 中包含了5 个整型的元素即1、2、3、4、5。第 3 行语句执行 rdd1.map0操作,map0的输入参数“lambda x:x+10”是一个Lambda表达式。rdd1.map(lambda x:x+10)的含义是，依次取出 rdd1 这个RDD 中的每个元素，对于当前取到的元素，把它赋值给 Lambda 表达式中的变量x，然后，执行 Lambda 表达式的函数体部分“x+10”也就是把变量x的值和 10 相加后，作为函数的返回值，并作为一个元素放入到新的 RDD(即rdd2中。最终，新牛成的RDD (即 rdd2) 中包含了 5 个整型元素，即 11、12、13、14、15。 另外一个实例： 123&gt;&gt;&gt;lines=sc.textFile(&quot;file:///usr/local/spark/mycode/rdd/word.txt&quot;)&gt;&gt;&gt; words = lines.map(lambda line:line.split(&quot; &quot;))&gt;&gt;&gt; words.foreach(print) 上述语句执行过程如图所示。在第 1 行语句中，执行 sc.textFile0方法把 word.txt 文件中的数据加载到内存生成一个 RDD，即 lines，这个RDD 中的每个元素都是字符串类型，即每个 RDD 元素都是一行文本，比如，lines 中的第 1 个元素是”Hadoop is good”，第2 个元素是”Spark is fast”，第3个元素是”Spark is better”。在第 2 行语句中，执行 lies.map0操作，map0的输入参数 lambdaline:line.split(“)是一个 Lambda 表达式。linesmap(lambda line:line.split(“”)的含义是，依次取出 lines这个 RDD 中的每个元素，对于当前取到的元素，把它赋值给 Lambda 表达式中的变量 line，然后，执行 Lambda 表达式的函数体部分 line.split(“”)。因为 line 是一行文本，如”Hadoop is good”，一行文本中包含了很多个单词，单词之间以空格进行分隔，所以，line.split(“”的功能是，以空格作为分隔符把 line 拆分成一个个单词,拆分后得到的单词都封装在一个列表对象中,成为新的 RDD( 即 words)的一个元素，比如，”Hadoop is good”被拆分后，得到”Hadoop”、”is”和”good”3 个单词，会被封装到一个列表对象中，即[“Hadoop”.”is”,”good”]，成为 words 这个 RDD 中的一个元素。 3.flatMap(func)flatMap(func)与 map0相似，但每个输入元素都可以映射到 0 或多个输出结果。例如: 123&gt;&gt;&gt;lines=sc.textFile(&quot;file:///usr/local/spark/mycode/rdd/word.txt&quot;)&gt;&gt;&gt;words =lines.flatMap(lambda line:line.split(&quot; &quot;))&gt;&gt;&gt; words.foreach(print) 上述语句执行过程如图所示。在第 1行语句中，执行 sc.textFile0方法把 wordtxt 文件中的数据加载到内存生成一个RDD，即 lines，这个 RDD 中的每个元素都是字符串类型，即每个RDD 元素都是一行文本。在第2行语句中，执行 linesflatMap0操作，flatMap0的输入参数 line:linesplit(“”)是个Lambda 表达式。lines.flatMap(lambda line:line.split(“”))的结果，等价于如下两步操作的结果。 第1步: map0。执行 lines.map(lambda line: linesplit(“”))操作，从 lines 转换得到一个新的 RDD(即wordArray),wordArray 中的每个元素都是一个列表,比如,第1个元素是[“Hadoop”,”is”，”good”]7.第2个元素是”Spark”，”is”,”fast”]，第3 个元素是[“Spark”,”is””better”]。 第 2步:拍扁 ( flat)。flatMap0操作中的“flat”是一个很形象的动作-“拍扁”，也就是把vordArray 中的每个 RDD 元素都“拍扁”成多个元素。所有这些被拍扁以后得到的元素，构成一个新的 RDD，即 words。比如，wordArray 中的第1个元素是[“Hadoop”,”is”,”good]，被拍扁以后得到3个新的字符串类型的元素,即”Hadoop”、”is”和”good”; wordArray 中的第 2 个元素是[“Spark”,”is”fast”],被拍扁以后得到 3 个新的元素,即”Spark”、”is”和”fast”; wordArray 中的第 3 个元素是[“Spark””is””beter”，被拍扁以后得到 3 个新的元素，即”Spark”、”is”和”beter”。最终，这些被拍扁以后得到的 9 个字符串类型的元素构成一个新的 RDD (即 words )。也就是说，words 里面包含了 9 个字串类型的元素，分别是”Hadoop”、”is”、”good”、”Spark”、”is”、”fast”、”Spark”、”is”和”‘better’。 4.gropByKeygroupByKey()应用于(K,V)键值对的数据集时，返回一个新的(K,Iterable)形式的数据集。 123words=sc.parallelize([(&quot;Hadoop&quot;,1),(&quot;is&quot;,1),(&quot;good&quot;,1),(&quot;Spark&quot;,1),(&quot;is&quot;,1),(&quot;better&quot;,1)])words1=words.groupByKey()words1.foreach(print) 如图所示，在这个实例中，名称为 words 的 RDD 中包含了 9 个元素，每个元素都是(KV)键值对类型。wordsl&#x3D;words.groupByKey0操作执行以后，所有 key 相同的键值对，它们的 value都被归并到一起。比如，(“is”,1)、(“is”,1)、(is”,1)这3 个键值对的 key 相同，就会被归并成一个新的键值对(“is”,(1,1,1))，其中，key 是”is”，value 是(1,1,1)，而且，value 会被封装成 Iterable 对象 (一种可选代集合 )。 5.reduceByKey(func)reduceByKey(func)应用于(KV)键值对的数据集时，返回一个新的(K,V)形式的数据集，其中的每个值是将每个key传递到函数func中进行聚合后得到的结果 123words=sc.parallelize([(&quot;Hadoop&quot;,1),(&quot;is&quot;,1),(&quot;good&quot;,1),(&quot;Spark&quot;,1),(&quot;is&quot;,1),(&quot;better&quot;,1)])words1=words.reduceByKey(lambda a,b:a+b)words1.foreach(print) 如图所示，在这个实例中，名称为 words 的 RDD 中包含了 9个元素，每个元素都是(K,V)键值对类型。words.reduceByKey(lambda a,b;atb)操作执行以后,所有 key 相同的键值对，它们的 value首先被归并到一起，比如，(“is”,1)、(“is”1)、(“is”,1)这3 个键值对的 key 相同，就会被归并成一个新的键值对(“is”,(1,1,1))，其中，key 是”is”，value 是一个 value-list，即(1,1,1)。然后，使用 func 函数把(l,1,1)聚合到一起，这里的 func 函数是一个Lambda 表达式，即 lambda a,b;atb，它的功能是把(1,1,1)这个 value-list 中的每个元素进行汇总求和。首先，把 value-list 中的第1个元素(即 1) 赋值给参数a，把 value-list 中的第 2个元素(也是 1)赋值给参数 b，执行 atb 得到 2，然后，继续对 value-list中的元素执行下一次计算，把刚才求和得到的 2 赋值给 a，把 value-list 中的第 3 个元素(即 1)赋值给b，再次执行 a+b 计算得到 3。最终，就得到聚合后的结果(‘is’,3)。 Ⅱ行动操作行动操作是真正触发计算的地方。Spark程序执行到行动操作时，才会执行真正的计算，从文件中加载数据，完成一次又一次转换操作，最终，完成行动操作得到结果。 用一个例子看看 12rdd =sc.parallelize([1,2,3,4,5])rdd.count() 5 12rdd.first() 1 1rdd.take(3) [1, 2, 3] 1rdd.reduce(lambda a,b:a+b) 15 1rdd.collect() [1, 2, 3, 4, 5] 1rdd.foreach(lambda elem:print(elem)) 1234512345 这里首先使用 sc.parallelize([1,2,3,4,5])生成了一个 RDD,变量名称为 rdd,rdd 中包含了5个元素分别是1、2、3、4和5，因此，rdd.count0语句执行以后返回的结果是 5。执行 rdd.first0语句后，会返回第1个元素，即1。当执行完 rdd.take(3)语句以后，会以列表的形式返回 rdd 中的前 3 个元素即[1,2,3]。执行完rdd.reduce(lambda a,b:a+b)语句后，会得到对 rdd 中的所有元素(即1、2、3、4、5进行求和以后的结果，即 15。在执行 rdd.reduce(lambda a,b;atb)时，系统会把 rdd 中的第1个元素1传入参数 a，把rdd 的第2个元素 2 传入参数 b，执行 a+b 计算得到求和结果 3;然后，把这个求和的结果 3 传入给参数 a，把 rdd 的第 3 个元素3 传入参数 b，执行 atb 计算得到求和结果 6; 然后,把6传入参数 a，把 rdd 的第 4 个元素 4 传入参数 b，执行 a+b 计算得到求和结果 10; 最后，把 10传入参数 a，把 rdd 的第 5个元素 5 传入参数 b，执行 atb 算得到求和结果 S。接下来，执行rdd.collect()，以列表的形式返回 rdd 中的所有元素，可以看出，执行结果是一个列表[1,2,3,4,5]。在这个实例的最后，执行了语句 rdd.foreach(lambda elem:print(elem)，该语句会依次遍历 rdd 中的每个元素，把当前遍历到的元素赋值给变量 elem，并使用 print(elem)打印出 elem 的值。实际上rdd.foreach(lambda elem:print(elem))可以被简化成 rdd.foreach(print)，执行效果是一样的。需要特别强调的是,当采用Local 模式在单机上执行时,rdd.foreach(print)语句会打印出一个RDD中的所有元素。但是，当采用集群模式执行时，在 Worker 节点上执行打印语句是输出到 Worker 节点的 stdout 中，而不是输出到任务控制节点 Driver 中，因此，任务控制节点 Driver 中的 stdout 是不会显示打印语句的这些输出内容的。为了能够把所有 Worker 节点上的打印输出信息也显示到 Driver中，就需要使用 collect0方法，比如，print(rdd.collect())。但是，由于 collect0方法会把各个 Worker节点上的所有 RDD元素都抓取到 Driver 中，因此，这可能会导致 Driver 所在节点发生内存溢出。所以，在实际编程中，需要谨慎使用&#96;&#96;&#96; collect()&#96;&#96;方法。 Ⅲ惰性机制惰性机制是指整个转换过程只是记录了转换的轨迹，并不会发生真正的计算，只有遇到行动操作时，才会触发“从头到尾”的真正的计算。这里给出一段简单的语句来解释 Spark 的惰性机制。 1234lines=sc.textFile(&quot;file:///usr/local/spark/mycode/rdd/word.txt&quot;)lineLengths=lines.map(lambda s:len(s))totalLength=lineLengths.reduce(lambda a,b:a+b)print(totalLength) 在上述语句中，第1 行语句中的 textFile()是一个转换操作，执行后，系统只会记录这次转换，并不会真正读取 wordtxt 文件的数据到内存中;第 2 行语句的 map也是一个转换操作，系统只是记录这次转换，不会真正执行 map()方法;第 3 行语句的 reduce()方法是一个“行动”类型的操作，这时，系统会生成一个作业，触发真正的计算。也就是说，这时才会加载 word.txt 的数据到内存，生成lines 这个RDD。lines 中的每个元素都是一行文本，然后，对 lines 执行 map()方法，计算这个RDD中每个元素的长度(即一行文本包含的单词个数 )，得到新的 RDD，即 lineLengths，这个RDD中每个元素都是整型，表示文本的长度。最后，在 lineLengths 上调用reduce()方法，执行 RDD元素求和，得到所有文本长度的总和。 持久化在 Spark 中，RDD 采用惰性求值的机制，每次遇到行动操作，都会从头开始执行计算。每次调用行动操作，都会触发一次从头开始的计算，这对于迭代计算而言，代价是很大的，因为选代计算经常需要多次重复使用同一组数据。下面就是多次计算同一个 RDD 的例子。 1234list = [&quot;Hadoop&quot;,&quot;Spark&quot;,&quot;Hive&quot;]rdd = sc.parallelize(list)print (rdd.count ()) #行动操作，触发一次真正从头到尾的计算print (&#x27;,&#x27;.join(rdd.collect())) #行动操作，触发一次真正从头到尾的计算Hadoop,Spark,Hive 实际上，可以通过持久化(缓存)机制来避免这种重复计算的开销。具体方法是使用 persist0方法将一个 RDD 标记为持久化，之所以要“标记为持久化”，是因为出现 persist0语句的地方，并不会马上计算生成 RDD 并把它持久化，而是要等到遇到第一个行动操作触发真正计算以后，才会把算结果进行持久化。持久化后的 RDD 将会被保留在计算节点的内存中，被后面的行动操作重复使用persist0的圆括号中包含的是持久化级别参数，可以有如下不同的级别。 persist(MEMORY ONLY): 表示将 RDD作为反序列化的对象存储于JVM 中，如果内存足，就要按照 LRU 原则替换缓存中的内容。 persist(MEMORYAND DISK):表示将RDD作为反序列化的对象存储在JVM中，如果内存不足，超出的分区将会被存放在硬盘上。 一般而言，使用 cache()方法时，会调用 persist(MEMORY ONLY)。针对上面的实例，增加持久化语句以后的执行过程如下: 12345list = [&quot;Hadoop&quot;,&quot;Spark&quot;,&quot;Hive&quot;]rdd = sc.parallelize(list)rdd.cache() #会调用 persist(MEMORY ONLY)，但是，语句执行到这里，并不会缓存 rdd，因为这#时 rdd 还没有被计算生成print(rdd.count()) #第一次行动操作，触发一次真正从头到尾的计算，这时上面的 rdd.cache ()#才会被执行，把这个 rdd 放到缓存中print(&#x27;.&#x27;.join(rdd.collect())) #第二次行动操作，不需要触发从头到尾的计算，只需要重复使#用上面缓存中的 rdd 持久化RDD 会占用内存空间，当不再需要一个 RDD 时，就可以使用 unpersist0方法手动地把持久化的 RDD 从缓存中移除，释放内存空间。 分区1.分区的作用RDD 是弹性分布式数据集，通常 RDD 很大，会被分成很多个分区，分别保存在不同的节点上如图49所示，一个集群中包含 4 个工作节点( WorkerNode )，分别是 WorkerNodel、WorkerNode2WorkerNode3 和 WorkerNode4。假设有两个 RDD，即rdd1 和 rdd2，其中，rdd1 包含5 个分区(即plp2、p3、p4和p5)，rdd2 包含3 个分区(即p6、p7和p8)。对RDD 进行分区，第一个作用是增加并行度。比如，在图 4-9 中，rdd2 的 3 个分区 p6、p7和p8,分布在3 个不同的工作节点 WorkerNode2、WorkerNode3 和 WorkerNode4 上，就可以在这3个T作节点上分别启动 3 个线程对这 3 个分区的数据进行并行处理，增加任务的并行度。 对 RDD 进行分区的第二个作用是减少通信开销。在分布式系统中，通信的代价是巨大的，控制数据分布以获得最少的网络传输可以极大地提升整体性能。Spark 程序可以通过控制 RDD 分区方式来减少网络通信的开销。下面通过一个实例来解释为什么通过分区可以减少网络传输开销。 连接(join)是查询分析中经常使用的一种操作。假设在某种应用中需要对两个表进行连接操作第1个表是一个很大的用户信息表 UserData(UserID,UserInfo)，其中，UserId 和 UserInfo 是 UserData表的两个字段，UserInfo 包含了某个用户所订阅的主题信息。第 2 个表是 Events(UserID,LinkInfo),这个表比较小，只记录了过去 5 分钟内发生的事件，即某个用户查看了哪个链接。为了对用户访问情况进行统计，需要周期性地对 UserData 和 Events 这两个表进行连接操作，获得(UserID,UserInfo,LinkInfo)这种形式的结果，从而知道某个用户订阅的是哪个主题，以及访问了哪个链接。 可以用 Spark 来实现上述应用场景。在执行 Spark 作业时，首先，UserData 表会被加载到内存中生成RDD(假设 RDD的名称为 userData)，RDD 中的每个元素是(UserID,UserInfo)这种形式的键值对,即 key 是 UserID,value 是 UserInfo;Events 表也会被加载到内存中生成RDD(假设名称为 events)RDD中的每个元素是(UserID，LinkInfo)这种形式的键值对，key 是 UserID，value 是 LinkInfo。由于UserData 是一个很大的表，通常会被存放到 HDFS 文件中，Spark 系统会根据每个 RDD 元素的数据来源，把每个 RDD 元素放在相应的节点上。比如，从工作节点 上的 HDFS 文件块 (block)中读取到的记录，其生成的 RDD 元素 ((UserID，UserInfo)形式的键值对 ，就会被放在节点上，从节点上的 HDFS 文件块 (block)中读取到的记录，其生成的 RDD 元素会被放在节点上，最终userData 这个 RDD 的元素就会分布在节点u1、u2…..um上。然后，执行连接操作 userData,join(events)得到连接结果。如图 所示，在默认情况下，连接操作会将两个数据集中的所有的 key 的哈希值都求出来，将哈希值相同的记录传送到同一台机器上之后在该机器上对所有 key 相同的记录进行连接操作。比如，对于 userData 这个 RDD 而言，它在节点山上的所有 RDD 元素，都需要根据 key 的值进行哈，然后，根据哈希值再分发到 j1、j2…..j这些节点上;在节点u上的所有 RDD 元素，也需要根据 key 的值进行哈希，然后，根据哈希值再分发到j1……jk这些节点上;同理，u1……um等节点上的 RDD元素，都需要进行同样的操作对于events 这个RDD 而言，也需要执行同样的操作。可以看出，在这种情况下，每次进行连接操作都会有数据混洗的问题，造成了很大的网络传输开销。 实际上，由于userData 这个 RDD 要比 events 大很多，所以，可以选择对 userData 进行分区。比如.可以采用哈希分区方法，把 userData 这个 RDD 分区成 m 个分区，这些分区分布在节点 、u…“u，上。对userData 进行分区以后，在执行连接操作时，就不会产生图 4-10 中的数据混洗情况。如图所示，由于已经对 userData 根据哈希值进行了分区，因此，在执行连接操作时，不需要再把 userData中的每个元素进行哈希求值以后再分发到其他节点上，只需要对 events 这个 RDD 的每个元素求哈希值(采用与 userData 相同的哈希函数)。然后，根据哈希值把每个 events 中的 RDD 元素分发到对应的节点u、u····um上面。整个过程中，只有 events 发生了数据混洗，产生了网络通信，而 userData的数据都是在本地引用，不会产生网络传输开销。由此可以看出，Spark 通过数据分区，可以大大降低一些特定类型的操作(比如join()、leftOuterJoin()、groupByKey()、reduceByKey()等)的网络传输开销。 2.分区的原则 RDD分区的一个原则是使得分区的个数尽量等于集群中的 CPU核心(Core)数目。对于不同的Spark 部署模式 (Local 模式、Standalone 模式、YARN 模式、Mesos 模式)而言，都可以通过设置spark.defaultparallelism 这个参数的值，来配置默认的分区数目。一般而言，各种模式下的默认分区数目如下。Local模式:默认为本地机器的 CPU 数目，若设置了 local[N]，则默认为 N。Standalone 或YARN模式:在“集群中所有 CPU 核心数目总和”和“2”这二者中取较大值作为默认值。Mesos 模式:默认的分区数为 8。 3.设置分区的个数可以手动设置分区的数量，主要包括两种方式: 创建 RDD 时手动指定分区个数;使用repartition方法重新设置分区个数。 (1)创建RDD 时手动指定分区个数 在调用 textFile()和 parallelize()方法的时候手动指定分区个数即可，语法格式如下: 1sc.textFile(path, partitionNum) 其中，path 参数用于指定要加载的文件的地址，partitionNum 参数用于指定分区个数。下面是个分区的实例。 12list = [1,2,3,4,5]rdd = sc.parallelize(list,2) //设置两个分区 对于 parallelize()而言，如果没有在方法中指定分区数，则默认为 spark.default,parallelism。对于textFile()而言，如果没有在方法中指定分区数，则默认为 min(defaultParallelism,2)，其中defaultParallelism 对应的就是 spark.default,parallelism。如果是从HDFS 中读取文件，则分区数为文件分片数(比如，128MB&#x2F;片 )。 (2)使用repartition 方法重新设置分区个数 通过转换操作得到新 RDD 时，直接调用 repartition 方法即可。例如: 123456data = sc.parallelize([1,2,3,4,5],2)len(data.glom().collect ()) #显示 data 这个 RDD 的分区数量2rdd = data.repartition(1) #对 data 这个RDD进行重新分区len(rdd.glom().collect())#显示 rdd 这个 RDD的分区数量1 4.自定义分区方法 Spark 提供了自带的 HashPartitioner (哈希分区)与 RangePartitioner ( 区城分区)，能够满足大数应用场景的需求。与此同时，Spark 也支持自定义分区方式，即通过提供一个自定义的分区函数来控制 RDD 的分区方式，从而利用领域知识进一步减少通信开销。需要注意的是，Spark 的分区函数针对的是(key;value)类型的 RDD，也就是说，RDD 中的每个元素都是(key,value)类型，然后，分区数根据 key对RDD 元素进行分区。因此，当需要对一些非(key,value)类型的 RDD进行自定义分区时需要首先把 RDD 元素转换为(key,value)类型，然后再使用分区函数。下面是一个实例，要求根据 key 值的最后一位数字将 key 写入到不同的文件中，比如，10 写入到part-00000，11写入到 part-00001，12 写入到 part-00002。打开一个 Linux 终端，使用 vim 编辑器创建一个代码文件“&#x2F;usr&#x2F;local&#x2F;spark&#x2F;mycode&#x2F;rdd&#x2F;TestPartitioner.py”，输入以下代码: 12345678910111213141516171819from pyspark import SparkConf, SparkContextdef MyPartitioner(key): print(&quot;MyPartitioner is running&quot;) print(&#x27;The key is %d&#x27; % key) return key%10def main(): print(&quot;The main function is running&quot;) conf=SparkConf().setMaster(&quot;local&quot;).setAppName(&quot;MyApp&quot;) sc=SparkContext(conf=conf) data=sc.parallelize(range(10),5) data.map(lambda x:(x,1)) \\ .partitionBy(10,MyPartitioner)\\ .map(lambda x:x[0]) \\ .saveAsTextFile(&quot;File:///usr/local/spark/mycode/add/partitioner&quot;)if __name__==&#x27;__main__&#x27;: main() 出现问题 ModuleNotFoundError: No module named &#39;pyspark&#39; 12apt install python3-pippip install pyspark 在上述代码中，data&#x3D;sc.parallelize(range(10),5)这行代码执行后，会生成一个名称为 data 的 RDD这个RDD 中包含了 0、1、2、3…..9 共 10 个整型元素，并被分成 5个分区。data,map(lambda x:(x,1)表示把 data 中的每个整型元素取出来，转换成(key,value)类型。比如，把1 这个元素取出来以后转按成(1,1)，把2这个元素取出来以后转换成(2,1)，这是因为，自定义分区函数要求 RDD 元素的类型必须是(key, value)类型。partitionBy(10,MyPartitioner表示调用自定义分区函数，把(0,1)、(,)、(2,1)、(3,1)….(9,1)这些 RDD 元素根据尾号分成10个分区。划分分区完成以后,再使用 map(ambda x:x[0).把(0,1)、(1,1)、(2,1)、(3,1) .·….(9,1)等(key,value)类型元素的 key 提取出来，得到 0、1、2、3…9.最后调用 saveAsTextFile0方法把 RDD的 10个整型元素写入到本地文件中。 使用如下命令运行 TestPartitioner.py: 12cd /usr/local/spark/mycode/rddpython3 TestPartitioner.py or 12$ cd /usr/local/spark/mycode/rddS /usr/local/spark/bin/spark-submit TestPartitioner.py 程序运行后会返回如下信息: 1234567The main function is runningMyPartitioner is runningThe key is 0MyPartitioner is runningThe key is 1MyPartitioner is runningThe key is 9 运行结束后可以看到，在本地文件系统的“file:&#x2F;&#x2F;&#x2F;usr&#x2F;local&#x2F;spark&#x2F;mycode&#x2F;rdd&#x2F;partitioner”目录下面，会生成 part-00000、part-00001、part-00002…..part-00009 和_SUCCESS 等文件。其中,part-00000文件中包含了数字 0，part-00001 文件中包含了数字 1，part-00002 文件中包含了数字 2 综合实例假设有一个本地文件“&#x2F;usr&#x2F;local&#x2F;spark&#x2F;mycode&#x2F;rdd&#x2F;word.txt”，里面包含了很多行文本，每行文本由多个单词构成，单词之间用空格分隔。可以使用如下语句对 word.txt 中的单词进行词频统计(即统计每个单词出现的次数 ): 1lines=sc.textFile(&quot;file:///usr/local/spark/mycode/rdd/word.txt&quot;) 1wordCount=lines.flatMap(lambda line:line.split(&quot; &quot;)).map(lambda word:(word,1)).reduceByKey(lambda a,b:a+b) 1print(wordCount.collect()) 在实际应用中，单词文件可能非常大，会被保存到分布式文件系统 HDFS 中，Spark 和 Hadoop会统一部署在一个集群上。如图所示，HDFS 的名称节点(HDFS NN)和 Spark 的主节点( SparkMaster)可以分开部署，而HDFS 的数据节点(HDFS DN)和 Spark 的从节点 ( Spark Worker)会部署在一起。这时采用 Spark 进行分布式处理,可以大大提高词频统计程序的执行效率,这是因为,SparkWorker 可以就近处理与自己部署在一起的 HDFS 数据节点中的数据。 对于词频统计程序 WordCount 而言，该程序分布式运行在每个 Slave 节点的每个分区上，统计本分区内的单词计数，然后将它传回给 Driver，再由 Driver 合并来自各个分区的所有单词计数，形成最终的单词计数。","categories":[{"name":"2023","slug":"2023","permalink":"http://example.com/categories/2023/"}],"tags":[{"name":"Spark","slug":"Spark","permalink":"http://example.com/tags/Spark/"}]},{"title":"UML类图 & UML时序图","slug":"UML类图-&-UML时序图","date":"2023-03-20T08:08:25.851Z","updated":"2023-03-20T08:08:25.852Z","comments":true,"path":"2023/03/20/UML类图-&-UML时序图/","link":"","permalink":"http://example.com/2023/03/20/UML%E7%B1%BB%E5%9B%BE-&-UML%E6%97%B6%E5%BA%8F%E5%9B%BE/","excerpt":"","text":"2.1 UML图2.1 UML类图 &amp; UML时序图统一建模语言（Unified Modeling Language，UML）是用来设计软件的可视化建模语言。它的特点是简单、统一、图形化、能表达软件设计中的动态与静态信息。UML是一种为面向对象系统的产品进行说明、可视化和编制文档的标准语言，独立于任何一种具体的程序设计语言。 1997 年 UML 被国际对象管理组织（OMG）采纳为面向对象的建模语言的国际标准。它的特点是简单、统一、图形化、能表达软件设计中的动态与静态信息。 应用场景 UML 能为软件开发的所有阶段提供模型化和可视化支持。而且融入了软件工程领域的新思想、新方法和新技术，使软件设计人员沟通更简明，进一步缩短了设计时间，减少开发成本。 UML 具有很宽的应用领域。其中最常用的是建立软件系统的模型，但它同样可以用于描述非软件领域的系统，如机械系统、企业机构或业务过程，以及处理复杂数据的信息系统、具有实时要求的工业系统或工业过程等。总之，UML 可以对任何具有静态结构和动态行为的系统进行建模，而且使用于从需求规格描述直至系统完成后的测试和维护等系统开发的各个阶段。 UML 模型大多以图表的方式表现出来，一份典型的建模图表通常包含几个块或框、连接线和作为模型附加信息的文本。这些虽简单却非常重要，在 UML 规则中相互联系和扩展。 语言是包括文字和图形的，有很多内容文字是无法表达的。比如建筑设计图纸吗，里面存在多图形，光用文字并不能表达清楚建筑设计。在建筑界，有一套标准来描述设计，同样道理，在软件开发界，也需要一套标准来帮助我们做好软件开发的工作。UML 就是其中的一种标准，注意这可不是唯一标准，只是 UML 是大家比较推崇的一种标准而已。UML 并不是强制性标准，没有规定在软件开发中一定要用 UML，但是我们需要包括 UML 在内的各种标准，来提高软件开发的水平。 基本构件 UML 建模的核心是模型，模型是现实的简化、真实系统的抽象。UML 提供了系统的设计蓝图。当给软件系统建模时，需要采用通用的符号语言，这种描述模型所使用的语言被称为建模语言。在 UML 中，所有的描述由事物、关系和图这些构件组成。下图完整地描述了所有构件的关系。 事物 事物是抽象化的最终结果，分为结构事物、行为事物、分组事物和注释事物。 结构事物 结构事物是模型中的静态部分，用以呈现概念或实体的表现元素，如下表所示。 行为事物 行为事物指 UML 模型中的动态部分，如下表所示。 分组事物 目前只有一种分组事物，即包。包纯碎是概念上的，只存在于开发阶段，结构事物、行为事物甚至分组事物都有可能放在一个包中，如下表所示。 注释事物 注释事物是解释 UML 模型元素的部分，如下表所示。 UML 从目标系统的不同角度出发，UML2.0 一共有 13 种图（UML1.5 定义了 9 种，UML2.0 增加了 4 种），别是类图、对象图、构件图、部署图、活动图、状态图、用例图、时序图、协作图 9 种，以及包图、组合结构图、时间图、交互概览图 4 种。 在 UML 2.0 的 13 种图中，类图（Class Diagrams）是使用频率最高的 UML 图之一。类图描述系统中的类，以及各个类之间的关系的静态视图，能够让我们在正确编写代码之前对系统有一个全面的认识。类图是一种模型类型，确切地说，是一种静态模型类型。类图表示类、接口和它们之间的协作关系，用于系统设计阶段。 2.1.1 类图概述类图(Class diagram)是显示了模型的静态结构，特别是模型中存在的类、类的内部结构以及它们与其他类的关系等。类图不显示暂时性的信息。类图是面向对象建模的主要组成部分。 2.1.2 类图作用 在软件工程中，类图是一种静态的结构图，描述了系统的类的集合，类的属性和类之间的关系，可以简化了人们对系统的理解； 类图是系统分析和设计阶段的重要产物，是系统编码和测试的重要模型。 2.1.3 类图表示 1.类 ​ 类（Class）是指具有相同属性、方法和关系的对象的抽象，它封装了数据和行为，是面向对象程序设计（OOP）的基础，具有封装性、继承性和多态性等三大特性。 (1) 类名（Name）是一个字符串，例如，Student。 (2) 属性（Attribute）是指类的特性，即类的成员变量。 (3) 操作（Operations）是类的任意一个实例对象都可以使用的行为，是类的成员方法。 在UML类图中，类使用包含类名、属性(field) 和方法(method) 且带有分割线的矩形来表示，比如下图表示一个Employee类，它包含name,age和address这3个属性，以及work()方法。 ​ 属性&#x2F;方法名称前加的加号和减号表示了这个属性&#x2F;方法的可见性，UML类图中表示可见性的符号有三种： +：表示public -：表示private #：表示protected ​ 属性的完整表示方式是： 可见性 名称 ：类型 [ &#x3D; 缺省值] ​ 方法的完整表示方式是： 可见性 名称(参数列表) [ ： 返回类型] 注意： 1，中括号中的内容表示是可选的 2，也有将类型放在变量名前面，返回值类型放在方法名前面 举个例子： ​ 上图Demo类定义了三个方法： method()方法：修饰符为public，没有参数，没有返回值。 method1()方法：修饰符为private，没有参数，返回值类型为String。 method2()方法：修饰符为protected，接收两个参数，第一个参数类型为int，第二个参数类型为String，返回值类型是int。 类图中，需注意以下几点： 抽象类或抽象方法用斜体表示 如果是接口，则在类名上方加 &lt;&gt; 字段和方法返回值的数据类型非必需 静态类或静态方法加下划线 另外一个例子： 请看以下这个类图，类之间的关系是我们需要关注的： 车的类图结构为&lt;&gt;，表示车是一个抽象类； 它有两个继承类：小汽车和自行车；它们之间的关系为实现关系，使用带空心箭头的虚线表示； 小汽车为与SUV之间也是继承关系，它们之间的关系为泛化关系，使用带空心箭头的实线表示； 小汽车与发动机之间是组合关系，使用带实心箭头的实线表示； 学生与班级之间是聚合关系，使用带空心箭头的实线表示； 学生与身份证之间为关联关系，使用一根实线表示； 学生上学需要用到自行车，与自行车是一种依赖关系，使用带箭头的虚线表示； 2. 接口 接口（Interface）是一种特殊的类，它具有类的结构但不可被实例化，只可以被子类实现。它包含抽象操作，但不包含属性。它描述了类或组件对外可见的动作。在 UML 中，接口使用一个带有名称的小圆圈来进行表示。 如下所示是图形类接口的 UML 表示。 3. 类图 类图（ClassDiagram）是用来显示系统中的类、接口、协作以及它们之间的静态结构和关系的一种静态模型。它主要用于描述软件系统的结构化设计，帮助人们简化对软件系统的理解，它是系统分析与设计阶段的重要产物，也是系统编码与测试的重要模型依据。 类图中的类可以通过某种编程语言直接实现。类图在软件系统开发的整个生命周期都是有效的，它是面向对象系统的建模中最常见的图。如下所示是“计算长方形和圆形的周长与面积”的类图，图形接口有计算面积和周长的抽象方法，长方形和圆形实现这两个方法供访问类调用。 2.1.4 类与类之间关系的表示 关联关系(association) 关联关系是用一条直线表示的；它描述不同类的对象之间的结构关系；它是一种静态关系， 通常与运行状态无关，一般由常识等因素决定的；它一般用来定义对象之间静态的、天然的结构； 所以，关联关系是一种“强关联”的关系； 比如，乘车人和车票之间就是一种关联关系；学生和学校就是一种关联关系； 关联关系默认不强调方向，表示对象间相互知道；如果特别强调方向，如下图，表示A知道B，但 B不知道A； 注：在最终代码中，关联对象通常是以成员变量的形式实现的； 关联关系是类与类之间最常用的一种关系，分为一般关联关系、聚合关系和组合关系。我们先介绍一般关联。关联又可以分为单向关联，双向关联，自关联。 a）单项关联 在UML类图中单向关联用一个带箭头的实线表示。上图表示每个顾客都有一个地址，这通过让Customer类持有一个类型为Address的成员变量类实现。 b）双向关联 从上图中我们很容易看出，所谓的双向关联就是双方各自持有对方类型的成员变量。 在UML类图中，双向关联用一个不带箭头的直线表示。上图中在Customer类中维护一个List，表示一个顾客可以购买多个商品；在Product类中维护一个Customer类型的成员变量表示这个产品被哪个顾客所购买。 c）自关联 自关联在UML类图中用一个带有箭头且指向自身的线表示。上图的意思就是Node类包含类型为Node的成员变量，也就是“自己包含自己”。 2. 聚合关系(aggregation)聚合关系是关联关系的一种，是强关联关系，是整体和部分之间的关系。 聚合关系也是通过成员对象来实现的，其中成员对象是整体对象的一部分，但是成员对象可以脱离整体对象而独立存在。例如，学校与老师的关系，学校包含老师，但如果学校停办了，老师依然存在。 聚合关系用一条带空心菱形箭头的直线表示，如下图表示A聚合到B上，或者说B由A组成； 下图所示是大学和教师的关系图： 3. 组合关系(composition)组合表示类之间的整体与部分的关系，但它是一种更强烈的聚合关系。 在组合关系中，整体对象可以控制部分对象的生命周期，一旦整体对象不存在，部分对象也将不存在，部分对象不能脱离整体对象而存在。例如，头和嘴的关系，没有了头，嘴也就不存在了。 在 UML 类图中，组合关系用带实心菱形的实线来表示，菱形指向整体。如下图表示A组成B，或者B由A组成； 下图所示是头和嘴的关系图： 与聚合关系一样，组合关系同样表示整体由部分构成的语义；比如公司由多个部门组成； 但组合关系是一种强依赖的特殊聚合关系，如果整体不存在了，则部分也不存在了；例如， 公司不存在了，部门也将不存在了； 4. 依赖关系(dependency)依赖关系是一种使用关系，它是对象之间耦合度最弱的一种关联方式，是临时性的关联。在代码中，某个类的方法通过局部变量、方法的参数或者对静态方法的调用来访问另一个类（被依赖类）中的某些方法来完成一些职责。 在 UML 类图中，依赖关系使用带箭头的虚线来表示，箭头从使用类指向被依赖的类。如下图表示A依赖于B；他描述一个对象在运行期间会用到另一个对象的关系； 下图所示是司机和汽车的关系图，司机驾驶汽车： 与关联关系不同的是，它是一种临时性的关系，通常在运行期间产生，并且随着运行时的变化； 依赖关系也可能发生变化； 显然，依赖也有方向，双向依赖是一种非常糟糕的结构，我们总是应该保持单向依赖，杜绝双向依赖的产生； 注：在最终代码中，依赖关系体现为类构造方法及类方法的传入参数，箭头的指向为调用关系；依赖关系除了临时知道对方外，还是“使用”对方的方法和属性； 5. 继承关系&#x2F;泛化关系(generalization)继承关系是对象之间耦合度最大的一种关系，表示一般与特殊的关系，是父类与子类之间的关系，是一种继承关系。类的继承结构表现在UML中为：泛化(generalize)与实现(realize)： 继承关系为 is-a的关系；两个对象之间如果可以用 is-a 来表示，就是继承关系：（..是..) eg：自行车是车、猫是动物 在 UML 类图中，泛化关系用带空心三角箭头的实线来表示，箭头从子类指向父类。如下图表示（A继承自B）； 例如，汽车在现实中有实现，可用汽车定义具体的对象；汽车与SUV之间为泛化关系； 再比如，Student 类和 Teacher 类都是 Person 类的子类，其类图如下图所示： 注：最终代码中，泛化关系表现为继承非抽象类； 6. 实现关系(realize)实现关系是接口与实现类之间的关系。在这种关系中，类实现了接口，类中的操作实现了接口中所声明的所有的抽象操作。 在 UML 类图中，实现关系使用带空心三角箭头的虚线来表示，箭头从实现类指向接口。 比如：”车”为一个抽象概念，在现实中并无法直接用来定义对象；只有指明具体的子类(汽车还是自行车)，才 可以用来定义对象（”车”这个类在C++中用抽象类表示，在JAVA中有接口这个概念，更容易理解） 再例如，汽车和船实现了交通工具，其类图如图 9 所示。 注：最终代码中，实现关系表现为继承抽象类； 类关系记忆技巧如下表所示。 注意：UML 的标准类关系图中，没有实心箭头。有些 Java 编程的 IDE 自带类生成工具可能出现实心箭头，主要目的是降低理解难度。 下面用一个经典案例来加深和巩固对类图的理解。下图是对动物衍生关系描述的类图。这个图非常有技术含量也非常经典，大家可以好好理解一下。 2.1.5 时序图为了展示对象之间的交互细节，后续对设计模式解析的章节，都会用到时序图； 时序图（Sequence Diagram）是显示对象之间交互的图，这些对象是按时间顺序排列的。时序图中显示的是参与交互的对象及其对象之间消息交互的顺序。 时序图包括的建模元素主要有：对象（Actor）、生命线（Lifeline）、控制焦点（Focus of control）、消息（Message）等等。 角色（Actor）： 系统角色，可以是人、及其甚至其他的系统或者子系统。 对象（Object）： 对象包括三种命名方式： 第一种方式包括对象名和类名； 第二中方式只显示类名不显示对象名，即表示他是一个匿名对象； 第三种方式只显示对象名不显示类明。 生命线（Lifeline）： 生命线在顺序图中表示为从对象图标向下延伸的一条虚线，表示对象存在的时间，如下图 控制焦点（Focus of Control）： 控制焦点是顺序图中表示时间段的符号，在这个时间段内对象将执行相应的操作。用小矩形表示，如下图。 消息（Message）： 消息一般分为同步消息（Synchronous Message），异步消息（Asynchronous Message）和返回消息（Return Message）.如下图所示： 同步消息&#x3D;调用消息（Synchronous Message）： 消息的发送者把控制传递给消息的接收者，然后停止活动，等待消息的接收者放弃或者返回控制。用来表示同步的意义。 异步消息（Asynchronous Message）： 消息发送者通过消息把信号传递给消息的接收者，然后继续自己的活动，不等待接受者返回消息或者控制。异步消息的接收者和发送者是并发工作的。 返回消息（Return Message）： 返回消息表示从过程调用返回 自关联消息（Self-Message）： 表示方法的自身调用以及一个对象内的一个方法调用另外一个方法。 组合片段示例： Alternative fragment（denoted “alt”） 与 if…then…else对应 Option fragment (denoted “opt”) 与 Switch对应 Parallel fragment (denoted “par”) 表示同时发生 Loop fragment(denoted “loop”) 与 for 或者 Foreach对应 时序图实例分析（Sequece Diagram Example Analysis） 完成课程创建功能，主要流程有： 1、请求添加课程页面，填写课程表单，点击【create】按钮 2、添加课程信息到数据库 3、向课程对象追加主题信息 4、为课程指派教师 5、完成课程创建功能 1、序号1.0-1.3 完成页面的初始化 2、序号1.4-1.5 课程管理员填充课程表单 3、序号1.6-1.7 课程管理员点击【Create】按钮，并响应点击事件 4、序号1.8 Service层创建课程 5、序号1.9-1.10 添加课程到数据库，并返回课程编号CourseId 6、序号1.11-1.12 添加课程主题到数据库，并返回主题编号topicId 7、序号1.13 给课程指派教师 8、序号1.14 向界面抛创建课程成功与否的消息","categories":[{"name":"2023","slug":"2023","permalink":"http://example.com/categories/2023/"}],"tags":[{"name":"设计模式","slug":"设计模式","permalink":"http://example.com/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"}]},{"title":"Python类","slug":"Python类","date":"2023-03-20T04:58:38.022Z","updated":"2023-03-20T07:04:48.617Z","comments":true,"path":"2023/03/20/Python类/","link":"","permalink":"http://example.com/2023/03/20/Python%E7%B1%BB/","excerpt":"","text":"Python类类(class) 和 对象(object)类：创建对象的模板，定义对象将会拥有的属性和函数 __init__函数：每个类必须定义的函数，对象创建语句时自动执行 123456789class myday: #建立一个类模板 def __init__(): .....day1 = myday() #创建一个myday类的对象 python类类名：mayday属性：name和emotion函数：init函数，wake函数，eat函数 1234567891011121314151617181920# 类(class)class myday: def __init__(self): #每个类必须定义(def) __init__函数，每个函数第一参数都是self self.name = &quot;Xiao Ming&quot; #myday对象拥有属性name和emotion self.emotion = &quot;happy&quot; def wake(self,event): if event == &quot;上课&quot;: self.emotion = &quot;still happy&quot; def eat(self, food): if food == &quot;牛肉&quot;: self.emotion = &quot;more happy&quot; #def __eq__(self,other): #return self.name == other.nameday2 = myday()#创建对象时会自动执行__init__方法print(day2.emotion)print(day2.name) __init__函数添加参数 创建对象时传入self之后的参数 12345678910111213141516171819class myday: def __init__(self,name,emotion): self.emotion = emotion #定义对象属性“self.emotion”，将这个属性赋值为函数传入的参数“emotion” self.name = name def wake(self,event): if event == &quot;上课&quot;: self.emotion = &quot;still happy&quot; def eat(self, food): if food == &quot;牛肉&quot;: self.emotion = &quot;more happy&quot; #def __eq__(self,other): #return self.name == other.nameday2 = myday(&quot;me&quot;,&quot;very happy&quot;)#创建对象时会自动执行__init__函数print(day2.name)print(day2.emotion) 1234567891011121314151617181920212223class myday: def __init__(self,name,emotion): self.emotion = emotion #定义对象属性“self.emotion”，将这个属性赋值为函数传入的参数“emotion” self.name = name def wake(self,event): if event == &quot;上课&quot;: self.emotion = &quot;still happy&quot; def eat(self, food): if food == &quot;牛肉&quot;: self.emotion = &quot;more happy&quot; #def __eq__(self,other): #return self.name == other.nameday2 = myday(&quot;me&quot;,&quot;very happy&quot;)#调用对象函数时，从self之后的参数开始传入day2.eat(&quot;jiaozi&quot;)print(day2.emotion)day2.eat(&quot;牛肉&quot;)print(day2.emotion) 任务：编写一个类继承myday类12345678910111213141516171819202122232425262728293031323334class myday: def __init__(self,name,emotion): self.emotion = emotion #定义对象属性“self.emotion”，将这个属性赋值为函数传入的参数“emotion” self.name = name def wake(self,event): if event == &quot;上课&quot;: self.emotion = &quot;still happy&quot; def eat(self, food): if food == &quot;牛肉&quot;: self.emotion = &quot;more happy&quot; #def __eq__(self,other): #return self.name == other.nameday2 = myday(&quot;me&quot;,&quot;very happy&quot;)#创建对象时，程序会自动执行__init__函数day2.eat(&quot;jiaozi&quot;)print(day2.emotion)day2.eat(&quot;牛肉&quot;)print(day2.emotion)#类的继承 和 函数重写class night(myday): #night类继承myday类 def __init__(self): self.emotion = &quot;nice&quot; self.name = &quot;me&quot; def play(self): self.emotion = &quot;so nice&quot;night1 = night()night1.eat(&quot;羊肉&quot;) #night继承myday类除__init__之外的函数print(night1.emotion)night1.eat(&quot;牛肉&quot;)print(night1.emotion) 一个类是否等于另一个类？1234567day1 = myday(&quot;a&quot;,&quot;happy&quot;)day2 = myday(&quot;a&quot;,&quot;happy&quot;)day1.name == day2.name #True or Falseday1 == day2 #True or False?#（如果我们在类里定义一个__eq__函数，当我们执行 day1 == day2语句的时候，程序会自动执行__eq__函数） 多线程开发案例123456789101112131415161718192021import timeimport threadingclass TestThread(threading.Thread): def __init__(self, para=&#x27;hi&#x27;, sleep=3): super().__init__() self.para = para self.sleep = sleep def run(self): &quot;&quot;&quot;线程内容&quot;&quot;&quot; time.sleep(self.sleep) print(self.para)thread_hi = TestThread()thread_hello = TestThread(&#x27;hello&#x27;, 1) # 启动线程thread_hi.start()thread_hello.start() 任务！：按照如下描述定义一个类，代表一个企业class company: init函数：定义资金（money)属性，产品(product)属性和价格（price）属性 register函数：公司注册，修改资金属性 produce函数：制造，修改资金属性，修改产品属性 sale函数：销售，修改资金属性和产品属性 research函数：研发，修改资金属性和价格属性 任务！：定义另一个类，继承company类，重写research函数（子类需要添加至少一个新的函数，并重写至少一个父类的函数。） 12345678910111213141516171819class company: def __init__(self,money,product,price) : self.money=money self.product=product self.price=price def register(self,tol_money):#注册资金 self.money=tol_money def produce(self,pro_money,product_num): self.money-=pro_money#生产就减少了 self.product+=product_num#产品多了 def sale(self,sal_money,product_num): self.money+=sal_money#钱多了 self.product-=product_num#产品减少了 def research(self,re_money,re_price): self.money-=re_money#钱减少了 self.price+=re_price#价格上去了company1=company(&quot;1000&quot;,&quot;机器&quot;,&quot;100/2&quot;)company1.register(&quot;5000&quot;)print(company1.money) research函数：研发，修改资金属性和价格属性，产品属性 invert函数:投资，修改金钱属性 12345678910111213141516class BigCompany(company): def __init__(self,money,product,price): super().__init__(money,product,price) def research(self,re_money,re_price,re_prodcut): self.money=re_money#钱减少了 self.price+=re_price#价格上去了 self.product+=re_prodcut#产品多了 def inverst(self,invstment_money): self.money-=invstment_moneycompany2=BigCompany(7000,2,50)company2.research(8000,80,90)company2.inverst(908070)print(company2.money)","categories":[{"name":"2023","slug":"2023","permalink":"http://example.com/categories/2023/"}],"tags":[{"name":"python","slug":"python","permalink":"http://example.com/tags/python/"}]},{"title":"如何在Linux系统下编译C++","slug":"如何在Linux系统下编译C++","date":"2023-03-17T13:50:45.280Z","updated":"2023-03-17T14:05:29.847Z","comments":true,"path":"2023/03/17/如何在Linux系统下编译C++/","link":"","permalink":"http://example.com/2023/03/17/%E5%A6%82%E4%BD%95%E5%9C%A8Linux%E7%B3%BB%E7%BB%9F%E4%B8%8B%E7%BC%96%E8%AF%91C++/","excerpt":"","text":"如何在Linux系统下编译C++方法一:12345678#include&lt;iostream&gt;#include&lt;cstdio&gt;using namespace std;int main()&#123; cout&lt;&lt;&quot;hello_word&quot;; return 0;&#125; 编译 1gcc 1.cpp -lstdc++ 生a.out文件 运行a.out 1./a.out 方法二:12345678#include&lt;iostream&gt;#include&lt;cstdio&gt;using namespace std;int main()&#123; cout&lt;&lt;&quot;hello_word222&quot;; return 0;&#125; 编译 1g++ 2.cpp -o 2output 运行2output 1./2output","categories":[{"name":"2023","slug":"2023","permalink":"http://example.com/categories/2023/"}],"tags":[{"name":"linux_c++","slug":"linux-c","permalink":"http://example.com/tags/linux-c/"}]},{"title":"操作系统——进程同步——生产者消费者问题","slug":"进程同步","date":"2023-03-17T03:21:38.374Z","updated":"2023-03-24T00:36:45.212Z","comments":true,"path":"2023/03/17/进程同步/","link":"","permalink":"http://example.com/2023/03/17/%E8%BF%9B%E7%A8%8B%E5%90%8C%E6%AD%A5/","excerpt":"","text":"进程同步 pv 操作 互斥锁 1234P --wait(信号量S)&#123; S&lt;=0 S-- //上锁&#125; 成对出现 123V --signal(信号量)&#123; S++ //开锁&#125; 生产者 123456789101112131415int in(),out=();item butter[n];semaphore mutex=1,empty=n,full=();//mutex必须为1 ,empty空位置,full有多少个void proceducer()&#123; do&#123; producer an item nextp; …… wait(empty); //enpty-- wait(mutex); //上锁 butter[in]=nextp; //生产一个 in:=(in+1)%n; // 生产一个 signal(mutex); //解锁 signal(full); //full++ &#125;while(TRUE)；&#125; 消费者 1234567891011void consumer()&#123; do&#123; wait(full)； //full-1 wait(mutex); //上锁 nextc=butter[out]; //消费一个 out=(out+1)%n; //消费一个 signal(mutex); //解锁 signal(empty); //empty++ consumer the item in nextc; &#125;while(TRUE);&#125; 12345void main()&#123; cobegin proceducer();consumer(); coend&#125; 第1关：生产者消费者同步控制任务描述本关任务：编写生产者消费者同步控制程序。 相关知识为了完成本关任务，你需要掌握：1.理解生产者消费者同步问题，2.线程的编写方法，3.使用信号量实现线程间同步控制。 线程并发引起的同步问题线程以并发形式运行，当并发的线程间访问共享数据时，会发后争用现象，不进行同步控制的线程运行会造成不恰当的结果。 生产者消费者同步问题生产者消费者是典型的同步问题，他们共享了一个缓冲池(全局变量数组)，当缓冲池有空位时生产者线程向缓冲池中依次赋值，如果缓冲池满则等待。当缓冲池中有数据时消费者线程从中取走数据，如果缓冲池空则等待。 如何解决线程间访问共享变量的冲突问题当多个线程访问同一个共享变量时，共享变量成为临界资源，它需要操作系统提供同步控制机制，以保证多个线程可以依序访问，当一个线程操作临界资源时其它线程不会中断其操作，因此对临界资源的操作是安全的。 下面是linux平台使用信号量的头文件和方法。 #include &lt;semaphore.h&gt; int sem_init(sem_t * sem, int pshared, unsigned int value);&#x2F;&#x2F;创建信号量变量，value是信号量的初值 int sem_destroy(sem_t *sem);&#x2F;&#x2F;销毁信号量 int sem_post(sem_t * sem); &#x2F;&#x2F;信号量值增加1，并激活处于等待状态的线程 int sem_wait(sem_t * sem); &#x2F;&#x2F;信号量值减少1 为0时将调用该方法的线程被OS阻塞 编程要求主线程序启动生产者线程和消费者线程，并等待两个线程的结束。 两个线程使用三个信号量，其中生产者线程向全局变量进行十次赋值(代表生产)，每次赋值前都要检查是否有空位，有空位的情况下 需要获得互斥量sem_mutex，并对共享缓冲区进行赋值，然后释放互斥量以便消费者线程可以操作缓冲区临界资源。 消费者线程要从缓冲区取值，取值前先检查是否有可用数据，有可用数据的情况下再获得互斥量sem_mutex，再取出缓冲区的值。 要特别说明的是生产者和消费者线程工作的速率是不同的，但在同步信号控制下，两个线程节奏互相配合步调一致。在《计算机操作系统》 教材中使用了伪代码，并且循环体没有结束条件，在此用C语言改写原程序，生产者一共只生产十个数据。 ####测试说明 为简化数据操作，程序没有输入，主线程已经写好， void * producer(void * arg); void * consumer(void * arg); static sem_t sem_empty;&#x2F;&#x2F;空位个数 static sem_t sem_full; &#x2F;&#x2F;可用数据个数 static sem_t sem_mutex; &#x2F;&#x2F;互斥量，用于控制两个线程互斥访问缓冲区 static int buffer[]&#x3D;{0,0,0}; int main(int argc,char * argv[]) { pthread_t id_prod,id_consum; sem_init(&amp;sem_empty,0,3); &#x2F;&#x2F;初值为3，空位为3， sem_init(&amp;sem_full,0,0); &#x2F;&#x2F;初值为0，可用数据个数为0， sem_init(&amp;sem_mutex,0,1); &#x2F;&#x2F;初值为1，用于控制两个线程互斥访问缓冲区 pthread_create(&amp;id_prod, NULL,producer,NULL);&#x2F;&#x2F;创建生产者线程 pthread_create(&amp;id_consum,NULL,consumer,NULL);&#x2F;&#x2F;创建消费者线程 pthread_join(id_prod,NULL); &#x2F;&#x2F;主线程等待生产者线程结束 pthread_join(id_consum,NULL);&#x2F;&#x2F;主线程等待消费者线程结束 sem_destroy(&amp;sem_empty); sem_destroy(&amp;sem_full); sem_destroy(&amp;sem_mutex); return 0; } 学生需要补充producer线程与consumer中关于同步控制部分的程序。 输出：1至10 (需由学生根据程序生成正确结果) 开始你的任务吧，祝你成功！ 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667//stu001.c 生产者消费者同步控制，由学生完成缺失代码。 //主线程序启动生产者线程和消费者线程，全局变量初值为0//生产者线程向全局变量进行10次赋值(代表生产)，消费者线程从全局变量读取值，///并重新赋值0(代表消费了产品)#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt; #include &lt;pthread.h&gt;#include &lt;semaphore.h&gt; void * producer(void * arg);void * consumer(void * arg);static sem_t sem_empty;//空位个数static sem_t sem_full; //可用数据个数static sem_t sem_mutex; //互斥量，用于控制两个线程互斥访问缓冲区static int buffer[]=&#123;0,0,0&#125;;//共享的缓冲区int main(int argc,char * argv[])&#123; pthread_t id_prod,id_consum; sem_init(&amp;sem_empty,0,3); //初值为3，空位为3， sem_init(&amp;sem_full,0,0); //初值为0，可用数据个数为0， sem_init(&amp;sem_mutex,0,1); //初值为1，用于控制两个线程互斥访问缓冲区 pthread_create(&amp;id_prod, NULL,producer,NULL);//创建生产者线程 pthread_create(&amp;id_consum,NULL,consumer,NULL);//创建消费者线程 pthread_join(id_prod,NULL); //主线程等待生产者线程结束 pthread_join(id_consum,NULL);//主线程等待消费者线程结束 sem_destroy(&amp;sem_empty); sem_destroy(&amp;sem_full); sem_destroy(&amp;sem_mutex); return 0;&#125;void * producer(void * arg)&#123; int i,pIndex=0; for(i=11;i&lt;21;i++) &#123; //请在begin end语句间补全程序语句实现生产者向缓冲区赋值操作 /* begin *******************程序代码约六行******************************* */ sem_wait(&amp;sem_empty);//empty-- sem_wait(&amp;sem_mutex); //枷锁 buffer[pIndex]=i; //缓冲区只有三个位置 pIndex=(pIndex+1)%3;// 11-- 0 12--1 13--2 14--0 15--1 16--2 sem_post(&amp;sem_mutex);//解锁 sem_post(&amp;sem_full);//full++ /* end ************************************************************** */ &#125; return NULL;&#125;void * consumer(void *arg)&#123; int i,cIndex=0; for(i=11;i&lt;21;i++) &#123; //请在begin end语句间补全程序语句实现扫描算法，算出总访问磁道数存入totaltracks变量 /* begin *******************程序代码约六行******************************* */ sem_wait(&amp;sem_full);//full-- sem_wait(&amp;sem_mutex);//枷锁 printf(&quot;%d,&quot;,buffer[cIndex]); cIndex=(cIndex+1)%3;//与上面对应 sem_post(&amp;sem_mutex);//解锁 sem_post(&amp;sem_empty);//empty++ /* end ************************************************************** */ &#125; return NULL;&#125; 参考Linux下c++的东西 https://man7.org/linux/man-pages/man3/sem_wait.3.html 123sem_wait是一个函数，也是一个原子操作，它的作用是从信号量的值减去一个“1”，但它永远会先等待该信号量为一个非零值才开始做减法。也就是说，如果你对一个值为2的信号量调用sem_wait()，线程将会继续执行，将信号量的值将减到1。如果对一个值为0的信号量调用sem_wait()，这个函数就会原地等待直到有其它线程增加了这个值使它不再是0为止。如果有两个线程都在sem_wait()中等待同一个信号量变成非零值，那么当它被第三个线程增加 一个“1”时，等待线程中只有一个能够对信号量做减法并继续执行，另一个还将处于等待状态。sem_trywait(sem_t *sem)是函数sem_wait的非阻塞版，它直接将信号量sem减1，同时返回错误代码。(不得不说，百度确实蛮会复制粘贴翻译的，只不过没有那个网站格式做的好hhh) 1sem_post是给信号量的值加上一个“1”，它是一个“原子操作”－－－即同时对同一个信号量做加“1”操作的两个线程是不会冲突的；而同 时对同一个文件进行读和写操作的两个程序就有可能会引起冲突。 1sem_t C语言中，信号量的数据类型为结构sem_t，它本质上是一个长整型的数。 https://blog.51cto.com/u_13999641/4314815 没看完【argc，argv是什么】 真的忘的差不多了0.0","categories":[{"name":"2023","slug":"2023","permalink":"http://example.com/categories/2023/"}],"tags":[{"name":"操作系统","slug":"操作系统","permalink":"http://example.com/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"}]},{"title":"java数据类型","slug":"java数据类型","date":"2023-03-16T14:06:57.039Z","updated":"2023-03-20T07:57:15.646Z","comments":true,"path":"2023/03/16/java数据类型/","link":"","permalink":"http://example.com/2023/03/16/java%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/","excerpt":"","text":"Java数据类型定义Java语言是强类型语言，对于每一种数据都定义了明确的具体的数据类型，在内存中分配了不同大小的内存空间。 分类 基本数据类型 数值型 整数类型(byte,short,int,long) 浮点类型(float,double) 字符型(char) 布尔型(boolean) 引用数据类型 类(class) 接口(interface) 数组([]) 计算机存储单元 定义：变量是内存中的小容器，用来存储数据。那么计算机内存是怎么存储数据的呢？无论是内存还是硬盘，计算机存储设备的最小信息单元叫“位（bit）”，我们又称之为“比特位”，通常用小写的字母b表示。而计算机最小的存储单元叫“字节（byte）”，通常用大写字母B表示，字节是由连续的8个位组成。 常用存储单元关系 1B&#x3D; 8b1KB &#x3D; 1024B1MB &#x3D; 1024KB1GB &#x3D; 1024MB1TB &#x3D; 1024GB Java基本数据类型图 定义 数据类型的转换是在所赋值的数值类型和被变量接收的数据类型不一致时发生的，它需要从一种数据类型转换成另一种数据类型。 分类 隐式转换 定义 在运算过程中，由于不同的数据类型会转换成同一种数据类型，所以整型、浮点型以及字符型都可以参与混合运算。自动转换的规则是从低级类型数据转换成高级类型数据。 转换规则 数值型数据的转换：byte→short→int→long→float→double。 字符型转换为整型：char→int。 转换条件 自动类型转换的实现需要同时满足两个条件：①两种数据类型彼此兼容，②目标类型的取值范围大于源数据类型（低级类型数据转换成高级类型数据）。例如 byte 类型向 short 类型转换时，由于 short 类型的取值范围较大，会自动将 byte 转换为 short 类型。 显式转换 定义 当两种数据类型不兼容，或目标类型的取值范围小于源类型时，自动转换将无法进行，这时就需要进行强制类型转换。 语法格式 目标类型 变量名 &#x3D; (目标类型) (被转换的数据);举例：int b &#x3D; (byte)(a + b); 注意 如果超出了被赋值的数据类型的取值范围得到的结果会与你期望的结果不同 不建议强制转换，因为会有精度的损失。","categories":[{"name":"2023","slug":"2023","permalink":"http://example.com/categories/2023/"}],"tags":[{"name":"java","slug":"java","permalink":"http://example.com/tags/java/"}]},{"title":"3-15-2023","slug":"3-15-2023","date":"2023-03-15T14:51:14.942Z","updated":"2023-03-15T14:59:29.047Z","comments":true,"path":"2023/03/15/3-15-2023/","link":"","permalink":"http://example.com/2023/03/15/3-15-2023/","excerpt":"三月中自我崩溃","text":"三月中自我崩溃 1.每日单词 考试周，复习无进展，极度自我焦虑, 看的上海的学校今年分数下来了， 崩溃，高了40分，崩溃,换学校， 觉得三年青春换水硕不值 转战留学","categories":[{"name":"2023","slug":"2023","permalink":"http://example.com/categories/2023/"}],"tags":[{"name":"casual_talk","slug":"casual-talk","permalink":"http://example.com/tags/casual-talk/"}]},{"title":"设计模式homework(1)","slug":"设计模式homework(1)","date":"2023-03-15T09:56:02.491Z","updated":"2023-03-20T07:53:52.155Z","comments":true,"path":"2023/03/15/设计模式homework(1)/","link":"","permalink":"http://example.com/2023/03/15/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8Fhomework(1)/","excerpt":"","text":"2023_Week1_Exp_Upload1. (简答题)用 UMLet 工具对下面代码绘制类图 【关联关系】：是一种拥有的关系，它使一个类知道另一个类的属性和方法 【代码体现】：成员变量 【箭头及指向】：带普通箭头的实心线，指向被拥有者 1.上图中，课程与学生是双向关联，课程有多名学生，学生也可能有多个课程。 2.但学生与成绩间的关系为单向关联，一名学生可能要有多门成绩，成绩有学生信息，但学生类不拥有成绩变量 3.【组合关系】：是整体与部分的关系，但部分不能离开整体而单独存在。如公司和部门是整体和部分的关系，没有公司就不存在部门。 组合关系是关联关系的一种，是比聚合关系还要强的关系，它要求普通的聚合关系中代表整体的对象负责代表部分的对象的生命周期。 【代码体现】：成员变量 【箭头及指向】：带实心菱形的实线，菱形指向整体 上图中课程为整体，成绩没有课程就不存在。 4.【依赖关系】：是一种使用的关系，即一个类的实现需要另一个类的协助，所以要尽量不使用双向的互相依赖. 【代码表现】：局部变量、方法的参数或者对静态方法的调用 【箭头及指向】：带箭头的虚线，指向被使用者 一个宿舍类的实现需要另一个学生类的协助，宿舍是被使用者","categories":[{"name":"2023","slug":"2023","permalink":"http://example.com/categories/2023/"}],"tags":[{"name":"设计模式","slug":"设计模式","permalink":"http://example.com/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"}]},{"title":"UML&&面向对象设计原则","slug":"UML类图&&原则概述","date":"2023-03-15T09:32:42.087Z","updated":"2023-03-15T09:33:49.550Z","comments":true,"path":"2023/03/15/UML类图&&原则概述/","link":"","permalink":"http://example.com/2023/03/15/UML%E7%B1%BB%E5%9B%BE&&%E5%8E%9F%E5%88%99%E6%A6%82%E8%BF%B0/","excerpt":"","text":"一、单一职责原则**就一个类而言，应该仅有一个引起它变化的原因。 如果一个类承担的职责过多，就等于把这些职责耦合在一起，一个职责的变化可能会削弱或者抑制这个类完成其他职责的能力。这种耦合会导致脆弱他的设计，当变化发生时，设计会遭受到意想不到的破坏；软件设计真正要做的许多内容就是发现职责并把那些职责相互分离。 二、开放-封闭原则软件实体应该可以扩展，但不可修改。该原则是面向对象设计的核心所在，遵循这个原则可以带来面向对象技术所声称的可维护、可扩展、可复用、灵活性好。 设计人员必须对于他设计的模块应该对哪种变化封闭做出选择，必须先猜测出最有可能发生的变化种类，然后构造抽象来隔离那些变化。最初编写程序时假设变化不会发生，当变化发生时，就创建抽象来隔离以后发生的同类变化，拒绝不成熟的抽象。 三、里氏代换原则子类型必须能够替换掉它们的父类型。由于子类型的可替换性才使得使用父类类型的模块在无需修改的情况下就可以扩展。 四、依赖倒转原则高层模块不应该依赖低层模块，两个都应该依赖抽象；抽象不应该依赖细节，细节应该依赖抽象。 要针对接口编程，不要针对实现编程。该原则可以说是面向对象设计的标志，编写时考虑的是如何对抽象编程而不是针对细节编程，即程序中所有的依赖关系都是终止于抽象类或者接口。 五、迪迷特原则（最少知识原则）如果两个类不必彼此直接通信，那么这两个类就不应当发生直接的相互作用；如果其中一个类需要调用另一个类的某一个方法的话，可以通过第三者转发这个调用。 该原则其根本思想，是强调了类之间的松耦合；类之间的耦合越弱，越利于复用，一个处在弱耦合的类被修改，不会对有关系的类造成波及。在类的结构设计上，每一个类都应当尽量降低成员的访问权限。 六、合成&#x2F;聚合复用原则尽量使用合成&#x2F;聚合，尽量不要使用类继承。 聚合表示一种弱的“拥有”关系，体现的是A对象可以包含B对象，但B对象不是A对象的一部分；合成则是一种强的“拥有”关系，体现了严格的部分和整体的关系，部分和整体的生命周期一样。 优先使用对象的合成&#x2F;聚合将有助于你保持每个类被封装，并被击中在单个任务上，这样类和类继承层次会保持较小规模，并且不太可能增长为不可控制的庞然大物。 七、UML例图‘+’表示public，‘-’表示private，‘#’表示protected； 接口顶端有《interface》显示，只有两行；同时另一个表示方法为棒棒糖表示法； 聚合表示一种弱的’拥有’关系，体现的是A对象可以包含B对象，但B对象不是A对象的一部分； 合成是一种强的’拥有’关系，体现了严格的部分和整体的关系，部分和整体的生命周期一样； 在UML类图中，常见的有以下几种关系: 泛化（Generalization）, 实现（Realization），关联（Association)，聚合（Aggregation），组合(Composition)，依赖(Dependency) 1. 泛化（Generalization）【泛化关系】：是一种继承关系，表示一般与特殊的关系，它指定了子类如何特化父类的所有特征和行为。例如：老虎是动物的一种，即有老虎的特性也有动物的共性。 【箭头指向】：带三角箭头的实线，箭头指向父类 2. 实现（Realization）【实现关系】：是一种类与接口的关系，表示类是接口所有特征和行为的实现. 【箭头指向】：带三角箭头的虚线，箭头指向接口 3. 关联（Association)【关联关系】：是一种拥有的关系，它使一个类知道另一个类的属性和方法；如：老师与学生，丈夫与妻子关联可以是双向的，也可以是单向的。双向的关联可以有两个箭头或者没有箭头，单向的关联有一个箭头。 【代码体现】：成员变量 【箭头及指向】：带普通箭头的实心线，指向被拥有者 上图中，老师与学生是双向关联，老师有多名学生，学生也可能有多名老师。但学生与某课程间的关系为单向关联，一名学生可能要上多门课程，课程是个抽象的东西他不拥有学生。 下图为自身关联： 4. 聚合（Aggregation）【聚合关系】：是整体与部分的关系，且部分可以离开整体而单独存在。如车和轮胎是整体和部分的关系，轮胎离开车仍然可以存在。 聚合关系是关联关系的一种，是强的关联关系；关联和聚合在语法上无法区分，必须考察具体的逻辑关系。 【代码体现】：成员变量 【箭头及指向】：带空心菱形的实心线，菱形指向整体 5. 组合(Composition)【组合关系】：是整体与部分的关系，但部分不能离开整体而单独存在。如公司和部门是整体和部分的关系，没有公司就不存在部门。 组合关系是关联关系的一种，是比聚合关系还要强的关系，它要求普通的聚合关系中代表整体的对象负责代表部分的对象的生命周期。 【代码体现】：成员变量 【箭头及指向】：带实心菱形的实线，菱形指向整体 6. 依赖(Dependency)【依赖关系】：是一种使用的关系，即一个类的实现需要另一个类的协助，所以要尽量不使用双向的互相依赖. 【代码表现】：局部变量、方法的参数或者对静态方法的调用 【箭头及指向】：带箭头的虚线，指向被使用者 各种关系的强弱顺序： 泛化 &#x3D; 实现 &gt; 组合 &gt; 聚合 &gt; 关联 &gt; 依赖 下面这张UML图，比较形象地展示了各种类图关系： 创建型1. Factory Method（工厂方法） 意图： 定义一个用于创建对象的接口，让子类决定实例化哪一个类。Factory Method 使一个类的实例化延迟到其子类。 适用性： 当一个类不知道它所必须创建的对象的类的时候。 当一个类希望由它的子类来指定它所创建的对象的时候。 当类将创建对象的职责委托给多个帮助子类中的某一个，并且你希望将哪一个帮助子类是代理者这一信息局部化的时候。 详解：设计模式是什么鬼（工厂方法） 2. Abstract Factory（抽象工厂） 意图： 提供一个创建一系列相关或相互依赖对象的接口，而无需指定它们具体的类。 适用性： 一个系统要独立于它的产品的创建、组合和表示时。 一个系统要由多个产品系列中的一个来配置时。 当你要强调一系列相关的产品对象的设计以便进行联合使用时。 当你提供一个产品类库，而只想显示它们的接口而不是实现时。 详解：设计模式是什么鬼（抽象工厂） 3. Builder（建造者） 意图： 将一个复杂对象的构建与它的表示分离，使得同样的构建过程可以创建不同的表示。 适用性： 当创建复杂对象的算法应该独立于该对象的组成部分以及它们的装配方式时。 当构造过程必须允许被构造的对象有不同的表示时。 详解：设计模式是什么鬼（建造者） 4. Prototype（原型） 意图： 用原型实例指定创建对象的种类，并且通过拷贝这些原型创建新的对象。 适用性： 当要实例化的类是在运行时刻指定时，例如，通过动态装载；或者 为了避免创建一个与产品类层次平行的工厂类层次时；或者 当一个类的实例只能有几个不同状态组合中的一种时。建立相应数目的原型并克隆它们可能比每次用合适的状态手工实例化该类更方便一些。 详解：设计模式是什么鬼（原型） 5. Singleton（单例） 意图： 保证一个类仅有一个实例，并提供一个访问它的全局访问点。 适用性： 当类只能有一个实例而且客户可以从一个众所周知的访问点访问它时。 当这个唯一实例应该是通过子类化可扩展的，并且客户应该无需更改代码就能使用一个扩展的实例时。 详解：设计模式是什么鬼（单例） 结构型6. Adapter Class&#x2F;Object（适配器） 意图： 将一个类的接口转换成客户希望的另外一个接口。Adapter 模式使得原本由于接口不兼容而不能一起工作的那些类可以一起工作。 适用性： 你想使用一个已经存在的类，而它的接口不符合你的需求。 你想创建一个可以复用的类，该类可以与其他不相关的类或不可预见的类（即那些接口可能不一定兼容的类）协同工作。 （仅适用于对象Adapter ）你想使用一些已经存在的子类，但是不可能对每一个都进行子类化以匹配它们的接口。对象适配器可以适配它的父类接口。 详解：设计模式是什么鬼（适配器） 7. Bridge（桥接） 意图： 将抽象部分与它的实现部分分离，使它们都可以独立地变化。 适用性： 你不希望在抽象和它的实现部分之间有一个固定的绑定关系。例如这种情况可能是因为，在程序运行时刻实现部分应可以被选择或者切换。 类的抽象以及它的实现都应该可以通过生成子类的方法加以扩充。这时Bridge 模式使你可以对不同的抽象接口和实现部分进行组合，并分别对它们进行扩充。 对一个抽象的实现部分的修改应对客户不产生影响，即客户的代码不必重新编译。 （C++）你想对客户完全隐藏抽象的实现部分。在C++中，类的表示在类接口中是可见的。 有许多类要生成。这样一种类层次结构说明你必须将一个对象分解成两个部分。Rumbaugh 称这种类层次结构为“嵌套的普化”（nested generalizations ）。 你想在多个对象间共享实现（可能使用引用计数），但同时要求客户并不知道这一点。一个简单的例子便是Coplien 的String 类[ Cop92 ]，在这个类中多个对象可以共享同一个字符串表示（StringRep ）。 详解：设计模式是什么鬼（桥接） 8. Composite（组合） 意图： 将对象组合成树形结构以表示“部分-整体”的层次结构。C o m p o s i t e 使得用户对单个对象和组合对象的使用具有一致性。 适用性： 你想表示对象的部分-整体层次结构。 你希望用户忽略组合对象与单个对象的不同，用户将统一地使用组合结构中的所有对象。 详解：设计模式是什么鬼（组合） 9. Decorator（装饰） 意图： 动态地给一个对象添加一些额外的职责。就增加功能来说，Decorator 模式相比生成子类更为灵活。 适用性： 在不影响其他对象的情况下，以动态、透明的方式给单个对象添加职责。 处理那些可以撤消的职责。 当不能采用生成子类的方法进行扩充时。一种情况是，可能有大量独立的扩展，为支持每一种组合将产生大量的子类，使得子类数目呈爆炸性增长。另一种情况可能是因为类定义被隐藏，或类定义不能用于生成子类。 详解：设计模式是什么鬼（装饰） 10. Facade（外观） 意图： 为子系统中的一组接口提供一个一致的界面，Facade模式定义了一个高层接口，这个接口使得这一子系统更加容易使用。 适用性： 当你要为一个复杂子系统提供一个简单接口时。子系统往往因为不断演化而变得越来越复杂。大多数模式使用时都会产生更多更小的类。这使得子系统更具可重用性，也更容易对子系统进行定制，但这也给那些不需要定制子系统的用户带来一些使用上的困难。Facade 可以提供一个简单的缺省视图，这一视图对大多数用户来说已经足够，而那些需要更多的可定制性的用户可以越过facade层。 客户程序与抽象类的实现部分之间存在着很大的依赖性。引入facade 将这个子系统与客户以及其他的子系统分离，可以提高子系统的独立性和可移植性。 当你需要构建一个层次结构的子系统时，使用facade模式定义子系统中每层的入口点。如果子系统之间是相互依赖的，你可以让它们仅通过facade进行通讯，从而简化了它们之间的依赖关系。 详解：设计模式是什么鬼（门面） 11. Flyweight（享元） 意图： 运用共享技术有效地支持大量细粒度的对象。 适用性： 一个应用程序使用了大量的对象。 完全由于使用大量的对象，造成很大的存储开销。 对象的大多数状态都可变为外部状态。 如果删除对象的外部状态，那么可以用相对较少的共享对象取代很多组对象。 应用程序不依赖于对象标识。由于Flyweight 对象可以被共享，对于概念上明显有别的对象，标识测试将返回真值。 详解：设计模式是什么鬼（享元） 12. Proxy（代理） 意图： 为其他对象提供一种代理以控制对这个对象的访问。 适用性： 在需要用比较通用和复杂的对象指针代替简单的指针的时候，使用Proxy模式。下面是一 些可以使用Proxy 模式常见情况： 远程代理（Remote Proxy ）为一个对象在不同的地址空间提供局部代表。NEXTSTEP[Add94] 使用NXProxy 类实现了这一目的。Coplien[Cop92] 称这种代理为“大使” （Ambassador ）。 虚代理（Virtual Proxy ）根据需要创建开销很大的对象。在动机一节描述的ImageProxy 就是这样一种代理的例子。 保护代理（Protection Proxy ）控制对原始对象的访问。保护代理用于对象应该有不同 的访问权限的时候。例如，在Choices 操作系统[ CIRM93]中KemelProxies为操作系统对象提供 了访问保护。 智能指引（Smart Reference ）取代了简单的指针，它在访问对象时执行一些附加操作。它的典型用途包括： 对指向实际对象的引用计数，这样当该对象没有引用时，可以自动释放它(也称为SmartPointers[Ede92 ] )。 当第一次引用一个持久对象时，将它装入内存。 在访问一个实际对象前，检查是否已经锁定了它，以确保其他对象不能改变它。 详解：设计模式是什么鬼（代理） 行为型13. Interpreter（解释器） 意图： 给定一个语言，定义它的文法的一种表示，并定义一个解释器，这个解释器使用该表示来解释语言中的句子。 适用性： 当有一个语言需要解释执行, 并且你可将该语言中的句子表示为一个抽象语法树时，可使用解释器模式。而当存在以下情况时该模式效果最好： 该文法简单对于复杂的文法, 文法的类层次变得庞大而无法管理。此时语法分析程序生成器这样的工具是更好的选择。它们无需构建抽象语法树即可解释表达式, 这样可以节省空间而且还可能节省时间。 效率不是一个关键问题最高效的解释器通常不是通过直接解释语法分析树实现的, 而是首先将它们转换成另一种形式。例如，正则表达式通常被转换成状态机。但即使在这种情况下, 转换器仍可用解释器模式实现, 该模式仍是有用的。 详解：设计模式是什么鬼（解释器） 14. Template Method（模板方法） 意图： 定义一个操作中的算法的骨架，而将一些步骤延迟到子类中。TemplateMethod 使得子类可以不改变一个算法的结构即可重定义该算法的某些特定步骤。 适用性： 一次性实现一个算法的不变的部分，并将可变的行为留给子类来实现。 各子类中公共的行为应被提取出来并集中到一个公共父类中以避免代码重复。这是Opdyke 和Johnson 所描述过的“重分解以一般化”的一个很好的例子[ OJ93 ]。首先识别现有代码中的不同之处，并且将不同之处分离为新的操作。最后，用一个调用这些新的操作的模板方法来替换这些不同的代码。 控制子类扩展。模板方法只在特定点调用“hook ”操作（参见效果一节），这样就只允许在这些点进行扩展。 详解：设计模式是什么鬼（模板方法） 15. Chain of Responsibility（责任链） 意图： 使多个对象都有机会处理请求，从而避免请求的发送者和接收者之间的耦合关系。将这些对象连成一条链，并沿着这条链传递该请求，直到有一个对象处理它为止。 适用性： 有多个的对象可以处理一个请求，哪个对象处理该请求运行时刻自动确定。 你想在不明确指定接收者的情况下，向多个对象中的一个提交一个请求。 可处理一个请求的对象集合应被动态指定。 详解：设计模式是什么鬼（责任链） 16. Command（命令） 意图： 将一个请求封装为一个对象，从而使你可用不同的请求对客户进行参数化；对请求排队或记录请求日志，以及支持可撤消的操作。 适用性： 抽象出待执行的动作以参数化某对象，你可用过程语言中的回调（call back）函数表达这种参数化机制。所谓回调函数是指函数先在某处注册，而它将在稍后某个需要的时候被调用。Command 模式是回调机制的一个面向对象的替代品。 在不同的时刻指定、排列和执行请求。一个Command对象可以有一个与初始请求无关的生存期。如果一个请求的接收者可用一种与地址空间无关的方式表达，那么就可将负责该请求的命令对象传送给另一个不同的进程并在那儿实现该请求。 支持取消操作。Command的Excute 操作可在实施操作前将状态存储起来，在取消操作时这个状态用来消除该操作的影响。Command 接口必须添加一个Unexecute操作，该操作取消上一次Execute调用的效果。执行的命令被存储在一个历史列表中。可通过向后和向前遍历这一列表并分别调用Unexecute和Execute来实现重数不限的“取消”和“重做”。 支持修改日志，这样当系统崩溃时，这些修改可以被重做一遍。在Command接口中添加装载操作和存储操作，可以用来保持变动的一个一致的修改日志。从崩溃中恢复的过程包括从磁盘中重新读入记录下来的命令并用Execute操作重新执行它们。 用构建在原语操作上的高层操作构造一个系统。这样一种结构在支持事务( transaction)的信息系统中很常见。一个事务封装了对数据的一组变动。Command模式提供了对事务进行建模的方法。Command有一个公共的接口，使得你可以用同一种方式调用所有的事务。同时使用该模式也易于添加新事务以扩展系统。 详解：设计模式是什么鬼（命令模式） 17. Iterator（迭代器） 意图： 提供一种方法顺序访问一个聚合对象中各个元素, 而又不需暴露该对象的内部表示。 适用性： 访问一个聚合对象的内容而无需暴露它的内部表示。 支持对聚合对象的多种遍历。 为遍历不同的聚合结构提供一个统一的接口(即, 支持多态迭代)。 详解：设计模式是什么鬼（迭代器） 18. Mediator（中介者） 意图： 用一个中介对象来封装一系列的对象交互。中介者使各对象不需要显式地相互引用，从而使其耦合松散，而且可以独立地改变它们之间的交互。 适用性： 一组对象以定义良好但是复杂的方式进行通信。产生的相互依赖关系结构混乱且难以理解。 一个对象引用其他很多对象并且直接与这些对象通信,导致难以复用该对象。 想定制一个分布在多个类中的行为，而又不想生成太多的子类。 详解：设计模式是什么鬼（中介） 19. Memento（备忘录） 意图： 在不破坏封装性的前提下，捕获一个对象的内部状态，并在该对象之外保存这个状态。这样以后就可将该对象恢复到原先保存的状态。 适用性： 必须保存一个对象在某一个时刻的(部分)状态, 这样以后需要时它才能恢复到先前的状态。 如果一个用接口来让其它对象直接得到这些状态，将会暴露对象的实现细节并破坏对象的封装性。 详解：设计模式是什么鬼（备忘录） 20. Observer（观察者） 意图： 定义对象间的一种一对多的依赖关系,当一个对象的状态发生改变时, 所有依赖于它的对象都得到通知并被自动更新。 适用性： 当一个抽象模型有两个方面, 其中一个方面依赖于另一方面。将这二者封装在独立的对象中以使它们可以各自独立地改变和复用。 当对一个对象的改变需要同时改变其它对象, 而不知道具体有多少对象有待改变。 当一个对象必须通知其它对象，而它又不能假定其它对象是谁。换言之, 你不希望这些对象是紧密耦合的。 详解：设计模式是什么鬼（观察者） 21. State（状态） 意图： 允许一个对象在其内部状态改变时改变它的行为。对象看起来似乎修改了它的类。 适用性： 一个对象的行为取决于它的状态, 并且它必须在运行时刻根据状态改变它的行为。 一个操作中含有庞大的多分支的条件语句，且这些分支依赖于该对象的状态。这个状态通常用一个或多个枚举常量表示。通常, 有多个操作包含这一相同的条件结构。State模式将每一个条件分支放入一个独立的类中。这使得你可以根据对象自身的情况将对象的状态作为一个对象，这一对象可以不依赖于其他对象而独立变化。 详解：设计模式是什么鬼（状态） 22. Strategy（策略） 意图： 定义一系列的算法,把它们一个个封装起来, 并且使它们可相互替换。本模式使得算法可独立于使用它的客户而变化。 适用性： 许多相关的类仅仅是行为有异。“策略”提供了一种用多个行为中的一个行为来配置一个类的方法。 需要使用一个算法的不同变体。例如，你可能会定义一些反映不同的空间&#x2F;时间权衡的算法。当这些变体实现为一个算法的类层次时[H087] ,可以使用策略模式。 算法使用客户不应该知道的数据。可使用策略模式以避免暴露复杂的、与算法相关的数据结构。 一个类定义了多种行为, 并且这些行为在这个类的操作中以多个条件语句的形式出现。将相关的条件分支移入它们各自的Strategy类中以代替这些条件语句。 详解：设计模式是什么鬼（策略） 23. Visitor（访问者） 意图： 定义一个操作中的算法的骨架，而将一些步骤延迟到子类中。TemplateMethod 使得子类可以不改变一个算法的结构即可重定义该算法的某些特定步骤。 适用性： 一次性实现一个算法的不变的部分，并将可变的行为留给子类来实现。 各子类中公共的行为应被提取出来并集中到一个公共父类中以避免代码重复。这是Opdyke和Johnson所描述过的“重分解以一般化”的一个很好的例子[OJ93]。首先识别现有代码中的不同之处，并且将不同之处分离为新的操作。最后，用一个调用这些新的操作的模板方法来替换这些不同的代码。 控制子类扩展。模板方法只在特定点调用“hook ”操作（参见效果一节），这样就只允许在这些点进行扩展。 详解：设计模式是什么鬼（访问者） 1来源：blog.csdn.net/zsjlovesm521/article/details/94382666","categories":[{"name":"2023","slug":"2023","permalink":"http://example.com/categories/2023/"}],"tags":[{"name":"设计模式","slug":"设计模式","permalink":"http://example.com/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"}]},{"title":"软件体系结构","slug":"软件体系结构","date":"2023-03-15T09:24:47.975Z","updated":"2023-03-15T10:50:24.862Z","comments":true,"path":"2023/03/15/软件体系结构/","link":"","permalink":"http://example.com/2023/03/15/%E8%BD%AF%E4%BB%B6%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84/","excerpt":"","text":"软件体系结构​ 软件体系结构是有关软件系统如何组织的描述。体系结构影响了系统的性能、安全性和可用性。软件工程师可以在给定的体系结构类型中使用不同的体系结构风格和模式，而不同的模式描述了不同的系统类别、构建、连接件及约束。 ​ 软件体系结构脱胎于软件工程．但其形成同时借鉴了计算机体系结构和网络体系结构中很多宝贵的思想和方法。最近几年软件体系结构研究完全独立于软件工程的研究，成为计算机科学的一个最新的研究方向和独立学科分支。 软件体系结构是对系统的高层设计，是从一个较高的层次来考虑组成系统的构建、构建之间的连接关系，以及系统需满足的约束等。设计模式可以用于软件体系结构的设计，以实现体系结构级的设计复用。用于软件体系结构的设计模式通常称为架构模式（Architectural Pattern）或体系机构风格（Architectural Style）。 在《Pattern - Oriented Software Architecture》第一卷中，Buschmann等人根据问题的规模或抽象层次将软件设计模式分为三个层次：架构模式（Architectural Patterns）、设计模式（Design Patterns）和习惯用法（Idioms）。 （1）架构模式 架构模式是一种高层模式，用于描述系统级的结构组成、相互关系及相关约束。对架构模式的选择是最基本的设计决策，将决定系统的基本架构，并决定后续的设计及开发活动。 例如，模型 - 视图 - 控制器（Model - View - Controller，MVC）即是一种架构模式，该模式给出了一种交互式系统的架构设计，该模式的主要思想式实现业务逻辑、用户界面的分离。 （2）设计模式 设计模式是中层模式，是针对系统局部设计问题给出的解决方案。一般情况下，人们所讲的设计模式都是指中层模式。设计模式的选择对系统的基本架构没有影响，但在实现架构模式时，则可能采用多种设计模式。 例如，在实现MVC架构模式时，采用的主要设计模式有观察者模式、组合模式和策略模式等。 （3）习惯用法 架构模式和设计模式被认为是与具体编程语言无关的，而习惯用法则通常被认为是与具体编程语言相关的一种低层模式。习惯用法给出的解决方案通常与具体编程语言的某种语法机制相关。 本课程中，软件体系结构就是指架构模式，可以认为是：软件体系结构 &#x3D; 构件 + 连接件 + 约束 。 构件 构件是具有某种功能的可复用的软件结构单元，表示系统中主要的计算元素 和 数据存储。 构件是一个抽象的概念，在程序中可以指程序函数、模块、对象、类等。 连接件 连接是构件间建立和维护行为关联与信息传递的途径。连接包含下面两种要素： 其中，机制指的实际中的消息传递方式。 而协议则决定了 消息的语义理解。 连接件表示构件之间的交互并实现构件之间的连接。 软件体系结构目标为了更好理解后面的软件体系结构涉及的原则和体系结构风格，请牢记这些目标，时不时的对照后面的内容回顾这些目标。 所有的设计原则等理论基本上都可以映射到下面一个或几个目标上。 体系结构的发展现在软件的复杂性及多变性，导致了软件粒度越来越粗，越来越开放。 下面是常见的软件体系结构 软件体系结构与软件设计模式的区别","categories":[{"name":"2023","slug":"2023","permalink":"http://example.com/categories/2023/"}],"tags":[{"name":"设计模式","slug":"设计模式","permalink":"http://example.com/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"}]},{"title":"设计模式概述","slug":"设计模式(1)","date":"2023-03-15T09:18:35.137Z","updated":"2023-03-20T13:02:46.547Z","comments":true,"path":"2023/03/15/设计模式(1)/","link":"","permalink":"http://example.com/2023/03/15/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F(1)/","excerpt":"","text":"设计模式概述（1）1.1 软件设计模式的产生背景“设计模式”最初并不是出现在软件设计中，而是被用于建筑领域的设计中。 1977年美国著名建筑大师、加利福尼亚大学伯克利分校环境结构中心主任克里斯托夫·亚历山大（Christopher Alexander）在他的著作《建筑模式语言：城镇、建筑、构造》（A Pattern Language: Towns Building Construction）中描述了一些常见的建筑设计问题，并提出了 253 种关于对城镇、邻里、住宅、花园和房间等进行设计的基本模式。 1979 年他的另一部经典著作《建筑的永恒之道》（The Timeless Way of Building）进一步强化了设计模式的思想，为后来的建筑设计指明了方向。 1987 年，肯特·贝克（Kent Beck）和沃德·坎宁安（Ward Cunningham）首先将克里斯托夫·亚历山大的模式思想应用在 Smalltalk 中的图形用户接口的生成中，但没有引起软件界的关注。 1990年软件工程界开始研讨设计模式的话题，后来召开了多次关于设计模式的研讨会。直到1995 年，艾瑞克·伽马（ErichGamma）、理査德·海尔姆（Richard Helm）、拉尔夫·约翰森（Ralph Johnson）、约翰·威利斯迪斯（John Vlissides）等 4 位作者合作出版了《设计模式：可复用面向对象软件的基础》一书，在此书中收录了 23 个设计模式，这是设计模式领域里程碑的事件，导致了软件设计模式的突破。这 4 位作者在软件开发领域里也以他们的“四人组”（Gang of Four，GoF）著称。 1.2 软件设计模式的概念软件设计模式（Software Design Pattern），又称设计模式，“解决如下的在特定的环境中反复出现的设计问题，并且为其提供了解决方案”(Buschmann, et. al. 1996)，是一套被反复使用、多数人知晓的、经过分类编目的、代码设计经验的总结。它描述了在软件设计过程中的一些不断重复发生的问题，以及该问题的解决方案。也就是说，它是解决特定问题的一系列套路，是前辈们的代码设计经验的总结，具有一定的普遍性，可以反复使用。 1.3 学习设计模式的必要性设计模式的本质是面向对象设计原则的实际运用，是对类的封装性、继承性和多态性以及类的关联关系和组合关系的充分理解。 正确使用设计模式具有以下优点。 可以提高程序员的思维能力、编程能力和设计能力。 使程序设计更加标准化、代码编制更加工程化，使软件开发效率大大提高，从而缩短软件的开发周期。 使设计的代码可重用性高、可读性强、可靠性高、灵活性好、可维护性强。 成为优秀的软件工程师。 当然，软件设计模式只是一个引导。在具体的软件幵发中，必须根据设计的应用系统的特点和要求来恰当选择。对于简单的程序开发，苛能写一个简单的算法要比引入某种设计模式更加容易。但对大项目的开发或者框架设计，用设计模式来组织代码显然更好。 1.4 软件设计模式的基本要素软件设计模式使人们可以更加简单方便地复用成功的设计和体系结构，它通常包含以下几个基本要素：模式名称、别名、动机、问题、解决方案、效果、结构、模式角色、合作关系、实现方法、适用性、已知应用、例程、模式扩展和相关模式等，其中最关键的元素包括以下 4 个主要部分。 模式名称 每一个模式都有自己的名字，通常用一两个词来描述，可以根据模式的问题、特点、解决方案、功能和效果来命名。模式名称（PatternName）有助于我们理解和记忆该模式，也方便我们来讨论自己的设计。 问题 问题（Problem）描述了该模式的应用环境，即何时使用该模式。它解释了设计问题和问题存在的前因后果，以及必须满足的一系列先决条件。 解决方案 模式问题的解决方案（Solution）包括设计的组成成分、它们之间的相互关系及各自的职责和协作方式。因为模式就像一个模板，可应用于多种不同场合，所以解决方案并不描述一个特定而具体的设计或实现，而是提供设计问题的抽象描述和怎样用一个具有一般意义的元素组合（类或对象的 组合）来解决这个问题。 效果 描述了模式的应用效果以及使用该模式应该权衡的问题，即模式的优缺点。主要是对时间和空间的衡量，以及该模式对系统的灵活性、扩充性、可移植性的影响，也考虑其实现问题。显式地列出这些效果（Consequence）对理解和评价这些模式有很大的帮助。 1.5 根据目的分类 创建型模式 用于描述“怎样创建对象”，它的主要特点是“将对象的创建与使用分离”。GoF（四人组）书中提供了单例、原型、工厂方法、抽象工厂、建造者等 5 种创建型模式。 结构型模式 用于描述如何将类或对象按某种布局组成更大的结构，GoF（四人组）书中提供了代理、适配器、桥接、装饰、外观、享元、组合等 7 种结构型模式。 行为型模式 用于描述类或对象之间怎样相互协作共同完成单个对象无法单独完成的任务，以及怎样分配职责。GoF（四人组）书中提供了模板方法、策略、命令、职责链、状态、观察者、中介者、迭代器、访问者、备忘录、解释器等 11 种行为型模式。 1.6 根据作用范围来分根据模式是主要用于类上还是主要用于对象上来分，这种方式可分为类模式和对象模式两种。 类模式：用于处理类与子类之间的关系，这些关系通过继承来建立，是静态的，在编译时刻便确定下来了。GoF中的工厂方法、（类）适配器、模板方法、解释器属于该模式。 对象模式：用于处理对象之间的关系，这些关系可以通过组合或聚合来实现，在运行时刻是可以变化的，更具动态性。GoF 中除了以上 4 种，其他的都是对象模式。 1.7. GoF的23种设计模式的功能简介前面说明了 GoF 的 23 种设计模式的分类，现在对各个模式的功能进行介绍。 单例（Singleton）模式：某个类只能生成一个实例，该类提供了一个全局访问点供外部获取该实例，其拓展是有限多例模式。 原型（Prototype）模式：将一个对象作为原型，通过对其进行复制而克隆出多个和原型类似的新实例。 工厂方法（Factory Method）模式：定义一个用于创建产品的接口，由子类决定生产什么产品。 抽象工厂（AbstractFactory）模式：提供一个创建产品族的接口，其每个子类可以生产一系列相关的产品。 建造者（Builder）模式：将一个复杂对象分解成多个相对简单的部分，然后根据不同需要分别创建它们，最后构建成该复杂对象。 代理（Proxy）模式：为某对象提供一种代理以控制对该对象的访问。即客户端通过代理间接地访问该对象，从而限制、增强或修改该对象的一些特性。 适配器（Adapter）模式：将一个类的接口转换成客户希望的另外一个接口，使得原本由于接口不兼容而不能一起工作的那些类能一起工作。 桥接（Bridge）模式：将抽象与实现分离，使它们可以独立变化。它是用组合关系代替继承关系来实现，从而降低了抽象和实现这两个可变维度的耦合度。 装饰（Decorator）模式：动态的给对象增加一些职责，即增加其额外的功能。 外观（Facade）模式：为多个复杂的子系统提供一个一致的接口，使这些子系统更加容易被访问。 享元（Flyweight）模式：运用共享技术来有效地支持大量细粒度对象的复用。 组合（Composite）模式：将对象组合成树状层次结构，使用户对单个对象和组合对象具有一致的访问性。 模板方法（TemplateMethod）模式：定义一个操作中的算法骨架，而将算法的一些步骤延迟到子类中，使得子类可以不改变该算法结构的情况下重定义该算法的某些特定步骤。 策略（Strategy）模式：定义了一系列算法，并将每个算法封装起来，使它们可以相互替换，且算法的改变不会影响使用算法的客户。 命令（Command）模式：将一个请求封装为一个对象，使发出请求的责任和执行请求的责任分割开。 职责链（Chain of Responsibility）模式：把请求从链中的一个对象传到下一个对象，直到请求被响应为止。通过这种方式去除对象之间的耦合。 状态（State）模式：允许一个对象在其内部状态发生改变时改变其行为能力。 观察者（Observer）模式：多个对象间存在一对多关系，当一个对象发生改变时，把这种改变通知给其他多个对象，从而影响其他对象的行为。 中介者（Mediator）模式：定义一个中介对象来简化原有对象之间的交互关系，降低系统中对象间的耦合度，使原有对象之间不必相互了解。 迭代器（Iterator）模式：提供一种方法来顺序访问聚合对象中的一系列数据，而不暴露聚合对象的内部表示。 访问者（Visitor）模式：在不改变集合元素的前提下，为一个集合中的每个元素提供多种访问方式，即每个元素有多个访问者对象访问。 备忘录（Memento）模式：在不破坏封装性的前提下，获取并保存一个对象的内部状态，以便以后恢复它。 解释器（Interpreter）模式：提供如何定义语言的文法，以及对语言句子的解释方法，即解释器。 必须指出，这 23 种设计模式不是孤立存在的，很多模式之间存在一定的关联关系，在大的系统开发中常常同时使用多种设计模式。","categories":[{"name":"2023","slug":"2023","permalink":"http://example.com/categories/2023/"}],"tags":[{"name":"设计模式","slug":"设计模式","permalink":"http://example.com/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"}]},{"title":"虚拟机和主机双向复制","slug":"虚拟机和主机双向复制","date":"2023-03-13T16:19:02.512Z","updated":"2023-03-13T17:01:33.362Z","comments":true,"path":"2023/03/14/虚拟机和主机双向复制/","link":"","permalink":"http://example.com/2023/03/14/%E8%99%9A%E6%8B%9F%E6%9C%BA%E5%92%8C%E4%B8%BB%E6%9C%BA%E5%8F%8C%E5%90%91%E5%A4%8D%E5%88%B6/","excerpt":"虚拟机和主机双向复制","text":"虚拟机和主机双向复制 vmware tools黑了 http://www.360doc.com/content/22/1205/19/81029453_1059073619.shtml 试试这个吧 手工安装Vmware tools方法 这种方法是通过Ubuntu的安装命令直接从网上进行安装，打开终端窗口直接执行下列命令即可，安装之前要保证虚拟机可以连接外网，要能连上软件更新服务器，该服务器有可能在国外（根据你自己的设置）。命令如下： 1234sudo apt-get autoremove open-vm-toolssudo apt-get install open-vm-toolssudo apt-get install open-vm-tools-desktop 安装完之后最好重启一下虚拟机。安装完Vmware tools并正确配置后就可以实现主机和虚拟机双向内容复制、粘贴，包括文件的拷贝。","categories":[{"name":"2023","slug":"2023","permalink":"http://example.com/categories/2023/"}],"tags":[{"name":"vmware","slug":"vmware","permalink":"http://example.com/tags/vmware/"}]},{"title":"Spark入门：RDD编程","slug":"sparkRDD编程","date":"2023-03-13T13:47:53.892Z","updated":"2023-04-07T06:53:47.438Z","comments":true,"path":"2023/03/13/sparkRDD编程/","link":"","permalink":"http://example.com/2023/03/13/sparkRDD%E7%BC%96%E7%A8%8B/","excerpt":"Spark入门：RDD编程","text":"Spark入门：RDD编程 RDD创建RDD可以通过两种方式创建： 第一种：读取一个外部数据集。比如，从本地文件加载数据集，或者从HDFS文件系统、HBase、Cassandra、Amazon S3等外部数据源中加载数据集。Spark可以支持文本文件、SequenceFile文件（Hadoop提供的 SequenceFile是一个由二进制序列化过的key&#x2F;value的字节流组成的文本存储文件）和其他符合Hadoop InputFormat格式的文件。 第二种：调用SparkContext的parallelize方法，在Driver中一个已经存在的集合（数组）上创建 在即将进行相关的实践操作之前，我们首先要登录Linux系统（本教程统一采用hadoop用户登录），然后，打开命令行“终端”，请按照下面的命令启动Hadoop中的HDFS组件： 创建RDD之前的准备工作在即将进行相关的实践操作之前，我们首先要登录Linux系统（本教程统一采用hadoop用户登录），然后，打开命令行“终端”，请按照下面的命令启动Hadoop中的HDFS组件： 12cd /usr/local/hadoop./sbin/start-dfs.sh 然后，我们按照下面命令启动spark-shell： 12cd /usr/local/spark./bin/pyspark 然后，新建第二个“终端”，方法是，在前面已经建设的第一个终端窗口的左上方，点击“终端”菜单，在弹出的子菜单中选择“新建终端”，就可以打开第二个终端窗口，现在，我们切换到第二个终端窗口，在第二个终端窗口中，执行以下命令，进入之前已经创建好的“&#x2F;usr&#x2F;local&#x2F;spark&#x2F;mycode&#x2F;”目录，在这个目录下新建rdd子目录，用来存放本章的代码和相关文件： 12cd usr/local/spark/mycode/mkdir rdd 然后，使用vim编辑器，在rdd目录下新建一个word.txt文件，你可以在文件里面随便输入几行英文语句用来测试。 经过上面的准备工作以后，我们就可以开始创建RDD了。 从文件系统中加载数据创建RDDSpark采用textFile()方法来从文件系统中加载数据创建RDD，该方法把文件的URI作为参数，这个URI可以是本地文件系统的地址，或者是分布式文件系统HDFS的地址，或者是Amazon S3的地址等等。下面请切换回spark-shell窗口，看一下如何从本地文件系统中加载数据： 12&gt;&gt;&gt;lines = sc.textFile(&quot;file:///usr/local/spark/mycode/rdd/word.txt&quot;) 1&gt;&gt;&gt;lines.foreach(print) 加载HDFS中的文件为了能够读取HDFS中的文件，请首先启动Hadoop中的HDFS组件。注意，之前我们在“Spark安装”这章内容已经介绍了如何安装Hadoop和Spark，所以，这里我们可以使用以下命令直接启动Hadoop中的HDFS组件（由于用不到MapReduce组件，所以，不需要启动MapReduce或者YARN）。请到第二个终端窗口，使用Linux Shell命令提示符状态，然后输入下面命令： 12cd /usr/local/hadoop./sbin/start-dfs.sh 启动结束后，HDFS开始进入可用状态。如果你在HDFS文件系统中，还没有为当前Linux登录用户创建目录(本教程统一使用用户名hadoop登录Linux系统)，请使用下面命令创建： 1./bin/hdfs dfs -mkdir -p /user/hadoop 也就是说，HDFS文件系统为Linux登录用户开辟的默认目录是“&#x2F;user&#x2F;用户名”（注意：是user，不是usr），本教程统一使用用户名hadoop登录Linux系统，所以，上面创建了“&#x2F;user&#x2F;hadoop”目录，再次强调，这个目录是在HDFS文件系统中，不在本地文件系统中。创建好以后，下面我们使用命令查看一下HDFS文件系统中的目录和文件： 1./bin/hdfs dfs -ls . ** 但这个命令我搞不出来，显示的是这个 – 上面命令中，最后一个点号“.”，表示要查看Linux当前登录用户hadoop在HDFS文件系统中与hadoop对应的目录下的文件，也就是查看HDFS文件系统中“&#x2F;user&#x2F;hadoop&#x2F;”目录下的文件，所以，下面两条命令是等价的： – 12./bin/hdfs dfs -ls ../bin/hdfs dfs -ls /user/hadoop 你自己可以试一试，只有第二个可以用 如果要查看HDFS文件系统根目录下的内容，需要使用下面命令： 1./bin/hdfs dfs -ls / 然后输出的东西见上面那个图，有一个items 下面，我们把本地文件系统中的“&#x2F;usr&#x2F;local&#x2F;spark&#x2F;mycode&#x2F;rdd&#x2F;word.txt”上传到分布式文件系统HDFS中（放到hadoop用户目录下）： 1./bin/hdfs dfs -put /usr/local/spark/mycode/rdd/word.txt /user/hadoop 然后，用命令查看一下HDFS的hadoop用户目录下是否多了word.txt文件，可以使用下面命令列出hadoop目录下的内容： 1./bin/hdfs dfs -ls / 可以看到，确实多了一个word.txt文件，我们使用cat命令查看一个HDFS中的word.txt文件的内容，命令如下： 1./bin/hdfs dfs -cat ./word.txt 上面命令执行后，就会看到HDFS中word.txt的内容了。 现在，让我们切换回到spark-shell窗口，编写语句从HDFS中加载word.txt文件，并显示第一行文本内容： 12&gt;&gt;&gt;lines= sc.textFile(&quot;hdfs://localhost:9000/user/hadoop/word.txt&quot;)&gt;&gt;&gt;lines=sc.foreach(print) 注意，上面三条命令是完全等价的命令，只不过使用了不同的目录形式，你可以使用其中任意一条命令完成数据加载操作。 在使用Spark读取文件时，需要说明以下几点：（1）如果使用了本地文件系统的路径，那么，必须要保证在所有的worker节点上，也都能够采用相同的路径访问到该文件，比如，可以把该文件拷贝到每个worker节点上，或者也可以使用网络挂载共享文件系统。（2）textFile()方法的输入参数，可以是文件名，也可以是目录，也可以是压缩文件等。比如，textFile(“&#x2F;my&#x2F;directory”), textFile(“&#x2F;my&#x2F;directory&#x2F;.txt”), and textFile(“&#x2F;my&#x2F;directory&#x2F;.gz”).（3）textFile()方法也可以接受第2个输入参数（可选），用来指定分区的数目。默认情况下，Spark会为HDFS的每个block创建一个分区（HDFS中每个block默认是128MB）。你也可以提供一个比block数量更大的值作为分区数目，但是，你不能提供一个小于block数量的值作为分区数目。 通过并行集合（数组）创建RDD可以调用SparkContext的parallelize方法，在Driver中一个已经存在的集合（数组）上创建。下面请在spark-shell中操作： 123&gt;&gt;&gt;array = [1,2,3,4,5]&gt;&gt;&gt;rdd = sc.parallelize(array)&gt;&gt;&gt;rdd.foreach(print) RDD操作RDD被创建好以后，在后续使用过程中一般会发生两种操作：*  转换（Transformation）： 基于现有的数据集创建一个新的数据集。*  行动（Action）：在数据集上进行运算，返回计算值。 转换操作对于RDD而言，每一次转换操作都会产生不同的RDD，供给下一个“转换”使用。转换得到的RDD是惰性求值的，也就是说，整个转换过程只是记录了转换的轨迹，并不会发生真正的计算，只有遇到行动操作时，才会发生真正的计算，开始从血缘关系源头开始，进行物理的转换操作。下面列出一些常见的转换操作（Transformation API）：* filter(func)：筛选出满足函数func的元素，并返回一个新的数据集* map(func)：将每个元素传递到函数func中，并将结果返回为一个新的数据集* flatMap(func)：与map()相似，但每个输入元素都可以映射到0或多个输出结果* groupByKey()：应用于(K,V)键值对的数据集时，返回一个新的(K, Iterable)形式的数据集* reduceByKey(func)：应用于(K,V)键值对的数据集时，返回一个新的(K, V)形式的数据集，其中的每个值是将每个key传递到函数func中进行聚合 1.filter(func) 好吧，这个书上说要把word.txt写成 12345Hadoop is goodSpark is fastSpark is better 那我们就 1cd /usr/local/spark/mycode/rdd 1gedit word.txt 然后再 123&gt;&gt;&gt;lines=sc.textFile(&quot;file:///usr/local/spark/mycode/rdd/word.txt&quot;)&gt;&gt;&gt;linesWithSpark = lines.filter(lambda line: &quot;Spark&quot; in line)&gt;&gt;&gt;linesWithSpark.foreach(print) 上面的代码中，lines就是一个RDD。lines.filter()会遍历lines中的每行文本，并对每行文本执行括号中的匿名函数，也就是执行Lamda表达式：line &#x3D;&gt; line.contains(“Spark”)，在执行Lamda表达式时，会把当前遍历到的这行文本内容赋值给参数line，然后，执行处理逻辑line.contains(“Spark”)，也就是只有当改行文本包含“Spark”才满足条件，才会被放入到结果集中。最后，等到lines集合遍历结束后，就会得到一个结果集，这个结果集中包含了所有包含“Spark”的行。最后，对这个结果集调用count()，这是一个行动操作，会计算出结果集中的元素个数。 2.map(func) map(func)：将每个元素传递到函数func中，并将结果返回为一个新的数据集 1234&gt;&gt;&gt; data =[1,2,3,4,5]&gt;&gt;&gt; rdd1 = sc.parallelize(data)&gt;&gt;&gt; rdd2 = rdd1.map(lambda x:x+10)&gt;&gt;&gt; rdd2.foreach(print) 上述语句执行过程如图 所示。第 1行语句创建了一个包含 5 个整型元素的列表 data。第2行语句执行 sc.parallelize(data)，从列表 data 中生成一个 RDD，即 rdd1,rdd1 中包含了5 个整型的元素即1、2、3、4、5。第 3 行语句执行 rdd1.map0操作,map0的输入参数“lambda x:x+10”是一个Lambda表达式。rdd1.map(lambda x:x+10)的含义是，依次取出 rdd1 这个RDD 中的每个元素，对于当前取到的元素，把它赋值给 Lambda 表达式中的变量x，然后，执行 Lambda 表达式的函数体部分“x+10”也就是把变量x的值和 10 相加后，作为函数的返回值，并作为一个元素放入到新的 RDD(即rdd2中。最终，新牛成的RDD (即 rdd2) 中包含了 5 个整型元素，即 11、12、13、14、15。 另外一个实例： 123&gt;&gt;&gt;lines=sc.textFile(&quot;file:///usr/local/spark/mycode/rdd/word.txt&quot;)&gt;&gt;&gt; words = lines.map(lambda line:line.split(&quot; &quot;))&gt;&gt;&gt; words.foreach(print) 上述语句执行过程如图所示。在第 1 行语句中，执行 sc.textFile0方法把 word.txt 文件中的数据加载到内存生成一个 RDD，即 lines，这个RDD 中的每个元素都是字符串类型，即每个 RDD 元素都是一行文本，比如，lines 中的第 1 个元素是”Hadoop is good”，第2 个元素是”Spark is fast”，第3个元素是”Spark is better”。在第 2 行语句中，执行 lies.map0操作，map0的输入参数 lambdaline:line.split(“)是一个 Lambda 表达式。linesmap(lambda line:line.split(“”)的含义是，依次取出 lines这个 RDD 中的每个元素，对于当前取到的元素，把它赋值给 Lambda 表达式中的变量 line，然后，执行 Lambda 表达式的函数体部分 line.split(“”)。因为 line 是一行文本，如”Hadoop is good”，一行文本中包含了很多个单词，单词之间以空格进行分隔，所以，line.split(“”的功能是，以空格作为分隔符把 line 拆分成一个个单词,拆分后得到的单词都封装在一个列表对象中,成为新的 RDD( 即 words)的一个元素，比如，”Hadoop is good”被拆分后，得到”Hadoop”、”is”和”good”3 个单词，会被封装到一个列表对象中，即[“Hadoop”.”is”,”good”]，成为 words 这个 RDD 中的一个元素。 3.flatMap(func)flatMap(func)与 map0相似，但每个输入元素都可以映射到 0 或多个输出结果。例如: 123&gt;&gt;&gt;lines=sc.textFile(&quot;file:///usr/local/spark/mycode/rdd/word.txt&quot;)&gt;&gt;&gt;words =lines.flatMap(lambda line:line.split(&quot; &quot;))&gt;&gt;&gt; words.foreach(print) 上述语句执行过程如图所示。在第 1行语句中，执行 sc.textFile0方法把 wordtxt 文件中的数据加载到内存生成一个RDD，即 lines，这个 RDD 中的每个元素都是字符串类型，即每个RDD 元素都是一行文本。在第2行语句中，执行 linesflatMap0操作，flatMap0的输入参数 line:linesplit(“”)是个Lambda 表达式。lines.flatMap(lambda line:line.split(“”))的结果，等价于如下两步操作的结果。 第1步: map0。执行 lines.map(lambda line: linesplit(“”))操作，从 lines 转换得到一个新的 RDD(即wordArray),wordArray 中的每个元素都是一个列表,比如,第1个元素是[“Hadoop”,”is”，”good”]7.第2个元素是”Spark”，”is”,”fast”]，第3 个元素是[“Spark”,”is””better”]。 第 2步:拍扁 ( flat)。flatMap0操作中的“flat”是一个很形象的动作-“拍扁”，也就是把vordArray 中的每个 RDD 元素都“拍扁”成多个元素。所有这些被拍扁以后得到的元素，构成一个新的 RDD，即 words。比如，wordArray 中的第1个元素是[“Hadoop”,”is”,”good]，被拍扁以后得到3个新的字符串类型的元素,即”Hadoop”、”is”和”good”; wordArray 中的第 2 个元素是[“Spark”,”is”fast”],被拍扁以后得到 3 个新的元素,即”Spark”、”is”和”fast”; wordArray 中的第 3 个元素是[“Spark””is””beter”，被拍扁以后得到 3 个新的元素，即”Spark”、”is”和”beter”。最终，这些被拍扁以后得到的 9 个字符串类型的元素构成一个新的 RDD (即 words )。也就是说，words 里面包含了 9 个字串类型的元素，分别是”Hadoop”、”is”、”good”、”Spark”、”is”、”fast”、”Spark”、”is”和”。","categories":[{"name":"2023","slug":"2023","permalink":"http://example.com/categories/2023/"}],"tags":[{"name":"Spark","slug":"Spark","permalink":"http://example.com/tags/Spark/"}]},{"title":"3-8-2023","slug":"3-8-2023","date":"2023-03-08T05:19:53.978Z","updated":"2023-03-08T05:45:39.860Z","comments":true,"path":"2023/03/08/3-8-2023/","link":"","permalink":"http://example.com/2023/03/08/3-8-2023/","excerpt":"三月初自我反省","text":"三月初自我反省 1.退实验室✔ 2.数学第一章✔ 3.单词200 per day✔ 4.后端增删查改✔ 1234567891011121314151617181920212223def department_list(request): member_list=Department.objects.all() return render(request,&#x27;dep.html&#x27;,&#123;&#x27;member&#x27;:member_list&#125;)def add_dep(request): if request.method==&#x27;GET&#x27;: return render(request,&#x27;adddep.html&#x27;) elif request.method==&#x27;POST&#x27;: title=request.POST.get(&#x27;aatitle&#x27;) Department.objects.create(tittle=title) return redirect(&quot;/dep/list&quot;)def delete_dep(request): memid=request.GET.get(&#x27;memid&#x27;) Department.objects.filter(id=memid).delete() return redirect(&quot;/dep/list&quot;)def edit_dep(request,memid): if request.method==&#x27;GET&#x27;: nnmame=Department.objects.filter(id=memid).first() return render(request,&#x27;editdpt.html&#x27;,&#123;&#x27;nnmame&#x27;:nnmame.tittle&#125;) aatitle=request.POST.get(&#x27;aatitle&#x27;) Department.objects.filter(id=memid).update(tittle=aatitle) return redirect(&quot;/dep/list&quot;) 5.数据结构 图(floyd，dijkstra)✔ 1234567891011121314151617181920212223242526272829303132#include&lt;cstdio&gt;#include&lt;iostream&gt;#include&lt;cmath&gt;#include&lt;cstring&gt;using namespace std;int a[101][3];double f[101][101];int n,i,j,k,x,y,m,s,e;int main()&#123;// freopen(&quot;short.in&quot;,&quot;r&quot;,stdin);// freopen(&quot;short.out&quot;,&quot;w&quot;,stdout); cin&gt;&gt;n; for(i=1;i&lt;=n;i++) cin&gt;&gt;a[i][1]&gt;&gt;a[i][2]; cin&gt;&gt;m; memset(f,0x7f,sizeof(f)); //初始化为最大值 for(i=1;i&lt;=m;i++)&#123; cin&gt;&gt;x&gt;&gt;y;// int temp1=;// int temp2=; f[y][x]=f[x][y]=sqrt(pow(double(a[x][1]-a[y][1]),2)+pow(double(a[x][2]-a[y][2]),2)); &#125; cin&gt;&gt;s&gt;&gt;e; for(k=1;k&lt;=n;k++) for(j=1;j&lt;=n;j++) for(i=1;i&lt;=n;i++) if(f[i][k]+f[k][j]&lt;f[i][j]) f[i][j]=f[i][k]+f[k][j]; printf(&quot;%.2lf\\n&quot;,f[s][e]); return 0; &#125; 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849#include&lt;cstdio&gt;#include&lt;cstring&gt;#define INF 1e4+10using namespace std;const int M=1e4+10;const int N=1000+10;int n,m,s;int mp[N][M];int dis[N],vis[N];void initmp()&#123;memset(mp,INF,sizeof(mp)); &#125;void dijkstra(int s)&#123; //求s点到其它点的最短路径 memset(vis,0,sizeof(vis));//0表示蓝点(未确定最短路径的点)，1表示白点（确定路径的点） memset(dis,0x3f,sizeof(dis));//默认情况下设置为无穷大 dis[s]=0; while(1)&#123; int mini=0,min_=INF; for(int j=1;j&lt;=n;j++)&#123; if(!vis[j]&amp;&amp;min_&gt;dis[j])&#123;//从蓝点中找出最小的点 .vis[j](蓝点)为0,那么!vis[j]就为1了.dis[j]是权值 mini=j;//记录第几个点 min_=dis[j]; //记录最短的路的距离 &#125; &#125; //如果没有蓝点就提前结束 if(mini==0) break; vis[mini]=1;//变成白点 for(int i=1;i&lt;=n;i++)&#123; if(dis[i]&gt;dis[mini]+mp[mini][i]) dis[i]=dis[mini]+mp[mini][i]; &#125; &#125; &#125;int main()&#123; memset(mp,INF,sizeof(mp)); while(scanf(&quot;%d %d&quot;,&amp;n,&amp;m)!=EOF&amp;&amp;n)&#123; initmp();//每次清空mp for(int i=0;i&lt;m;i++)&#123; int u,v,w; scanf(&quot;%d %d %d&quot;,&amp;u,&amp;v,&amp;w); if(mp[u][v]&gt;w) mp[u][v]=mp[v][u]=w; &#125; dijkstra(1); printf(&quot;%d\\n&quot;,dis[n]); &#125; return 0;&#125;","categories":[{"name":"2023","slug":"2023","permalink":"http://example.com/categories/2023/"}],"tags":[{"name":"casual_talk","slug":"casual-talk","permalink":"http://example.com/tags/casual-talk/"}]},{"title":"DataError at /index/add_member 1366, \"Incorrect string value :\\\\xE4\\\\xBC\\\\x98\\\\xE","slug":"ERROR 1366 (HY000)Incorrect string value解决方案","date":"2023-03-05T03:11:11.586Z","updated":"2023-03-08T05:16:49.900Z","comments":true,"path":"2023/03/05/ERROR 1366 (HY000)Incorrect string value解决方案/","link":"","permalink":"http://example.com/2023/03/05/ERROR%201366%20(HY000)Incorrect%20string%20value%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/","excerpt":"&#x38;&#x32;&#x35;&#53;&#x37;&#55;&#x39;&#52;&#x30;&#x40;&#x71;&#113;&#x2e;&#99;&#x6f;&#x6d; DataError at &#x2F;index&#x2F;add_member 1366, “Incorrect string value: ‘\\xE4\\xBC\\x98\\xE ERROR 1366 (HY000):Incorrect string value解决方案","text":"&#x38;&#x32;&#x35;&#53;&#x37;&#55;&#x39;&#52;&#x30;&#x40;&#x71;&#113;&#x2e;&#99;&#x6f;&#x6d; DataError at &#x2F;index&#x2F;add_member 1366, “Incorrect string value: ‘\\xE4\\xBC\\x98\\xE ERROR 1366 (HY000):Incorrect string value解决方案 https://zhuanlan.zhihu.com/p/53941345 after before 然后把数据库删除，重新创建数据库，再导入数据库文件，就又是一条好汉","categories":[{"name":"2023","slug":"2023","permalink":"http://example.com/categories/2023/"}],"tags":[{"name":"mysql","slug":"mysql","permalink":"http://example.com/tags/mysql/"}]},{"title":"远离不规范书籍，不然会变得不幸","slug":"远离不规范书籍，不然会变得不幸","date":"2023-03-04T09:14:48.511Z","updated":"2023-03-08T05:16:54.675Z","comments":true,"path":"2023/03/04/远离不规范书籍，不然会变得不幸/","link":"","permalink":"http://example.com/2023/03/04/%E8%BF%9C%E7%A6%BB%E4%B8%8D%E8%A7%84%E8%8C%83%E4%B9%A6%E7%B1%8D%EF%BC%8C%E4%B8%8D%E7%84%B6%E4%BC%9A%E5%8F%98%E5%BE%97%E4%B8%8D%E5%B9%B8/","excerpt":"远离不规范书籍,不然会变得不幸","text":"远离不规范书籍,不然会变得不幸","categories":[{"name":"2023","slug":"2023","permalink":"http://example.com/categories/2023/"}],"tags":[{"name":"casual_talk","slug":"casual-talk","permalink":"http://example.com/tags/casual-talk/"}]},{"title":"2月开学总结","slug":"2月开学总结","date":"2023-03-01T06:57:51.608Z","updated":"2023-03-08T05:15:23.317Z","comments":true,"path":"2023/03/01/2月开学总结/","link":"","permalink":"http://example.com/2023/03/01/2%E6%9C%88%E5%BC%80%E5%AD%A6%E6%80%BB%E7%BB%93/","excerpt":"2月开学总结","text":"2月开学总结 每日200单词，真的坚持不下来（我妈说过一句老话：新的马桶只有三天是香的） 周五-周日每日50页django目前停滞（p117），在后渲前的简单&#123;&#123;&#125;&#125;不清楚具体语法，有时间看b具体简单讲解，我实在无法理解，这种书怎么出版的，前20页每页都有错误，这个人抄官方文档都能抄错？？？？！！！ 问了师姐她复习进度，四月之前（include四月）刷完1800,以及师姐说英二难度比江苏高考英语难度小 临时接了挑战杯的复赛答辩，要准备讲演稿子 目前数学进度第一章（第一遍做不到不看视频（看视频时真的费时间），但已经都忘了（为什么上学期我要拒绝高数老师让我做她的助教（扇自己耳光））） 英语6级太难了 准备算法考试 所有的东西并行真的做不到，一天只能选一个（上周多线程进行复习&amp;&amp;学习，效率极低） 佛山顺德愿望get 实验室老师开始整幺蛾子了：周四下午7、8节加了一节选修课。明天去一节看看情况，不行就退实验室;以及未来一个月内实验室搬迁，不行就退。 昨天去交材料，党建的辅导老师说：好久没看见你了，你最近在干嘛。 我：准备考研，和实验室的东西。 老师:你准备考研的话要平衡比赛和考研准备的东西 老师:考研的书差不多要买了 我：嗯嗯12.仰天长叹，下个月三场考试，4月份一轮，师姐说828要在这学期内过完，操作系统跟着这学期的老师好好学一遍，就没什么问题，我真的能平衡吗……实验室感觉差不多可以退了，但又想拼一把计算机设计大赛，自己再做个东西出来…… emoji format 本来想花15min解决的note，花了1个小时的原因窒息","categories":[{"name":"2023","slug":"2023","permalink":"http://example.com/categories/2023/"}],"tags":[{"name":"casual_talk","slug":"casual-talk","permalink":"http://example.com/tags/casual-talk/"}]},{"title":"Import pymysql could not be resolved from","slug":"Import pymysql could not be resolved from","date":"2023-02-26T13:23:28.035Z","updated":"2023-03-13T16:56:38.944Z","comments":true,"path":"2023/02/26/Import pymysql could not be resolved from/","link":"","permalink":"http://example.com/2023/02/26/Import%20pymysql%20could%20not%20be%20resolved%20from/","excerpt":"Import “pymysql” could not be resolved from","text":"Import “pymysql” could not be resolved from 在anaconda里面装一个 首先先切进django的虚拟环境里面 在Anaconda中，可以通过使用conda命令来创建和管理虚拟环境。要切换已创建的虚拟环境，可以使用以下命令： 列出已有环境： 1conda info --envs 激活目标环境： 1conda activate &lt;env_name&gt; 这里&lt;env_name&gt;是你想要激活的虚拟环境的名称。激活环境后，你可以在该环境中使用安装的软件包和工具。 取消激活当前环境： 1conda deactivate 这将使当前环境不再处于活动状态，回到默认的基础环境。 注意：如果你在使用Anaconda Navigator，也可以通过选择“Environments”选项卡，然后单击目标环境的名称来激活虚拟环境。 conda install pymysql 看你anaconda用的是什么源，国内的记得关闭魔法上网工具","categories":[{"name":"2023","slug":"2023","permalink":"http://example.com/categories/2023/"}],"tags":[{"name":"django","slug":"django","permalink":"http://example.com/tags/django/"}]},{"title":"官方文档","slug":"null¶","date":"2023-02-24T12:24:35.657Z","updated":"2023-03-01T07:09:14.756Z","comments":true,"path":"2023/02/24/null¶/","link":"","permalink":"http://example.com/2023/02/24/null%C2%B6/","excerpt":"https://stackoverflow.com/questions/19428572/django-templatesyntaxerror-could-not-parse-the-remainder","text":"https://stackoverflow.com/questions/19428572/django-templatesyntaxerror-could-not-parse-the-remainder 模型字段参考 字段选项 https://docs.djangoproject.com/zh-hans/4.1/ref/models/fields/#validators 以下参数对所以字段类型均有效，且是可选的。 null¶ Field.``null¶ 如果是 True， Django 将在数据库中存储空值为 NULL。默认为 False。 避免在基于字符串的字段上使用 null，如 CharField 和 TextField。如果一个基于字符串的字段有 null=True，这意味着它有两种可能的“无数据”值。NULL，和空字符串。在大多数情况下，“无数据”有两种可能的值是多余的，Django 的惯例是使用空字符串，而不是 NULL。一个例外是当一个 CharField 同时设置了 unique=True 和 blank=True。在这种情况下，null=True 是需要的，以避免在保存具有空白值的多个对象时违反唯一约束。 无论是基于字符串的字段还是非字符串的字段，如果希望在表单中允许空值，还需要设置 blank=True，因为 null 参数只影响数据库的存储（参见 blank ）。","categories":[{"name":"2023","slug":"2023","permalink":"http://example.com/categories/2023/"}],"tags":[{"name":"django","slug":"django","permalink":"http://example.com/tags/django/"}]},{"title":"Module \"django.contrib.sessions.serializers\" does not define a \"PicleSerializer\" attribute/class","slug":"Module django.contrib.sessions.serializers does not define a PicleSerializer attributeclass","date":"2023-02-24T07:05:59.648Z","updated":"2023-03-01T07:09:09.742Z","comments":true,"path":"2023/02/24/Module django.contrib.sessions.serializers does not define a PicleSerializer attributeclass/","link":"","permalink":"http://example.com/2023/02/24/Module%20django.contrib.sessions.serializers%20does%20not%20define%20a%20PicleSerializer%20attributeclass/","excerpt":"Module “django.contrib.sessions.serializers” does not define a “PicleSerializer” attribute&#x2F;class","text":"Module “django.contrib.sessions.serializers” does not define a “PicleSerializer” attribute&#x2F;class 是这本书打错了hhhh https://docs.djangoproject.com/zh-hans/4.1/topics/http/sessions/ 在这里ctrl+F找 serializers 最后一个 serializers.``PickleSerializer tmd是这个玩意儿！ 不是picle睡觉哦pick 服了这个写书的老六！","categories":[{"name":"2023","slug":"2023","permalink":"http://example.com/categories/2023/"}],"tags":[{"name":"django","slug":"django","permalink":"http://example.com/tags/django/"}]},{"title":"无法加载文件C:\\Users\\xxx\\Documents\\WindowsPowerShell\\profile.ps1","slug":"无法加载文件CUsersxxxDocumentsWindowsPowerShellprofile.ps1，因为在此系统上禁止运行脚本","date":"2023-02-24T04:38:04.277Z","updated":"2023-03-01T07:08:52.941Z","comments":true,"path":"2023/02/24/无法加载文件CUsersxxxDocumentsWindowsPowerShellprofile.ps1，因为在此系统上禁止运行脚本/","link":"","permalink":"http://example.com/2023/02/24/%E6%97%A0%E6%B3%95%E5%8A%A0%E8%BD%BD%E6%96%87%E4%BB%B6CUsersxxxDocumentsWindowsPowerShellprofile.ps1%EF%BC%8C%E5%9B%A0%E4%B8%BA%E5%9C%A8%E6%AD%A4%E7%B3%BB%E7%BB%9F%E4%B8%8A%E7%A6%81%E6%AD%A2%E8%BF%90%E8%A1%8C%E8%84%9A%E6%9C%AC/","excerpt":"无法加载文件C:\\Users\\xxx\\Documents\\WindowsPowerShell\\profile.ps1，因为在此系统上禁止运行脚本","text":"无法加载文件C:\\Users\\xxx\\Documents\\WindowsPowerShell\\profile.ps1，因为在此系统上禁止运行脚本 问题描述打开 PowerShell 提示如下报错信息。 123456789101112Windows PowerShell版权所有（C） Microsoft Corporation。保留所有权利。安装最新的 PowerShell，了解新功能和改进！https://aka.ms/PSWindows. : 无法加载文件 C:\\Users\\87897\\Documents\\WindowsPowerShell\\profile.ps1，因为在此系统上禁止运行脚本。有关详细信息，请参阅 https:/go.microsoft.com/fwlink/?LinkID=135170 中的 about_Execution_Policies。所在位置 行:1 字符: 3+ . &#x27;C:\\Users\\87897\\Documents\\WindowsPowerShell\\profile.ps1&#x27;+ ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ + CategoryInfo : SecurityError: (:) []，PSSecurityException1234567891011 原因分析输入 get-ExecutionPolicy 输出 Restricted，即脚本执行策略受限。 123PS C:\\Windows\\system32&gt; get-ExecutionPolicyRestricted12 解决方案更换脚本执行策略：set-ExecutionPolicy RemoteSigned，然后输入 Y。 1234567PS C:\\Windows\\system32&gt; set-ExecutionPolicy RemoteSigned执行策略更改执行策略可帮助你防止执行不信任的脚本。更改执行策略可能会产生安全风险，如 https:/go.microsoft.com/fwlink/?LinkID=135170中的 about_Execution_Policies 帮助主题所述。是否要更改执行策略?[Y] 是(Y) [A] 全是(A) [N] 否(N) [L] 全否(L) [S] 暂停(S) [?] 帮助 (默认值为“N”): Y123456 更换完成后，再次使用命令 get-ExecutionPolicy 查看脚本执行策略。 123PS C:\\Windows\\system32&gt; get-ExecutionPolicyRemoteSigned12 可以发现已经更改了。问题完美解决，over~~😊","categories":[{"name":"2023","slug":"2023","permalink":"http://example.com/categories/2023/"}],"tags":[{"name":"powershell","slug":"powershell","permalink":"http://example.com/tags/powershell/"}]},{"title":"anaconda安装其他东西","slug":"Win10下Anaconda使用conda activate报错Your shell has not been properly configured to use 'conda activate'","date":"2023-02-24T04:23:35.093Z","updated":"2023-03-08T05:18:49.483Z","comments":true,"path":"2023/02/24/Win10下Anaconda使用conda activate报错Your shell has not been properly configured to use 'conda activate'/","link":"","permalink":"http://example.com/2023/02/24/Win10%E4%B8%8BAnaconda%E4%BD%BF%E7%94%A8conda%20activate%E6%8A%A5%E9%94%99Your%20shell%20has%20not%20been%20properly%20configured%20to%20use%20'conda%20activate'/","excerpt":"Win10下Anaconda使用conda activate报错Your shell has not been properly configured to use ‘conda activate’","text":"Win10下Anaconda使用conda activate报错Your shell has not been properly configured to use ‘conda activate’ 1234567891011121314151617181920212223PS E:\\dijango&gt; conda activate baseCommandNotFoundError: Your shell has not been properly configured to use &#x27;conda activate&#x27;.If using &#x27;conda activate&#x27; from a batch script, change yourinvocation to &#x27;CALL conda.bat activate&#x27;.To initialize your shell, run $ conda init &lt;SHELL_NAME&gt;Currently supported shells are:- bash- cmd.exe- fish- tcsh- xonsh- zsh- powershellSee &#x27;conda init --help&#x27; for more information and options.IMPORTANT: You may need to close and restart your shell after running &#x27;conda init&#x27;. 先以管理员身份打开cmd。试一下conda activate 环境名称。如果命令行提示 1Your shell has not been properly configured to use ‘conda activate’. 然后下面还提示 conda init &lt;SHELL NAME&gt; 就按照他的要求，输入一下 conda init cmd.exe 或者 conda init powershell 这两条都试试，回车，重启cmd说不定就好了。反正我好了。","categories":[{"name":"2023","slug":"2023","permalink":"http://example.com/categories/2023/"}],"tags":[{"name":"anaconda","slug":"anaconda","permalink":"http://example.com/tags/anaconda/"}]},{"title":"闭包","slug":"闭包","date":"2023-02-23T14:17:31.662Z","updated":"2023-02-23T13:50:32.190Z","comments":true,"path":"2023/02/23/闭包/","link":"","permalink":"http://example.com/2023/02/23/%E9%97%AD%E5%8C%85/","excerpt":"闭包","text":"闭包 12345678910111213141516171819202122232425262728// 1.污染环境的全局变量实现函数执行一次次数减一 var a=10; function fa()&#123; a--; console.log(a); &#125; // 2.那就换成局部变量试试 function fb()&#123; var a=10; a--; console.log(a); &#125;/*它居然不动了*/ // 3.闭包 function fc()&#123; let a=10; function fd()&#123; a--; console.log(a); &#125; return fd; &#125; var fm=fc();//完成这句才算闭包 // 总结 // 1.有嵌套函数 // 2.内部函数引用外部作用域 // 3.返回值是函数 // 4.船舰一个对象函数，让其长期驻留","categories":[{"name":"2022","slug":"2022","permalink":"http://example.com/categories/2022/"}],"tags":[{"name":"js","slug":"js","permalink":"http://example.com/tags/js/"}]},{"title":"reat-router","slug":"router","date":"2023-02-23T14:17:31.647Z","updated":"2023-02-23T13:50:45.673Z","comments":true,"path":"2023/02/23/router/","link":"","permalink":"http://example.com/2023/02/23/router/","excerpt":"随意使用您选择的打包器，例如 Create React App 1npx create-react-app router-tutorial","text":"随意使用您选择的打包器，例如 Create React App 1npx create-react-app router-tutorial 然后安装 React Router 依赖项： 12cd router-tutorialnpm install react-router-dom@6 history@5 然后编辑你的App.js，让它变得很无聊: 1234567export default function App() &#123; return ( &lt;div&gt; &lt;h1&gt;Bookkeeper!&lt;/h1&gt; &lt;/div&gt; );&#125; 最后，确认index.js or main.jsx（取决于你的打包工具）是可用的： root渲染App 123456import &#123; render &#125; from &quot;react-dom&quot;;import App from &quot;./App&quot;;const rootElement = document.getElementById(&quot;root&quot;);render(&lt;App /&gt;, rootElement); 然后是删了一点东西 启动您的React应用： 1npm start 连接路由首先，我们想把你的应用连接到路由: import ‘ BrowserRouter ‘，并用它包裹你的整个应用。(修改index.js) 1234567891011import &#123; render &#125; from &quot;react-dom&quot;;import &#123; BrowserRouter &#125; from &quot;react-router-dom&quot;;import App from &quot;./App&quot;;const rootElement = document.getElementById(&quot;root&quot;);render( &lt;BrowserRouter&gt; &lt;App /&gt; &lt;/BrowserRouter&gt;, rootElement); 应用程序中没有任何变化，但现在我们已准备好开始处理路由。 添加一些链接打开 src&#x2F;App.js、导入 Link 并添加一些全局导航。注：在本教程中不要对待样式太认真，我们只是为了方便而使用内联样式，你可以根据需要设置样式。 123456789101112131415161718import &#123; Link &#125; from &quot;react-router-dom&quot;;export default function App() &#123; return ( &lt;div&gt; &lt;h1&gt;Bookkeeper&lt;/h1&gt; &lt;nav style=&#123;&#123; borderBottom: &quot;solid 1px&quot;, paddingBottom: &quot;1rem&quot; &#125;&#125; &gt; &lt;Link to=&quot;/invoices&quot;&gt;Invoices&lt;/Link&gt; |&#123;&quot; &quot;&#125; &lt;Link to=&quot;/expenses&quot;&gt;Expenses&lt;/Link&gt; &lt;/nav&gt; &lt;/div&gt; );&#125; 单击链接和后退&#x2F;前进按钮。React Router 现在正在控制 URL！ 我们还没有在 URL 更改时呈现任何路由，但 Link 可以更改 URL，而不会导致整个页面重新加载。 添加一些路由添加几个新文件： src/routes/invoices.jsx src/routes/expenses.jsx (文件的位置并不重要，但是当你想要自动生成后端API，服务器渲染，代码分割或者更多的功能时，像这样命名你的文件可以很容易地将这个应用程序移植到其他项目，Remix😉) 现在在文件中加入以下代码： expenses.jsx 1234567export default function Expenses() &#123; return ( &lt;main style=&#123;&#123; padding: &quot;1rem 0&quot; &#125;&#125;&gt; &lt;h2&gt;Expenses&lt;/h2&gt; &lt;/main&gt; );&#125; invoices.jsx 1234567export default function Invoices() &#123; return ( &lt;main style=&#123;&#123; padding: &quot;1rem 0&quot; &#125;&#125;&gt; &lt;h2&gt;Invoices&lt;/h2&gt; &lt;/main&gt; );&#125; 最后，让我们通过在main.jsx或者index.js 中创建我们的第一个“路由配置”来让 React Router 在不同的 URL 上呈现我们的界面。 123456789101112131415161718192021import &#123; render &#125; from &quot;react-dom&quot;;import &#123; BrowserRouter, Routes, Route&#125; from &quot;react-router-dom&quot;;import App from &quot;./App&quot;;import Expenses from &quot;./routes/expenses&quot;;import Invoices from &quot;./routes/invoices&quot;;const rootElement = document.getElementById(&quot;root&quot;);render( &lt;BrowserRouter&gt; &lt;Routes&gt; &lt;Route path=&quot;/&quot; element=&#123;&lt;App /&gt;&#125; /&gt; &lt;Route path=&quot;expenses&quot; element=&#123;&lt;Expenses /&gt;&#125; /&gt; &lt;Route path=&quot;invoices&quot; element=&#123;&lt;Invoices /&gt;&#125; /&gt; &lt;/Routes&gt; &lt;/BrowserRouter&gt;, rootElement); 注意：当路由为”&#x2F;“时它渲染App组件，在”&#x2F;invoices”时它渲染Invoices组件。 所以到这里我们可以看出，点击后会整页都会变换掉 嵌套路由你可能已经注意到，当点击链接时，“App”中的布局会消失。共享布局是一件令人头疼的事情。我们已经知道，大多数UI都是一系列嵌套布局，这些布局总会映射到URL上，所以这个思路被直接植入到React Router中。 12345678910111213141516171819202122import &#123; render &#125; from &quot;react-dom&quot;;import &#123; BrowserRouter, Routes, Route&#125; from &quot;react-router-dom&quot;;import App from &quot;./App&quot;;import Expenses from &quot;./routes/expenses&quot;;import Invoices from &quot;./routes/invoices&quot;;const rootElement = document.getElementById(&quot;root&quot;);render( &lt;BrowserRouter&gt; &lt;Routes&gt; &lt;Route path=&quot;/&quot; element=&#123;&lt;App /&gt;&#125;&gt; &lt;Route path=&quot;expenses&quot; element=&#123;&lt;Expenses /&gt;&#125; /&gt; &lt;Route path=&quot;invoices&quot; element=&#123;&lt;Invoices /&gt;&#125; /&gt; &lt;/Route&gt; &lt;/Routes&gt; &lt;/BrowserRouter&gt;, rootElement); 当路由有子节点时，它会做两件事： 它嵌套了 URL (&quot;/&quot; + &quot;expenses&quot; 和 &quot;/&quot; + &quot;invoices&quot;) 当子路由匹配时，它将嵌套共享布局的 UI 组件： 但是，为了使（2）生效，我们需要在App.jsx“父”路由中渲染一个 组件。 12345678910111213141516171819import &#123; Outlet, Link &#125; from &quot;react-router-dom&quot;;export default function App() &#123; return ( &lt;div&gt; &lt;h1&gt;Bookkeeper&lt;/h1&gt; &lt;nav style=&#123;&#123; borderBottom: &quot;solid 1px&quot;, paddingBottom: &quot;1rem&quot; &#125;&#125; &gt; &lt;Link to=&quot;/invoices&quot;&gt;Invoices&lt;/Link&gt; |&#123;&quot; &quot;&#125; &lt;Link to=&quot;/expenses&quot;&gt;Expenses&lt;/Link&gt; &lt;/nav&gt; &lt;Outlet /&gt; &lt;/div&gt; );&#125; 现在再次单击。父路由 ( App.js) 仍然存在，而 &lt;Outlet&gt; 在两个子路由 (&lt;Invoices&gt; 和 &lt;Expenses&gt;)之间切换！ 正如我们稍后将看到的，这适用于路由层次结构的任何级别，并且非常强大。 列出发票通常你会从某个地方的服务器获取数据，但在本教程中，让我们造一些数据，这样我们就可以专注于路由。 创建一个文件src&#x2F;data.js并将其复制&#x2F;粘贴到那里： 123456789101112131415161718192021222324252627282930313233343536let invoices = [ &#123; name: &quot;Santa Monica&quot;, number: 1995, amount: &quot;$10,800&quot;, due: &quot;12/05/1995&quot; &#125;, &#123; name: &quot;Stankonia&quot;, number: 2000, amount: &quot;$8,000&quot;, due: &quot;10/31/2000&quot; &#125;, &#123; name: &quot;Ocean Avenue&quot;, number: 2003, amount: &quot;$9,500&quot;, due: &quot;07/22/2003&quot; &#125;, &#123; name: &quot;Tubthumper&quot;, number: 1997, amount: &quot;$14,000&quot;, due: &quot;09/01/1997&quot; &#125;, &#123; name: &quot;Wide Open Spaces&quot;, number: 1998, amount: &quot;$4,600&quot;, due: &quot;01/27/2998&quot; &#125;];export function getInvoices() &#123; return invoices;&#125; 现在我们可以在发票路由中使用它。让我们也添加一些样式来获得侧边栏导航布局。随意复制&#x2F;粘贴所有这些，但要特别注意 &lt;Link&gt; 组件需要 to 属性： 1234567891011121314151617181920212223242526import &#123; Link &#125; from &quot;react-router-dom&quot;;import &#123; getInvoices &#125; from &quot;../data&quot;;export default function Invoices() &#123; let invoices = getInvoices(); return ( &lt;div style=&#123;&#123; display: &quot;flex&quot; &#125;&#125;&gt; &lt;nav style=&#123;&#123; borderRight: &quot;solid 1px&quot;, padding: &quot;1rem&quot; &#125;&#125; &gt; &#123;invoices.map(invoice =&gt; ( &lt;Link style=&#123;&#123; display: &quot;block&quot;, margin: &quot;1rem 0&quot; &#125;&#125; to=&#123;`/invoices/$&#123;invoice.number&#125;`&#125; key=&#123;invoice.number&#125; &gt; &#123;invoice.name&#125; &lt;/Link&gt; ))&#125; &lt;/nav&gt; &lt;/div&gt; );&#125;","categories":[{"name":"2022","slug":"2022","permalink":"http://example.com/categories/2022/"}],"tags":[{"name":"reat","slug":"reat","permalink":"http://example.com/tags/reat/"}]},{"title":"匿名函数","slug":"匿名函数","date":"2023-02-23T14:17:31.647Z","updated":"2023-02-23T13:50:36.485Z","comments":true,"path":"2023/02/23/匿名函数/","link":"","permalink":"http://example.com/2023/02/23/%E5%8C%BF%E5%90%8D%E5%87%BD%E6%95%B0/","excerpt":"匿名函数","text":"匿名函数 123456789101112131415161718// 1.表达式赋值给变量来使用var fa =function()&#123; console.log(20);&#125;fa();// 2.当作函数来被调用setTimeout(function()&#123;console.log(30);&#125;,1000);// 3.通过函数嵌套当成闭包里的返回函数来调用function fb()&#123; return function()&#123;console.log(40);&#125;&#125;var fm=fb();fm();// 4.函数自己调用自己，也就是自调用。!function()&#123;console.log(50);&#125;();//匿名函数智能被调用或是自调用。//带参数的匿名函数自调用!function(a,b)&#123;console.log(a+b);&#125;(40,50);","categories":[{"name":"2022","slug":"2022","permalink":"http://example.com/categories/2022/"}],"tags":[{"name":"js","slug":"js","permalink":"http://example.com/tags/js/"}]},{"title":"回调函数","slug":"回调函数","date":"2023-02-23T14:17:31.647Z","updated":"2023-02-23T13:50:29.285Z","comments":true,"path":"2023/02/23/回调函数/","link":"","permalink":"http://example.com/2023/02/23/%E5%9B%9E%E8%B0%83%E5%87%BD%E6%95%B0/","excerpt":"回调函数","text":"回调函数 12345678910111213141516171819// 先定义一个函数，用来做短时间或无法脱身的事情，同步function sdo(does)&#123; console.log(does);&#125;// 在定义以恶搞函数，用来做长时间等待的事情，异步//用回调解决这个问题function ldo(doing,callback)&#123; setTimeout(()=&gt;&#123; console.log(doing); callback(&#x27;吃鸡&#x27;) &#125;,1000);&#125;// 接下来要开始迫害只因sdo(&#x27;买鸡&#x27;)sdo(&#x27;杀鸡&#x27;)ldo(&#x27;炖鸡&#x27;,sdo)//===&gt;函数作为参数// sdo(&#x27;吃鸡&#x27;)// 会发现不对劲","categories":[{"name":"2022","slug":"2022","permalink":"http://example.com/categories/2022/"}],"tags":[{"name":"js","slug":"js","permalink":"http://example.com/tags/js/"}]},{"title":"箭头函数","slug":"箭头函数","date":"2023-02-23T14:17:31.647Z","updated":"2023-02-23T13:50:33.998Z","comments":true,"path":"2023/02/23/箭头函数/","link":"","permalink":"http://example.com/2023/02/23/%E7%AE%AD%E5%A4%B4%E5%87%BD%E6%95%B0/","excerpt":"箭头函数","text":"箭头函数 12345678910111213141516// 1.箭头函数常见写法let fun1=(a,b)=&gt;&#123;return a+b;&#125;// 2.箭头函数没有参数，那么也要写括号let fun2=()=&gt;&#123;console.log(&#x27;你好&#x27;);&#125;// 3.如果只有一个参数，那么括号可以省略let fun3=name=&gt;&#123;console.log(`你好$&#123;name&#125;`);&#125;// 4.如果函数体只有一句执行代码，那么可以省略大括号，同时代码默认会被ruturn出去let fun4=name=&gt;`你好$&#123;name&#125;`;console.log(fun4(&#x27;小明&#x27;));// 5.箭头函数没有自己的this，他的this是来自于上层作用域的this let obj=&#123; fun5()&#123;console.log(&#x27;fun5:&#x27;,this);&#125;, fun6:()=&gt;&#123;console.log(&#x27;fun6:&#x27;,this);&#125; &#125; obj.fun5(); obj.fun6();","categories":[{"name":"2022","slug":"2022","permalink":"http://example.com/categories/2022/"}],"tags":[{"name":"js","slug":"js","permalink":"http://example.com/tags/js/"}]},{"title":"解决bash hexo command not found","slug":"解决bash hexo command not found","date":"2023-02-23T14:17:31.647Z","updated":"2023-03-01T07:08:49.612Z","comments":true,"path":"2023/02/23/解决bash hexo command not found/","link":"","permalink":"http://example.com/2023/02/23/%E8%A7%A3%E5%86%B3bash%20hexo%20command%20not%20found/","excerpt":"解决bash: hexo: command not found","text":"解决bash: hexo: command not found 检查 nodejs 和 npm 是否正常，依次输入命令 node -v 和 npm -v 看看是否有相关版本信息 出现了版本信息就证明 nodejs 和 npm 是没有问题的，那么就应该是环境变量的配置问题了，在【此电脑】右键【属性】，依次选择【高级系统设置】-【环境变量】，选择系统变量 Path，将 node_modules 下的 .bin 文件路径添加到 Path 里面 注意你的博客目录下应该有两个 node_modules 文件夹 F:\\blog 和F:\\blog\\BLOG 我是加了第一个module在环境变量 别的博主有的加了第二个module 总之自己试一下按哪个 环境变量添加好了之后重新打开 git 即可运行 hexo 命令，如果此时仍然无法执行 hexo 命令，那就只能拿出终极绝招了，运行命令 npm install hexo-cli -g 重新安装 hexo 即可！","categories":[{"name":"2023","slug":"2023","permalink":"http://example.com/categories/2023/"}],"tags":[{"name":"hexo","slug":"hexo","permalink":"http://example.com/tags/hexo/"}]},{"title":"PyQt5显示图片","slug":"PyQt5显示图片","date":"2023-02-23T14:17:31.640Z","updated":"2023-02-23T14:03:39.746Z","comments":true,"path":"2023/02/23/PyQt5显示图片/","link":"","permalink":"http://example.com/2023/02/23/PyQt5%E6%98%BE%E7%A4%BA%E5%9B%BE%E7%89%87/","excerpt":"PyQt5显示图片","text":"PyQt5显示图片 123redImg=QImage()QImage.load(redImg,&#x27;path&#x27;,format=&#x27;png&#x27;)self.label_3.setPixmap(QtGui.QPixmap(redImg)) 123img_path=&#x27;path&#x27;self.showImage = QPixmap(img_path).scaled(self.label_3.width(), self.label_3.height()) # 适应窗口大小self.label_3.setPixmap(self.showImage) # 显示图片 1234567image=cv2.imread(&#x27;path&#x27;)def showImageRed(self): self.image_1 = self.image self.image_1 = QtGui.QImage(self.image_1.data, self.image_1.shape[1],self.image_1.shape[0],QtGui.QImage.Format_RGB888).rgbSwapped() self.label_3.setPixmap(QtGui.QPixmap.fromImage(self.image_1)) 第三种方法可能会有斜影子，修改成下方这样 1234def showImageRed(self): self.image_1 = self.image self.image_1 = QtGui.QImage(self.image_1.data, self.image_1.shape[1], self.image_1.shape[0],self.image_1.shape[1]*3, QtGui.QImage.Format_RGB888).rgbSwapped() self.label_3.setPixmap(QtGui.QPixmap.fromImage(self.image_1)) 感觉应该是三通道问题","categories":[{"name":"2022","slug":"2022","permalink":"http://example.com/categories/2022/"}],"tags":[{"name":"PyQt5","slug":"PyQt5","permalink":"http://example.com/tags/PyQt5/"}]},{"title":"Hello World","slug":"hello-world","date":"2023-02-23T14:17:31.624Z","updated":"2023-02-06T13:37:47.659Z","comments":true,"path":"2023/02/23/hello-world/","link":"","permalink":"http://example.com/2023/02/23/hello-world/","excerpt":"hello","text":"hello Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new &quot;My New Post&quot; More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","categories":[],"tags":[]},{"title":"mysql报错ERROR 1045 (28000) Access denied for user 'root'@'localhost' (using password:NO)","slug":"mysql启动","date":"2023-02-23T14:17:31.624Z","updated":"2023-02-23T14:12:54.315Z","comments":true,"path":"2023/02/23/mysql启动/","link":"","permalink":"http://example.com/2023/02/23/mysql%E5%90%AF%E5%8A%A8/","excerpt":"ERROR 1045 (28000): Access denied for user ‘root‘@’localhost’ (using password: NO)","text":"ERROR 1045 (28000): Access denied for user ‘root‘@’localhost’ (using password: NO) E:\\jeecg\\jeecg-boot-master\\db\\jeecgboot-mysql-5.7.sql","categories":[{"name":"2023","slug":"2023","permalink":"http://example.com/categories/2023/"}],"tags":[{"name":"mysql","slug":"mysql","permalink":"http://example.com/tags/mysql/"}]},{"title":"maven 找不到依赖项 javax.servlet:servlet-api:${servlet-api.version}","slug":"maven","date":"2023-02-23T14:17:31.624Z","updated":"2023-02-23T14:10:17.356Z","comments":true,"path":"2023/02/23/maven/","link":"","permalink":"http://example.com/2023/02/23/maven/","excerpt":"找不到依赖项 javax.servlet:servlet-api:${servlet-api.version}1.下载maven百度","text":"找不到依赖项 javax.servlet:servlet-api:${servlet-api.version}1.下载maven百度 2.maven仓库查找 https://mvnrepository.com/ 直接搜索 比如 直接搜索 然后 点击之后往下移动 找到这一行 贴到pom.xml文件里 坐标组成 配置本地仓库 中央仓库 id唯一标识符，用来区分不同的mirror元素 mirrorOf代替哪个仓库 url镜像的URL","categories":[{"name":"2023","slug":"2023","permalink":"http://example.com/categories/2023/"}],"tags":[{"name":"maven","slug":"maven","permalink":"http://example.com/tags/maven/"}]},{"title":"npm install 包，没有报错，提示安装成功，但是项目中没有出现node_modules也没有安装的包","slug":"npm npm install hexo-cli -g","date":"2023-02-23T14:17:31.624Z","updated":"2023-03-01T07:07:25.030Z","comments":true,"path":"2023/02/23/npm npm install hexo-cli -g/","link":"","permalink":"http://example.com/2023/02/23/npm%20npm%20install%20hexo-cli%20-g/","excerpt":"npm install 包，没有报错，提示安装成功，但是项目中没有出现node_modules也没有安装的包1npm install hexo-cli -g","text":"npm install 包，没有报错，提示安装成功，但是项目中没有出现node_modules也没有安装的包1npm install hexo-cli -g 在当前文件夹目录下npm安装 hexo-cli -g 在当前文件夹不显示 因为这是全局安装 所以会跑到node.js文件夹目录底下 去这边找会发现一个hexo-cli的文件夹 点击这个博客[https://blog.csdn.net/qq_38613992/article/details/103769192] 查看npm的配置 1npm config list 一开始我是没有global&#x3D;？？？ 的 2.查看全局下，是否有自己安装的包 123npm root -g//获取到全局安装目录 一般看上面那个F盘的图，会在那里 3.修改npm配置信息，查看 图例1，global属性是否安装到全局，如果你的这里是true，那么，就算你安装一个包时，没有写-g，它也会自动将你的包安装到全局！ — 修改配置信息 方法一：命令行输入 123npm config set global=false，npm config set global=false 再次查看配置，确认是否修改 1npm config list 然后再 1npm install hexo-cli 后面不要-g就会在自己的文件夹里出现node_moudle了 你可以试试有-g的&#96;&#96;&#96;npm install hexo-cli&#96;&#96;，这样的话，就又会跑到node.js的global的moudle的文件夹里了 安装完成，如图","categories":[{"name":"2023","slug":"2023","permalink":"http://example.com/categories/2023/"}],"tags":[{"name":"hexo","slug":"hexo","permalink":"http://example.com/tags/hexo/"}]},{"title":"PyQt5","slug":"pyqt5","date":"2023-02-23T14:17:31.624Z","updated":"2023-02-23T14:03:21.742Z","comments":true,"path":"2023/02/23/pyqt5/","link":"","permalink":"http://example.com/2023/02/23/pyqt5/","excerpt":"安装PyQt5打开Anaconda Promt，切换到对应环境输入：","text":"安装PyQt5打开Anaconda Promt，切换到对应环境输入： 1pip install PyQt5 -i https://pypi.douban.com/simple 安装PyQt5-tools 12pip install PyQt5-tools -i https://pypi.douban.com/simple 打开 Anaconda prompt 输入: 1PyQt5-tools designer 它有很多东西 1234designerinstalluicqmlsceneqmltestrunner 不知道其他是啥（待解决） 直接点击创建（main window） 随便拖两个button上去 另存为 然后回到anaconda那个窗口， 我们要把这个.ui文件转化为py文件 方法一： 1python -m PyQt5.uic.pyuic test.ui -o test.py 要切换到相对应的文件夹路径下再运行 已经生成了 方法二： 太烦了，不写 F:\\anaconda\\EMPYTY\\pkgs\\pyqt-5.9.2-py39hd77b12b_6\\Library\\bin 大概在这个路径里面 很鸡肋，虽然写的前面的那玩意少了点，但是要吧ui移到当前文件夹里面，辣鸡 1pyuic5 test.ui -o test.py 方法三：直接使用扩展程序打开 pycharm扩展程序（vscode没找到在哪） 不太好搞（不想写，没看懂） 综上，用方法一 1.水平布局 回到vscode里面 123456789101112131415import sysimport shuipingfrom PyQt5.QtWidgets import QApplication,QMainWindow#创建QApplication类的实例app=QApplication(sys.argv)#创建一个窗口mainWindow=QMainWindow()#向主窗口添加控件ui=shuiping.Ui_MainWindow()ui.setupUi(mainWindow)# 显示窗口mainWindow.show()# 进入程序的主循环、并通过exit函数确保主循环安全结束sys.exit(app.exec_()) 表单布局 垂直布局 栅格布局 尺寸策略 伙伴关系 tab顺序 编辑信号和槽","categories":[{"name":"2022","slug":"2022","permalink":"http://example.com/categories/2022/"}],"tags":[{"name":"PyQt5","slug":"PyQt5","permalink":"http://example.com/tags/PyQt5/"}]},{"title":"之前的博客慢慢再修复，先把最近的东西放上来，sos！","slug":"breautiful","date":"2023-02-23T14:17:31.609Z","updated":"2023-02-23T13:41:12.493Z","comments":true,"path":"2023/02/23/breautiful/","link":"","permalink":"http://example.com/2023/02/23/breautiful/","excerpt":"","text":"之前的博客慢慢再修复，先把最近的东西放上来，sos！","categories":[{"name":"2023","slug":"2023","permalink":"http://example.com/categories/2023/"}],"tags":[{"name":"casual_talk","slug":"casual-talk","permalink":"http://example.com/tags/casual-talk/"}]},{"title":"C++文件操作之freopen","slug":"C++文件操作之freopen","date":"2023-02-23T14:17:31.609Z","updated":"2023-02-23T13:51:59.659Z","comments":true,"path":"2023/02/23/C++文件操作之freopen/","link":"","permalink":"http://example.com/2023/02/23/C++%E6%96%87%E4%BB%B6%E6%93%8D%E4%BD%9C%E4%B9%8Bfreopen/","excerpt":"C++文件操作之freopen","text":"C++文件操作之freopen 12freopen(&quot;xxx.in&quot;,&quot;r&quot;,stdin); //输入文件freopen(&quot;xxx.out&quot;,&quot;w&quot;,stdout); //输出文件 1234567891011121314#include&lt;cstdio&gt;#include&lt;iostream&gt;using namespace std;int main()&#123; freopen(&quot;a+b.in&quot;,&quot;r&quot;,stdin); freopen(&quot;a+b.out&quot;,&quot;w&quot;,stdout); //以上是模板 int a,b; cin&gt;&gt;a&gt;&gt;b; cout&lt;&lt;a+b&lt;&lt;endl; return 0;&#125;","categories":[{"name":"2023","slug":"2023","permalink":"http://example.com/categories/2023/"}],"tags":[{"name":"c++","slug":"c","permalink":"http://example.com/tags/c/"}]},{"title":"Failed to scan","slug":"Failed to scan [fileFmavenrepositoryorgspringframeworkspring-aspects5","date":"2023-02-23T14:17:31.609Z","updated":"2023-02-23T13:53:39.577Z","comments":true,"path":"2023/02/23/Failed to scan [fileFmavenrepositoryorgspringframeworkspring-aspects5/","link":"","permalink":"http://example.com/2023/02/23/Failed%20to%20scan%20[fileFmavenrepositoryorgspringframeworkspring-aspects5/","excerpt":"Failed to scan [file:&#x2F;F:&#x2F;maven&#x2F;repository&#x2F;org&#x2F;springframework&#x2F;spring-aspects&#x2F;5.1.9.RELEASE&#x2F;spring-aspects-5.1.9.RELEASE.jar] from classloader hierarchyjava.util.zip.ZipException: error in opening zip file","text":"Failed to scan [file:&#x2F;F:&#x2F;maven&#x2F;repository&#x2F;org&#x2F;springframework&#x2F;spring-aspects&#x2F;5.1.9.RELEASE&#x2F;spring-aspects-5.1.9.RELEASE.jar] from classloader hierarchyjava.util.zip.ZipException: error in opening zip file 1mvn install:install-file -DgroupId=com.qiyuesuo.sdk -DartifactId=sdk-java -Dversion=3.4.1 -Dpackaging=jar -Dfile=D:\\jar\\sdk-java-3.4.1.jar 1F:\\maven\\repository\\org\\springframework\\spring-aspects\\5.1.9.RELEASE org.springframework.spring-aspects 12mvn install:install-file -DgroupId=org.springframework.spring-aspects-DartifactId=spring-aspects -Dversion=5.3.1 -Dpackaging=jar -Dfile=F:\\maven\\spring-aspects-5.3.1.jar mvn install:install-file -DgroupId&#x3D;org.springframework.spring-aspects-DartifactId&#x3D;spring-aspects -Dversion&#x3D;5.3.1 -Dpackaging&#x3D;jar -Dfile&#x3D;F:\\maven\\spring-aspects-5.3.1.jar","categories":[{"name":"2023","slug":"2023","permalink":"http://example.com/categories/2023/"}],"tags":[{"name":"maven","slug":"maven","permalink":"http://example.com/tags/maven/"}]}],"categories":[{"name":"代码随想录","slug":"代码随想录","permalink":"http://example.com/categories/%E4%BB%A3%E7%A0%81%E9%9A%8F%E6%83%B3%E5%BD%95/"},{"name":"2023","slug":"2023","permalink":"http://example.com/categories/2023/"},{"name":"2022","slug":"2022","permalink":"http://example.com/categories/2022/"}],"tags":[{"name":"哈希表","slug":"哈希表","permalink":"http://example.com/tags/%E5%93%88%E5%B8%8C%E8%A1%A8/"},{"name":"vector容器","slug":"vector容器","permalink":"http://example.com/tags/vector%E5%AE%B9%E5%99%A8/"},{"name":"链表","slug":"链表","permalink":"http://example.com/tags/%E9%93%BE%E8%A1%A8/"},{"name":"casual_talk","slug":"casual-talk","permalink":"http://example.com/tags/casual-talk/"},{"name":"数组总结","slug":"数组总结","permalink":"http://example.com/tags/%E6%95%B0%E7%BB%84%E6%80%BB%E7%BB%93/"},{"name":"螺旋矩阵","slug":"螺旋矩阵","permalink":"http://example.com/tags/%E8%9E%BA%E6%97%8B%E7%9F%A9%E9%98%B5/"},{"name":"大数据可视化","slug":"大数据可视化","permalink":"http://example.com/tags/%E5%A4%A7%E6%95%B0%E6%8D%AE%E5%8F%AF%E8%A7%86%E5%8C%96/"},{"name":"滑动窗口","slug":"滑动窗口","permalink":"http://example.com/tags/%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3/"},{"name":"map和unordered_map","slug":"map和unordered-map","permalink":"http://example.com/tags/map%E5%92%8Cunordered-map/"},{"name":"c++最大值","slug":"c-最大值","permalink":"http://example.com/tags/c-%E6%9C%80%E5%A4%A7%E5%80%BC/"},{"name":"双指针法","slug":"双指针法","permalink":"http://example.com/tags/%E5%8F%8C%E6%8C%87%E9%92%88%E6%B3%95/"},{"name":"memset函数","slug":"memset函数","permalink":"http://example.com/tags/memset%E5%87%BD%E6%95%B0/"},{"name":"二分查找","slug":"二分查找","permalink":"http://example.com/tags/%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE/"},{"name":"search方法","slug":"search方法","permalink":"http://example.com/tags/search%E6%96%B9%E6%B3%95/"},{"name":"Spark","slug":"Spark","permalink":"http://example.com/tags/Spark/"},{"name":"设计模式","slug":"设计模式","permalink":"http://example.com/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"},{"name":"spark","slug":"spark","permalink":"http://example.com/tags/spark/"},{"name":"django","slug":"django","permalink":"http://example.com/tags/django/"},{"name":"操作系统","slug":"操作系统","permalink":"http://example.com/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"},{"name":"python","slug":"python","permalink":"http://example.com/tags/python/"},{"name":"linux_c++","slug":"linux-c","permalink":"http://example.com/tags/linux-c/"},{"name":"java","slug":"java","permalink":"http://example.com/tags/java/"},{"name":"vmware","slug":"vmware","permalink":"http://example.com/tags/vmware/"},{"name":"mysql","slug":"mysql","permalink":"http://example.com/tags/mysql/"},{"name":"powershell","slug":"powershell","permalink":"http://example.com/tags/powershell/"},{"name":"anaconda","slug":"anaconda","permalink":"http://example.com/tags/anaconda/"},{"name":"js","slug":"js","permalink":"http://example.com/tags/js/"},{"name":"reat","slug":"reat","permalink":"http://example.com/tags/reat/"},{"name":"hexo","slug":"hexo","permalink":"http://example.com/tags/hexo/"},{"name":"PyQt5","slug":"PyQt5","permalink":"http://example.com/tags/PyQt5/"},{"name":"maven","slug":"maven","permalink":"http://example.com/tags/maven/"},{"name":"c++","slug":"c","permalink":"http://example.com/tags/c/"}]}