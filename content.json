{"meta":{"title":"睡觉万岁","subtitle":"","description":"在梦里啥都有","author":"毛","url":"http://example.com","root":"/"},"pages":[{"title":"about","date":"2022-12-31T14:33:19.000Z","updated":"2023-03-15T10:30:14.364Z","comments":true,"path":"about/index.html","permalink":"http://example.com/about/index.html","excerpt":"","text":"欠的债迟早都要还的！~！~！~！~！ 不要急躁，静心高效做好每一件事情"},{"title":"分类","date":"2022-12-31T14:33:04.000Z","updated":"2022-12-31T14:36:05.876Z","comments":false,"path":"categories/index.html","permalink":"http://example.com/categories/index.html","excerpt":"","text":""},{"title":"资源","date":"2022-12-31T14:33:21.000Z","updated":"2022-12-31T14:37:12.176Z","comments":false,"path":"resources/index.html","permalink":"http://example.com/resources/index.html","excerpt":"","text":""},{"title":"标签","date":"2022-12-31T14:33:16.000Z","updated":"2022-12-31T14:36:40.295Z","comments":false,"path":"tags/index.html","permalink":"http://example.com/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"操作系统——进程同步——哲学家进餐问题","slug":"操作系统——进程同步——哲学家进餐问题","date":"2023-03-24T00:43:48.827Z","updated":"2023-03-24T00:44:51.621Z","comments":true,"path":"2023/03/24/操作系统——进程同步——哲学家进餐问题/","link":"","permalink":"http://example.com/2023/03/24/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E2%80%94%E2%80%94%E8%BF%9B%E7%A8%8B%E5%90%8C%E6%AD%A5%E2%80%94%E2%80%94%E5%93%B2%E5%AD%A6%E5%AE%B6%E8%BF%9B%E9%A4%90%E9%97%AE%E9%A2%98/","excerpt":"","text":"哲学家进餐问题复习一下pv操作互斥锁 pv操作","categories":[{"name":"2023","slug":"2023","permalink":"http://example.com/categories/2023/"}],"tags":[{"name":"操作系统","slug":"操作系统","permalink":"http://example.com/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"}]},{"title":"3-23-2023","slug":"3-23-2023","date":"2023-03-23T08:42:33.569Z","updated":"2023-03-23T08:59:22.581Z","comments":true,"path":"2023/03/23/3-23-2023/","link":"","permalink":"http://example.com/2023/03/23/3-23-2023/","excerpt":"放平心态不焦虑","text":"放平心态不焦虑 加油咯 1.接下来目标，确定中介，交钱，保底。 2.加油把手上的东西学完（这周把它干掉交比赛） 3.刷数据结构算法&&慢慢看数学慢慢刷题(方平心态) 4.美团笔试准备摆烂","categories":[{"name":"2023","slug":"2023","permalink":"http://example.com/categories/2023/"}],"tags":[{"name":"casual_talk","slug":"casual-talk","permalink":"http://example.com/tags/casual-talk/"}]},{"title":"设计模式--外观模式","slug":"外观模式","date":"2023-03-22T09:24:51.046Z","updated":"2023-03-23T08:59:49.480Z","comments":true,"path":"2023/03/22/外观模式/","link":"","permalink":"http://example.com/2023/03/22/%E5%A4%96%E8%A7%82%E6%A8%A1%E5%BC%8F/","excerpt":"外观模式","text":"外观模式 模式动机为子系统中的一组接口提供一个一致的界面，外观模式定义了一个高层接口，这个接口使得这一子系统更加容易使用。 外观模式是为了解决类与类之间的依赖关系的，像spring一样，可以将类和类之间的关系配置到配置文件中，而外观模式就是将其关系放在一个Facade类中，降低了类类之间的耦合度，该模式中没有涉及到接口。 模式定义外观模式(Facade Pattern)：外部与一个子系统的通信必须通过一个统一的外观对象进行，为子系统中的一组接口提供一个一致的界面，外观模式定义了一个高层接口，这个接口使得这一子系统更加容易使用。外观模式又称为门面模式，它是一种对象结构型模式。 该模式对外有一个统一接口，外部应用程序不用关心内部子系统的具体的细节，这样会大大降低应用程序的复杂度，提高了程序的可维护性。 外观（Facade）模式是“迪米特法则”的典型应用 模式结构 Facade: 外观角色。为多个子系统对外提供一个共同的接口。 SubSystem:子系统角色。实现系统的部分功能，客户可以通过外观角色访问它。 Client：客户 角色 时序图 外观模式抽象代码 外观模式分析 根据“单一职责原则”，在软件中将一个系统划分为若干个子系统有利于降低整个系统的复杂性，一个常见的设计目标是使子系统间的通信和相互依赖关系达到最小，而达到该目标的途径之一就是引入一个外观对象，它为子系统的访问提供了一个简单而单一的入口。 外观模式也是“迪米特法则”的体现，通过引入一个新的外观类可以降低原有系统的复杂度，同时降低客户类与子系统类的耦合度。 外观模式要求一个子系统的外部与其内部的通信通过一个统一的外观对象进行，外观类将客户端与子系统的内部复杂性分隔开，使得客户端只需要与外观对象打交道，而不需要与子系统内部的很多对象打交道。 外观模式的目的在于降低系统的复杂程度。 外观模式从很大程度上提高了客户端使用的便捷性，使得客户端无须关心子系统的工作细节，通过外观角色即可调用相关功能。 外观模式实例比如电脑是由CPU、内存、磁盘等部件组成，当启动电脑的时候，需要依次启动CPU、内存和磁盘等部件。CPU、Memory、Disk他们之间将会相互持有实例，产生关系，这样会造成严重的依赖，修改一个类，可能会带来其他类的修改。对于用户而言，其只需要知道可以把电脑打开即可。可以适用外观模式来设计该实例。类图如下图所示。 代码文件，CPU.java Memory.java Disk.java Computer.java（外观类） Client.java 引入外观角色之后，用户只需要直接与外观角色交互，用户与子系统之间的复杂关系由外观角色来实现，从而降低了系统的耦合度。 外观模式优点 对客户屏蔽子系统组件，减少了客户处理的对象数目并使得子系统使用起来更加容易。通过引入外观模式，客户代码将变得很简单，与之关联的对象也很少。 实现了子系统与客户之间的松耦合关系，这使得子系统的组件变化不会影响到调用它的客户类，只需要调整外观类即可。 降低了大型软件系统中的编译依赖性，并简化了系统在不同平台之间的移植过程，因为编译一个子系统一般不需要编译所有其他的子系统。一个子系统的修改对其他子系统没有任何影响，而且子系统内部变化也不会影响到外观对象。 只是提供了一个访问子系统的统一入口，并不影响用户直接使用子系统类。 外观模式缺点 不能很好地限制客户使用子系统类，如果对客户访问子系统类做太多的限制则减少了可变性和灵活性。 在不引入抽象外观类的情况下，增加新的子系统可能需要修改外观类或客户端的源代码，违背了“开闭原则”。 外观模式适用环境 当要为一个复杂子系统提供一个简单接口时可以使用外观模式。该接口可以满足大多数用户的需求，而且用户也可以越过外观类直接访问子系统。 客户程序与多个子系统之间存在很大的依赖性。引入外观类将子系统与客户以及其他子系统解耦，可以提高子系统的独立性和可移植性。 在层次化结构中，可以使用外观模式定义系统中每一层的入口，层与层之间不直接产生联系，而通过外观类建立联系，降低层之间的耦合度。 外观模式应用在Java核心库中，下面的类使用了外观模式。 javax.faces.context.FacesContext。该类使用了LifeCycle、ViewHandler、NavigationHandler等类。但用户直接使用FacesContext，并不觉得使用了后面的三个类。 javax.faces.context.ExternalContext 。该类使用了ServletContext，HttpSession，HttpServletRequest，HttpServletResponse等类。 JDBCFacade 识别方法： 如果一个类提供了一个简单的接口，但是其工作实际由其它类来完成，则可以认为是个外观类。通常外观类管理其使用对象的整个生命周期。 外观模式扩展 在外观模式中，通常只需要一个外观类，并且此外观类只有一个实例，换言之它是一个单例类。在很多情况下为了节约系统资源，一般将外观类设计为单例类。当然这并不意味着在整个系统里只能有一个外观类，在一个系统中可以设计多个外观类，每个外观类都负责和一些特定的子系统交互，向用户提供相应的业务功能。 不要通过继承一个外观类在子系统中加入新的行为，这种做法是错误的。外观模式的用意是为子系统提供一个集中化和简化的沟通渠道，而不是向子系统加入新的行为，新的行为的增加应该通过修改原有子系统类或增加新的子系统类来实现，不能通过外观类来实现。 外观模式最大的缺点在于违背了“开闭原则”，当增加新的子系统或者移除子系统时需要修改外观类，可以通过引入抽象外观类在一定程度上解决该问题，客户端针对抽象外观类进行编程。对于新的业务需求，不修改原有外观类，而对应增加一个新的具体外观类，由新的具体外观类来关联新的子系统对象，同时通过修改配置文件来达到不修改源代码并更换外观类的目的。 外观模式总结 在外观模式中，外部与一个子系统的通信必须通过一个统一的外观对象进行，为子系统中的一组接口提供一个一致的界面，外观模式定义了一个高层接口，这个接口使得这一子系统更加容易使用。外观模式又称为门面模式，它是一种对象结构型模式。 外观模式包含两个角色：外观角色是在客户端直接调用的角色，在外观角色中可以知道相关的(一个或者多个)子系统的功能和责任，它将所有从客户端发来的请求委派到相应的子系统去，传递给相应的子系统对象处理；在软件系统中可以同时有一个或者多个子系统角色，每一个子系统可以不是一个单独的类，而是一个类的集合，它实现子系统的功能。 外观模式要求一个子系统的外部与其内部的通信通过一个统一的外观对象进行，外观类将客户端与子系统的内部复杂性分隔开，使得客户端只需要与外观对象打交道，而不需要与子系统内部的很多对象打交道。 外观模式主要优点在于对客户屏蔽子系统组件，减少了客户处理的对象数目并使得子系统使用起来更加容易，它实现了子系统与客户之间的松耦合关系，并降低了大型软件系统中的编译依赖性，简化了系统在不同平台之间的移植过程；其缺点在于不能很好地限制客户使用子系统类，而且在不引入抽象外观类的情况下，增加新的子系统可能需要修改外观类或客户端的源代码，违背了“开闭原则”。 外观模式适用情况包括：要为一个复杂子系统提供一个简单接口；客户程序与多个子系统之间存在很大的依赖性；在层次化结构中，需要定义系统中每一层的入口，使得层与层之间不直接产生联系。","categories":[{"name":"2023","slug":"2023","permalink":"http://example.com/categories/2023/"}],"tags":[{"name":"设计模式","slug":"设计模式","permalink":"http://example.com/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"}]},{"title":"django_搜索校验分页","slug":"django_搜索校验分页","date":"2023-03-21T14:12:05.357Z","updated":"2023-03-22T14:06:08.804Z","comments":true,"path":"2023/03/21/django_搜索校验分页/","link":"","permalink":"http://example.com/2023/03/21/django_%E6%90%9C%E7%B4%A2%E6%A0%A1%E9%AA%8C%E5%88%86%E9%A1%B5/","excerpt":"","text":"搜索12##搜索PrettyNum.objects.filter&#123;mobile=&#x27;13906135233&#x27;,&quot;id&quot;:123&#125; 1234data_dict=&#123;&quot;mobile&quot;:&quot;13906135233&quot;,&quot;id&quot;:123&#125;PrettyNum.objects.filter(**data_dict) 1234567PrettyNum.objects.filter(id=12) 等于12PrettyNum.objects.filter(id__gt=12) 大于12PrettyNum.objects.filter(id__gte=12) 大于等于12PrettyNum.objects.filter(id__lt=12) 小于12PrettyNum.objects.filter(id__lte=12) 小于等于12data_dict=&#123;&quot;id__lte&quot;:12&#125; 123PrettyNum.objects.filter(mobile=&#x27;233&#x27;) 等于 PrettyNum.objects.filter(mobile__startswitch=&quot;139&quot;) 筛选出以139开头PrettyNum.objects.filter(mobile__endswitch=&quot;233&quot;) 筛选出以233结尾PrettyNum.objects.filter(mobile__contains=&quot;5233&quot;) 筛选出包含5233 123# usedata_dict=&#123;&quot;mobile__contains&quot;:&quot;233&quot;&#125;PrettyNum.objects.filter(**data_dict) 校验1234567from django.core.exceptions import ValidationError# 验证方法一mobile=forms.CharField( label=&quot;手机号&quot;, disabled=True, validators=[RegexValidator(r&#x27;^1[3-9]\\d&#123;9&#125;$&#x27;,&#x27;手机号格式错误&#x27;)], ) 12345678910111213from django.core.validators import RegexValidator# 验证方法二 def clean_mobile(self): txt_mobile=self.cleaned_data[&quot;mobile&quot;] exists=PrettyNum.objects.filter(mobile=txt_mobile).exists() if len(txt_mobile)!=11: #验证不通过 raise ValidationError(&quot;格式错误&quot;) if exists: #验证不通过 raise ValidationError(&quot;手机号已存在&quot;) return txt_mobile 123456789101112131415161718192021222324252627282930class PrettyForm(forms.ModelForm): # 验证方法一 # mobile=forms.CharField( # label=&quot;手机号&quot;, # validators=[RegexValidator(r&#x27;^1[3-9]\\d&#123;9&#125;$&#x27;,&#x27;手机号格式错误&#x27;)] # ) class Meta: model=PrettyNum fields=[&#x27;mobile&#x27;,&#x27;price&#x27;,&#x27;level&#x27;,&#x27;status&#x27;] # fields=&quot;__all__&quot; # exclude=[&#x27;level&#x27;] widgets=&#123; &quot;mobile&quot;:forms.TextInput(attrs=&#123;&quot;class&quot;:&quot;form-control&quot;&#125;), &quot;price&quot;:forms.TextInput(attrs=&#123;&quot;class&quot;:&quot;form-control&quot;&#125;), &quot;level&quot;:forms.TextInput(attrs=&#123;&quot;class&quot;:&quot;form-control&quot;&#125;), &quot;status&quot;:forms.TextInput(attrs=&#123;&quot;class&quot;:&quot;form-control&quot;&#125;), &#125;# 验证方法二 def clean_mobile(self): txt_mobile=self.cleaned_data[&quot;mobile&quot;] exists=PrettyNum.objects.filter(mobile=txt_mobile).exists() if len(txt_mobile)!=11: #验证不通过 raise ValidationError(&quot;格式错误&quot;) if exists: #验证不通过 raise ValidationError(&quot;手机号已存在&quot;) return txt_mobile 1234data_dict=&#123;&#125;value=request.GET.get(&#x27;q&#x27;,&#x27;&#x27;)if value: data_dict[&quot;mobile__contains&quot;] = value qurylist=PrettyNum.objects.filter(**data_dict).order_by(&quot;-level&quot;) 分页1qurylist=PrettyNum.objects.all()#所有的 1qurylist=PrettyNum.objects.filter(id=4)[0:10]#id为4的前十页 1qurylist=PrettyNum.objects.all()[0:10]#第一页 1qurylist=PrettyNum.objects.all()[10:20]#第二页 1qurylist=PrettyNum.objects.all()[20:30]#第三页 12345page=int(request.GET.get(&#x27;page&#x27;,1))start=(page-1)*10end=page*10qurylist=PrettyNum.objects.filter(**data_dict).order_by(&quot;-level&quot;)[start:end]return render(request,&#x27;pretty_list.html&#x27;,&#123;&#x27;qurylist&#x27;:qurylist,&quot;search_data&quot;:value&#125;) 12345678910111213141516171819&lt;nav aria-label=&quot;Page navigation&quot;&gt; &lt;ul class=&quot;pagination&quot;&gt; &lt;li&gt; &lt;a href=&quot;#&quot; aria-label=&quot;Previous&quot;&gt; &lt;span aria-hidden=&quot;true&quot;&gt;«&lt;/span&gt; &lt;/a&gt; &lt;/li&gt; &lt;li&gt;&lt;a href=&quot;/pretty/list/?page=1&quot;&gt;1&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=&quot;?page=2&quot;&gt;2&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=&quot;?page=3&quot;&gt;3&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=&quot;?page=4&quot;&gt;4&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=&quot;?page=5&quot;&gt;5&lt;/a&gt;&lt;/li&gt; &lt;li&gt; &lt;a href=&quot;#&quot; aria-label=&quot;Next&quot;&gt; &lt;span aria-hidden=&quot;true&quot;&gt;»&lt;/span&gt; &lt;/a&gt; &lt;/li&gt; &lt;/ul&gt;&lt;/nav&gt; 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869#分页 # qurylist=PrettyNum.objects.all() # qurylist=PrettyNum.objects.filter(id=4)[0:10] # qurylist=PrettyNum.objects.all()[0:10] # qurylist=PrettyNum.objects.all()[10:20] # qurylist=PrettyNum.objects.all()[20:30] page=int(request.GET.get(&#x27;page&#x27;,1)) pageSize=10 start=(page-1)*pageSize end=page*pageSize qurylist=PrettyNum.objects.filter(**data_dict).order_by(&quot;-level&quot;)[start:end] #总数据条数 total_count=PrettyNum.objects.filter(**data_dict).order_by(&quot;-level&quot;).count() #总页码 total_page_count,div=divmod(total_count,pageSize) if div: total_page_count+=1 # 计算出，显示当前页的前5页、后5页 plus=5 if total_page_count&lt;=2*plus+1: #数据库中的数据比较少，都没有达到11页 start_page=1 end_page=total_page_count else: #数据库中的数据比较多 &gt;11页 #当前页&lt;5时(极小值) if page&lt;=plus: start_page=1 end_page=2*plus+1 else: #当前页&gt;5 #当前页+5&gt;总页面 if (page+plus)&gt;total_page_count: start_page=total_page_count-2*plus end_page=total_page_count else: start_page=page-plus end_page=page+plus #页码 page_str_list=[] #首页 page_str_list.append(&#x27;&lt;li&gt;&lt;a href=&quot;?page=&#123;&#125;&quot;&gt;首页&lt;/a&gt;&lt;/li&gt;&#x27;.format(1)) #上一页 if page&gt;1: prev=&#x27;&lt;li&gt;&lt;a href=&quot;?page=&#123;&#125;&quot;&gt;上一页&lt;/a&gt;&lt;/li&gt;&#x27;.format(page-1) else: prev=&#x27;&lt;li&gt;&lt;a href=&quot;?page=&#123;&#125;&quot;&gt;上一页&lt;/a&gt;&lt;/li&gt;&#x27;.format(1) page_str_list.append(prev) for i in range(start_page,end_page+1): if i==page: ele=&#x27;&lt;li class=&quot;active&quot;&gt;&lt;a href=&quot;?page=&#123;&#125;&quot;&gt;&#123;&#125;&lt;/a&gt;&lt;/li&gt;&#x27;.format(i,i) else: ele=&#x27;&lt;li&gt;&lt;a href=&quot;?page=&#123;&#125;&quot;&gt;&#123;&#125;&lt;/a&gt;&lt;/li&gt;&#x27;.format(i,i) page_str_list.append(ele) #下一页 if page&lt;total_page_count: prev=&#x27;&lt;li&gt;&lt;a href=&quot;?page=&#123;&#125;&quot;&gt;下一页&lt;/a&gt;&lt;/li&gt;&#x27;.format(page+1) else: prev=&#x27;&lt;li&gt;&lt;a href=&quot;?page=&#123;&#125;&quot;&gt;下一页&lt;/a&gt;&lt;/li&gt;&#x27;.format(total_page_count) page_str_list.append(prev) #尾页 page_str_list.append(&#x27;&lt;li&gt;&lt;a href=&quot;?page=&#123;&#125;&quot;&gt;尾页&lt;/a&gt;&lt;/li&gt;&#x27;.format(total_page_count)) page_string =mark_safe(&quot;&quot;.join(page_str_list)) return render(request,&#x27;pretty_list.html&#x27;,&#123;&#x27;qurylist&#x27;:qurylist,&quot;search_data&quot;:value,&quot;page_string&quot;:page_string&#125;) 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115def pretty_list(request):##搜索# --------------------# 1.PrettyNum.objects.filter&#123;mobile=&#x27;13906135233&#x27;,&quot;id&quot;:123&#125;# 2.data_dict=&#123;&quot;mobile&quot;:&quot;13906135233&quot;,&quot;id&quot;:123&#125;# PrettyNum.objects.filter(**data_dict)# --------------------------------# PrettyNum.objects.filter(id=12) 等于12# PrettyNum.objects.filter(id__gt=12) 大于12# PrettyNum.objects.filter(id__gte=12) 大于等于12# PrettyNum.objects.filter(id__lt=12) 小于12# PrettyNum.objects.filter(id__lte=12) 小于等于12# data_dict=&#123;&quot;id__lte&quot;:12&#125;# # -----------------------------------# PrettyNum.objects.filter(mobile=&#x27;233&#x27;) 等于# PrettyNum.objects.filter(mobile__startswitch=&quot;139&quot;) 筛选出以139开头# PrettyNum.objects.filter(mobile__endswitch=&quot;233&quot;) 筛选出以233结尾# PrettyNum.objects.filter(mobile__contains=&quot;5233&quot;) 筛选出包含5233# use# data_dict=&#123;&quot;mobile__contains&quot;:&quot;233&quot;&#125;# PrettyNum.objects.filter(**data_dict)# ----------------------------------------# test # for i in range(300): # PrettyNum.objects.create(mobile=&quot;13906135899&quot;,price=10,level=1,status=1) data_dict=&#123;&#125; value=request.GET.get(&#x27;q&#x27;,&#x27;&#x27;) if value: data_dict[&quot;mobile__contains&quot;] = value # res=PrettyNum.objects.filter(**data_dict) # print(res) # if request.method==&#x27;GET&#x27;: # ****qurylist=PrettyNum.objects.filter(**data_dict).order_by(&quot;-level&quot;)[start:end] #select * from 表 order by level desc # qurylist=PrettyNum.objects.all().order_by(&quot;-level&quot;)#分页 # qurylist=PrettyNum.objects.all() # qurylist=PrettyNum.objects.filter(id=4)[0:10] # qurylist=PrettyNum.objects.all()[0:10] # qurylist=PrettyNum.objects.all()[10:20] # qurylist=PrettyNum.objects.all()[20:30] page=int(request.GET.get(&#x27;page&#x27;,1)) pageSize=10 start=(page-1)*pageSize end=page*pageSize qurylist=PrettyNum.objects.filter(**data_dict).order_by(&quot;-level&quot;)[start:end] #总数据条数 total_count=PrettyNum.objects.filter(**data_dict).order_by(&quot;-level&quot;).count() #总页码 total_page_count,div=divmod(total_count,pageSize) if div: total_page_count+=1 # 计算出，显示当前页的前5页、后5页 plus=5 if total_page_count&lt;=2*plus+1: #数据库中的数据比较少，都没有达到11页 start_page=1 end_page=total_page_count else: #数据库中的数据比较多 &gt;11页 #当前页&lt;5时(极小值) if page&lt;=plus: start_page=1 end_page=2*plus+1 else: #当前页&gt;5 #当前页+5&gt;总页面 if (page+plus)&gt;total_page_count: start_page=total_page_count-2*plus end_page=total_page_count else: start_page=page-plus end_page=page+plus #页码 page_str_list=[] #首页 page_str_list.append(&#x27;&lt;li&gt;&lt;a href=&quot;?page=&#123;&#125;&quot;&gt;首页&lt;/a&gt;&lt;/li&gt;&#x27;.format(1)) #上一页 if page&gt;1: prev=&#x27;&lt;li&gt;&lt;a href=&quot;?page=&#123;&#125;&quot;&gt;上一页&lt;/a&gt;&lt;/li&gt;&#x27;.format(page-1) else: prev=&#x27;&lt;li&gt;&lt;a href=&quot;?page=&#123;&#125;&quot;&gt;上一页&lt;/a&gt;&lt;/li&gt;&#x27;.format(1) page_str_list.append(prev) for i in range(start_page,end_page+1): if i==page: ele=&#x27;&lt;li class=&quot;active&quot;&gt;&lt;a href=&quot;?page=&#123;&#125;&quot;&gt;&#123;&#125;&lt;/a&gt;&lt;/li&gt;&#x27;.format(i,i) else: ele=&#x27;&lt;li&gt;&lt;a href=&quot;?page=&#123;&#125;&quot;&gt;&#123;&#125;&lt;/a&gt;&lt;/li&gt;&#x27;.format(i,i) page_str_list.append(ele) #下一页 if page&lt;total_page_count: prev=&#x27;&lt;li&gt;&lt;a href=&quot;?page=&#123;&#125;&quot;&gt;下一页&lt;/a&gt;&lt;/li&gt;&#x27;.format(page+1) else: prev=&#x27;&lt;li&gt;&lt;a href=&quot;?page=&#123;&#125;&quot;&gt;下一页&lt;/a&gt;&lt;/li&gt;&#x27;.format(total_page_count) page_str_list.append(prev) #尾页 page_str_list.append(&#x27;&lt;li&gt;&lt;a href=&quot;?page=&#123;&#125;&quot;&gt;尾页&lt;/a&gt;&lt;/li&gt;&#x27;.format(total_page_count)) search_string=&quot;&quot;&quot;&quot; &lt;form class=&quot;navbar-form navbar-left&quot; method=&quot;GET&quot;&gt; &lt;div class=&quot;form-group&quot;&gt; &lt;input type=&quot;text&quot; class=&quot;form-control&quot; placeholder=&quot;Search&quot; name=&quot;page&quot;&gt; &lt;/div&gt; &lt;button type=&quot;submit&quot; class=&quot;btn btn-default&quot;&gt;Submit&lt;/button&gt; &lt;/form&gt; &quot;&quot;&quot; page_str_list.append(search_string) page_string =mark_safe(&quot;&quot;.join(page_str_list)) return render(request,&#x27;pretty_list.html&#x27;,&#123;&#x27;qurylist&#x27;:qurylist,&quot;search_data&quot;:value,&quot;page_string&quot;:page_string&#125;) 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677&#123;% extends &#x27;layout.html&#x27; %&#125;&#123;% block content %&#125;&lt;div style=&quot;float: right;&quot;&gt; &lt;form class=&quot;navbar-form navbar-left&quot; method=&quot;GET&quot;&gt; &lt;div class=&quot;form-group&quot;&gt; &lt;input type=&quot;text&quot; class=&quot;form-control&quot; placeholder=&quot;Search&quot; name=&quot;q&quot; value=&quot;&#123;&#123;search_data&#125;&#125;&quot;&gt; &lt;/div&gt; &lt;button type=&quot;submit&quot; class=&quot;btn btn-default&quot;&gt;Search&lt;/button&gt;&lt;/form&gt;&lt;/div&gt;&lt;div&gt; &lt;a href=&quot;/pretty/add/&quot; &gt;&lt;button type=&quot;button&quot; class=&quot;btn btn-success dropdown-toggle&quot; data-toggle=&quot;dropdown&quot; aria-haspopup=&quot;true&quot; aria-expanded=&quot;false&quot;&gt;新建&lt;/button&gt;&lt;/a&gt; &lt;!-- &lt;a href=&quot;/usr/addform&quot;&gt;&lt;button type=&quot;button&quot; class=&quot;btn btn-success dropdown-toggle&quot; data-toggle=&quot;dropdown&quot; aria-haspopup=&quot;true&quot; aria-expanded=&quot;false&quot;&gt;用form新建&lt;/button&gt;&lt;/a&gt; --&gt;&lt;/div&gt;&lt;div class=&quot;panel panel-default &quot;&gt; &lt;/div&gt;&lt;div class=&quot;bs-example&quot; data-example-id=&quot;table-within-panel&quot;&gt; &lt;div class=&quot;panel panel-default&quot;&gt; &lt;!-- Default panel contents --&gt; &lt;div class=&quot;panel-heading&quot;&gt;靓号列表&lt;/div&gt; &lt;!-- &lt;div class=&quot;panel-body&quot;&gt; &lt;/div&gt; --&gt; &lt;!-- Table --&gt; &lt;table class=&quot;table&quot;&gt; &lt;thead&gt; &lt;tr&gt; &lt;th&gt;id&lt;/th&gt; &lt;th&gt;手机号&lt;/th&gt; &lt;th&gt;价格&lt;/th&gt; &lt;th&gt;级别&lt;/th&gt; &lt;th&gt;状态&lt;/th&gt; &lt;/tr&gt; &lt;/thead&gt; &lt;tbody&gt; &#123;% for mp in qurylist %&#125; &lt;tr&gt; &lt;th scope=&quot;row&quot;&gt;&#123;&#123;mp.id&#125;&#125;&lt;/th&gt; &lt;td&gt;&#123;&#123;mp.mobile&#125;&#125;&lt;/td&gt; &lt;td&gt;&#123;&#123;mp.price&#125;&#125;&lt;/td&gt; &lt;!-- &lt;td&gt;&#123;&#123;mp.create_time&#125;&#125;&lt;/td&gt; --&gt; &lt;!-- &lt;td&gt;&#123;&#123;mp.create_time|date:&quot;Y-m-d H:i:s&quot;&#125;&#125;&lt;/td&gt; --&gt; &lt;td&gt;&#123;&#123;mp.get_level_display&#125;&#125;&lt;/td&gt; &lt;td&gt;&#123;&#123;mp.get_status_display&#125;&#125;&lt;/td&gt; &lt;td&gt; &lt;a href=&quot;/pretty/&#123;&#123;mp.id&#125;&#125;/edit/&quot;&gt;&lt;button type=&quot;button&quot; class=&quot;btn btn-warning dropdown-toggle&quot; data-toggle=&quot;dropdown&quot; aria-haspopup=&quot;true&quot; aria-expanded=&quot;false&quot;&gt;编辑&lt;/button&gt;&lt;/a&gt; &lt;!-- &lt;a href=&quot;/dep/delete/?memid=&#123;&#123;mp.id&#125;&#125;&quot;&gt;&lt;button type=&quot;button&quot; class=&quot;btn btn-danger dropdown-toggle&quot; data-toggle=&quot;dropdown&quot; aria-haspopup=&quot;true&quot; aria-expanded=&quot;false&quot; &gt;删除&lt;/button&gt;&lt;/a&gt; --&gt; &lt;!-- &lt;a href=&quot;/dep/delete/?memid=&#123;&#123;mp.id&#125;&#125;&quot;&gt;&lt;button type=&quot;button&quot; class=&quot;btn btn-danger dropdown-toggle&quot; data-toggle=&quot;dropdown&quot; aria-haspopup=&quot;true&quot; aria-expanded=&quot;false&quot; &gt;删除&lt;/button&gt;&lt;/a&gt; --&gt; &lt;a href=&quot;/pretty/&#123;&#123;mp.id&#125;&#125;/delete/&quot;&gt;&lt;button type=&quot;button&quot; class=&quot;btn btn-danger dropdown-toggle&quot; data-toggle=&quot;dropdown&quot; aria-haspopup=&quot;true&quot; aria-expanded=&quot;false&quot; &gt;删除&lt;/button&gt;&lt;/a&gt; &lt;/td&gt; &lt;/tr&gt; &#123;% endfor %&#125; &lt;/tbody&gt; &lt;/table&gt; &lt;/div&gt; &lt;nav aria-label=&quot;Page navigation&quot;&gt; &lt;ul class=&quot;pagination&quot;&gt; &#123;&#123;page_string&#125;&#125; &lt;/ul&gt; &lt;/nav&gt; &lt;!-- &lt;form class=&quot;navbar-form navbar-left&quot; method=&quot;GET&quot;&gt; &lt;div class=&quot;form-group&quot;&gt; &lt;input type=&quot;text&quot; class=&quot;form-control&quot; placeholder=&quot;Search&quot; name=&quot;page&quot;&gt; &lt;/div&gt; &lt;button type=&quot;submit&quot; class=&quot;btn btn-default&quot;&gt;Submit&lt;/button&gt; &lt;/form&gt; --&gt;&#123;% endblock %&#125; BootStrap样式父类123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339from django.shortcuts import render,HttpResponse,redirectfrom .models import Department,Employee,PrettyNumfrom django import formsfrom django.core.exceptions import ValidationErrorfrom django.core.validators import RegexValidatorfrom django.utils.safestring import mark_safefrom app01.utils.pagination import Paginationimport copy# Create your views here.def department_list(request): member_list=Department.objects.all() return render(request,&#x27;dep.html&#x27;,&#123;&#x27;member&#x27;:member_list&#125;)def add_dep(request): if request.method==&#x27;GET&#x27;: return render(request,&#x27;adddep.html&#x27;) elif request.method==&#x27;POST&#x27;: title=request.POST.get(&#x27;aatitle&#x27;) Department.objects.create(tittle=title) return redirect(&quot;/dep/list/&quot;)def delete_dep(request): memid=request.GET.get(&#x27;memid&#x27;) Department.objects.filter(id=memid).delete() return redirect(&quot;/dep/list/&quot;)def edit_dep(request,memid): if request.method==&#x27;GET&#x27;: nnmame=Department.objects.filter(id=memid).first() return render(request,&#x27;editdpt.html&#x27;,&#123;&#x27;nnmame&#x27;:nnmame.tittle&#125;) aatitle=request.POST.get(&#x27;aatitle&#x27;) Department.objects.filter(id=memid).update(tittle=aatitle) return redirect(&quot;/dep/list/&quot;)def test(request): return render(request,&#x27;tt.html&#x27;)def usr_list(request): # for i in range(300): # Employee.objects.create(name=&quot;maomao&quot;,password=123,age=50,create_time=&#x27;2023-10-5&#x27;,depart_id=5) qurylist=Employee.objects.all() page_object=Pagination(request,qurylist) context=&#123; &quot;qurylist&quot;:page_object.page_qurylist, &quot;page_string&quot;:page_object.html(), &#125; return render(request,&#x27;usr.html&#x27;,context)# class MyForm(forms.Form): # usr=forms.CharField(widget=forms.EmailInput) # pwd=forms.CharField(widget=forms.PasswordInput) # age=forms.ImageField(widget=forms.NumberInput)# class MyForm(forms.Form):# class Meta:# model=Employee# fields=[&#x27;name&#x27;,&#x27;password&#x27;,&#x27;age&#x27;]def add_usr(request): context=&#123; &#x27;gender_choice&#x27;:Employee.gender_choices, &#x27;depart_list&#x27;:Department.objects.all() &#125; # form=MyForm() return render(request,&#x27;add_usr.html&#x27;,context) # return render(request,&#x27;add_usr_fro.html&#x27;,&#123;&#x27;form&#x27;:form&#125;)class MyForm(forms.ModelForm): # name=forms.CharField(min_length=3,label=&quot;用户名&quot;) # usr=forms.CharField(widget=forms.EmailInput) # pwd=forms.CharField(widget=forms.PasswordInput) # age=forms.ImageField(widget=forms.NumberInput) class Meta: model=Employee fields=[&#x27;name&#x27;,&#x27;password&#x27;,&#x27;age&#x27;,&#x27;account&#x27;,&#x27;create_time&#x27;,&#x27;depart&#x27;,&#x27;gender&#x27;] widgets=&#123; &quot;name&quot;:forms.TextInput(attrs=&#123;&quot;class&quot;:&quot;form-control&quot;&#125;), &quot;age&quot;:forms.TextInput(attrs=&#123;&quot;class&quot;:&quot;form-control&quot;&#125;), &quot;create-time&quot;:forms.TextInput(attrs=&#123;&quot;type&quot;:&quot;data&quot;&#125;) &#125; # def __init__(self,*args, **kwargs): # super().__init__(*args,**kwargs) # # for name,field in self.fields.items(): # field.Widget.attrs=&#123;&quot;class&quot;:&quot;form-control&quot;,&quot;placeholder&quot;:field.label&#125;def add_usr_form(request): if request.method == &quot;GET&quot;: form=MyForm() return render(request,&#x27;add_usr_fro.html&#x27;,&#123;&#x27;form&#x27;:form&#125;) # post 校验 form=MyForm(data=request.POST) if form.is_valid(): form.save() return redirect(&#x27;/usr/list/&#x27;) else: return render(request,&#x27;add_usr_fro.html&#x27;,&#123;&quot;form&quot;:form&#125;)def usr_edit(request,nid): #获取默认值 row_object=Employee.objects.filter(id=nid).first() if request.method ==&#x27;GET&#x27;: form =MyForm(instance=row_object) return render(request,&#x27;usr_edit.html&#x27;,&#123;&#x27;form&#x27;:form&#125;) #post form=MyForm(data=request.POST,instance=row_object) if form.is_valid(): form.save() return redirect(&#x27;/usr/list/&#x27;) return render(request,&#x27;usr_edit.html&#x27;,&#123;&#x27;form&#x27;:form&#125;)def usr_delete(request,nid): Employee.objects.filter(id=nid).delete() return redirect(&#x27;/usr/list/&#x27;)class PrettyForm(forms.ModelForm): # 验证方法一 # mobile=forms.CharField( # label=&quot;手机号&quot;, # validators=[RegexValidator(r&#x27;^1[3-9]\\d&#123;9&#125;$&#x27;,&#x27;手机号格式错误&#x27;)] # ) class Meta: model=PrettyNum fields=[&#x27;mobile&#x27;,&#x27;price&#x27;,&#x27;level&#x27;,&#x27;status&#x27;] # fields=&quot;__all__&quot; # exclude=[&#x27;level&#x27;] widgets=&#123; &quot;mobile&quot;:forms.TextInput(attrs=&#123;&quot;class&quot;:&quot;form-control&quot;&#125;), &quot;price&quot;:forms.TextInput(attrs=&#123;&quot;class&quot;:&quot;form-control&quot;&#125;), &quot;level&quot;:forms.TextInput(attrs=&#123;&quot;class&quot;:&quot;form-control&quot;&#125;), &quot;status&quot;:forms.TextInput(attrs=&#123;&quot;class&quot;:&quot;form-control&quot;&#125;), &#125;# 验证方法二 def clean_mobile(self): txt_mobile=self.cleaned_data[&quot;mobile&quot;] exists=PrettyNum.objects.filter(mobile=txt_mobile).exists() if len(txt_mobile)!=11: #验证不通过 raise ValidationError(&quot;格式错误&quot;) if exists: #验证不通过 raise ValidationError(&quot;手机号已存在&quot;) return txt_mobiledef pretty_list(request):##搜索# --------------------# 1.PrettyNum.objects.filter&#123;mobile=&#x27;13906135233&#x27;,&quot;id&quot;:123&#125;# 2.data_dict=&#123;&quot;mobile&quot;:&quot;13906135233&quot;,&quot;id&quot;:123&#125;# PrettyNum.objects.filter(**data_dict)# --------------------------------# PrettyNum.objects.filter(id=12) 等于12# PrettyNum.objects.filter(id__gt=12) 大于12# PrettyNum.objects.filter(id__gte=12) 大于等于12# PrettyNum.objects.filter(id__lt=12) 小于12# PrettyNum.objects.filter(id__lte=12) 小于等于12# data_dict=&#123;&quot;id__lte&quot;:12&#125;# # -----------------------------------# PrettyNum.objects.filter(mobile=&#x27;233&#x27;) 等于# PrettyNum.objects.filter(mobile__startswitch=&quot;139&quot;) 筛选出以139开头# PrettyNum.objects.filter(mobile__endswitch=&quot;233&quot;) 筛选出以233结尾# PrettyNum.objects.filter(mobile__contains=&quot;5233&quot;) 筛选出包含5233# use# data_dict=&#123;&quot;mobile__contains&quot;:&quot;233&quot;&#125;# PrettyNum.objects.filter(**data_dict)# ----------------------------------------# test # for i in range(300): # PrettyNum.objects.create(mobile=&quot;13906135899&quot;,price=10,level=1,status=1) # print(request.GET) # request.GET.setlist(&#x27;xx&#x27;,11) # print(request.GET.urlencode()) #q=123&amp;page=2 # get_object=copy.deepcopy(request.GET) # get_object._mutable=True # get_object.setlist(&#x27;page&#x27;,[11]) # print(get_object.urlencode()) qury_dict=copy.deepcopy(request.GET) qury_dict._mutable=True qury_dict.setlist(&#x27;page&#x27;,[11]) print(qury_dict.urlencode()) data_dict=&#123;&#125; value=request.GET.get(&#x27;q&#x27;,&#x27;&#x27;) if value: data_dict[&quot;mobile__contains&quot;] = value qurylist=PrettyNum.objects.filter(**data_dict).order_by(&quot;-level&quot;) page_object= Pagination(request,qurylist) page_qurylist=page_object.page_qurylist page_string=page_object.html() context=&#123;&#x27;qurylist&#x27;:page_qurylist, &quot;search_data&quot;:value, &quot;page_string&quot;:page_string&#125; # res=PrettyNum.objects.filter(**data_dict) # print(res) # if request.method==&#x27;GET&#x27;: # ****qurylist=PrettyNum.objects.filter(**data_dict).order_by(&quot;-level&quot;)[start:end] #select * from 表 order by level desc # qurylist=PrettyNum.objects.all().order_by(&quot;-level&quot;)#分页 # qurylist=PrettyNum.objects.all() # qurylist=PrettyNum.objects.filter(id=4)[0:10] # qurylist=PrettyNum.objects.all()[0:10] # qurylist=PrettyNum.objects.all()[10:20] # qurylist=PrettyNum.objects.all()[20:30] # page=int(request.GET.get(&#x27;page&#x27;,1)) # pageSize=10 # start=(page-1)*pageSize # end=page*pageSize # qurylist=PrettyNum.objects.filter(**data_dict).order_by(&quot;-level&quot;)[page_object.start:page_object.end] #总数据条数# total_count=PrettyNum.objects.filter(**data_dict).order_by(&quot;-level&quot;).count()# #总页码# total_page_count,div=divmod(total_count,pageSize)# if div:# total_page_count+=1 # 计算出，显示当前页的前5页、后5页# plus=5# if total_page_count&lt;=2*plus+1:# #数据库中的数据比较少，都没有达到11页# start_page=1# end_page=total_page_count# else:# #数据库中的数据比较多 &gt;11页# #当前页&lt;5时(极小值)# if page&lt;=plus:# start_page=1# end_page=2*plus+1# else:# #当前页&gt;5# #当前页+5&gt;总页面# if (page+plus)&gt;total_page_count:# start_page=total_page_count-2*plus# end_page=total_page_count# else:# start_page=page-plus# end_page=page+plus# #页码# page_str_list=[]# #首页# page_str_list.append(&#x27;&lt;li&gt;&lt;a href=&quot;?page=&#123;&#125;&quot;&gt;首页&lt;/a&gt;&lt;/li&gt;&#x27;.format(1))# #上一页# if page&gt;1:# prev=&#x27;&lt;li&gt;&lt;a href=&quot;?page=&#123;&#125;&quot;&gt;上一页&lt;/a&gt;&lt;/li&gt;&#x27;.format(page-1)# else:# prev=&#x27;&lt;li&gt;&lt;a href=&quot;?page=&#123;&#125;&quot;&gt;上一页&lt;/a&gt;&lt;/li&gt;&#x27;.format(1)# page_str_list.append(prev) # for i in range(start_page,end_page+1):# if i==page:# ele=&#x27;&lt;li class=&quot;active&quot;&gt;&lt;a href=&quot;?page=&#123;&#125;&quot;&gt;&#123;&#125;&lt;/a&gt;&lt;/li&gt;&#x27;.format(i,i)# else:# ele=&#x27;&lt;li&gt;&lt;a href=&quot;?page=&#123;&#125;&quot;&gt;&#123;&#125;&lt;/a&gt;&lt;/li&gt;&#x27;.format(i,i)# page_str_list.append(ele)# #下一页# if page&lt;total_page_count:# prev=&#x27;&lt;li&gt;&lt;a href=&quot;?page=&#123;&#125;&quot;&gt;下一页&lt;/a&gt;&lt;/li&gt;&#x27;.format(page+1)# else:# prev=&#x27;&lt;li&gt;&lt;a href=&quot;?page=&#123;&#125;&quot;&gt;下一页&lt;/a&gt;&lt;/li&gt;&#x27;.format(total_page_count)# page_str_list.append(prev)# #尾页# page_str_list.append(&#x27;&lt;li&gt;&lt;a href=&quot;?page=&#123;&#125;&quot;&gt;尾页&lt;/a&gt;&lt;/li&gt;&#x27;.format(total_page_count))# search_string=&quot;&quot;&quot;&quot;# &lt;form class=&quot;navbar-form navbar-left&quot; method=&quot;GET&quot;&gt;# &lt;div class=&quot;form-group&quot;&gt;# &lt;input type=&quot;text&quot; class=&quot;form-control&quot; placeholder=&quot;Search&quot; name=&quot;page&quot;&gt;# &lt;/div&gt;# &lt;button type=&quot;submit&quot; class=&quot;btn btn-default&quot;&gt;Submit&lt;/button&gt;# &lt;/form&gt;# &quot;&quot;&quot;# page_str_list.append(search_string)# page_string =mark_safe(&quot;&quot;.join(page_str_list)) return render(request,&#x27;pretty_list.html&#x27;,context)def pretty_add(request): if request.method==&#x27;GET&#x27;: form=PrettyForm() return render(request,&#x27;pretty_add.html&#x27;,&#123;&#x27;form&#x27;:form&#125;) #post校验 form=PrettyForm(data=request.POST) if form.is_valid(): form.save() return redirect(&#x27;/pretty/list/&#x27;) else: return render(request,&#x27;pretty_add.html&#x27;,&#123;&quot;form&quot;:form&#125;)class PrettyEditModelForm(forms.ModelForm): # 验证方法一 mobile=forms.CharField( label=&quot;手机号&quot;, # disabled=True, validators=[RegexValidator(r&#x27;^1[3-9]\\d&#123;9&#125;$&#x27;,&#x27;手机号格式错误&#x27;)], ) ## mobile=forms.CharField(disabled=True,label=&quot;手机号&quot;) class Meta: model=PrettyNum fields=[&#x27;mobile&#x27;,&#x27;price&#x27;,&#x27;level&#x27;,&#x27;status&#x27;] def clean_mobile(self): # print(self.instance.pk) txt_mobile=self.cleaned_data[&quot;mobile&quot;] exists=PrettyNum.objects.exclude(id=self.instance.pk).filter(mobile=txt_mobile).exists() # if len(txt_mobile)!=11: # # 验证不通过 # raise ValidationError(&quot;格式错误&quot;) if exists: #验证不通过 raise ValidationError(&quot;手机号已存在&quot;) return txt_mobile def pertty_edit(request,nid): row_object=PrettyNum.objects.filter(id=nid).first() if request.method==&#x27;GET&#x27;: form=PrettyEditModelForm(instance=row_object) return render(request,&#x27;pretty_edit.html&#x27;,&#123;&#x27;form&#x27;:form&#125;) #post form=PrettyEditModelForm(data=request.POST,instance=row_object) if form.is_valid(): form.save() return redirect(&#x27;/pretty/list/&#x27;) else: return render(request,&#x27;pretty_edit.html&#x27;,&#123;&#x27;form&#x27;:form&#125;)def pertty_delete(request,nid): PrettyNum.objects.filter(id=nid).delete() return redirect(&#x27;/pretty/list/&#x27;)","categories":[{"name":"2023","slug":"2023","permalink":"http://example.com/categories/2023/"}],"tags":[{"name":"django","slug":"django","permalink":"http://example.com/tags/django/"}]},{"title":"Spark入门：RDD编程（2）","slug":"Spark入门：RDD编程（2）","date":"2023-03-20T16:28:42.147Z","updated":"2023-03-20T16:28:43.815Z","comments":true,"path":"2023/03/21/Spark入门：RDD编程（2）/","link":"","permalink":"http://example.com/2023/03/21/Spark%E5%85%A5%E9%97%A8%EF%BC%9ARDD%E7%BC%96%E7%A8%8B%EF%BC%882%EF%BC%89/","excerpt":"","text":"Spark入门：RDD编程(2)4.2键值对RDD键值对RDD的创建","categories":[{"name":"2023","slug":"2023","permalink":"http://example.com/categories/2023/"}],"tags":[{"name":"Spark","slug":"Spark","permalink":"http://example.com/tags/Spark/"}]},{"title":"Spark入门：RDD编程（1）","slug":"spark","date":"2023-03-20T14:19:48.651Z","updated":"2023-03-20T16:28:47.347Z","comments":true,"path":"2023/03/20/spark/","link":"","permalink":"http://example.com/2023/03/20/spark/","excerpt":"Spark入门：RDD编程(1)","text":"Spark入门：RDD编程(1) 4.1RDD编程基础RDD创建RDD可以通过两种方式创建： 第一种：读取一个外部数据集。比如，从本地文件加载数据集，或者从HDFS文件系统、HBase、Cassandra、Amazon S3等外部数据源中加载数据集。Spark可以支持文本文件、SequenceFile文件（Hadoop提供的 SequenceFile是一个由二进制序列化过的key&#x2F;value的字节流组成的文本存储文件）和其他符合Hadoop InputFormat格式的文件。 第二种：调用SparkContext的parallelize方法，在Driver中一个已经存在的集合（数组）上创建 在即将进行相关的实践操作之前，我们首先要登录Linux系统（本教程统一采用hadoop用户登录），然后，打开命令行“终端”，请按照下面的命令启动Hadoop中的HDFS组件： 创建RDD之前的准备工作在即将进行相关的实践操作之前，我们首先要登录Linux系统（本教程统一采用hadoop用户登录），然后，打开命令行“终端”，请按照下面的命令启动Hadoop中的HDFS组件： 12cd /usr/local/hadoop./sbin/start-dfs.sh 然后，我们按照下面命令启动spark-shell： 12cd /usr/local/spark./bin/pyspark 然后，新建第二个“终端”，方法是，在前面已经建设的第一个终端窗口的左上方，点击“终端”菜单，在弹出的子菜单中选择“新建终端”，就可以打开第二个终端窗口，现在，我们切换到第二个终端窗口，在第二个终端窗口中，执行以下命令，进入之前已经创建好的“&#x2F;usr&#x2F;local&#x2F;spark&#x2F;mycode&#x2F;”目录，在这个目录下新建rdd子目录，用来存放本章的代码和相关文件： 12cd usr/local/spark/mycode/mkdir rdd 然后，使用vim编辑器，在rdd目录下新建一个word.txt文件，你可以在文件里面随便输入几行英文语句用来测试。 经过上面的准备工作以后，我们就可以开始创建RDD了。 从文件系统中加载数据创建RDDSpark采用textFile()方法来从文件系统中加载数据创建RDD，该方法把文件的URI作为参数，这个URI可以是本地文件系统的地址，或者是分布式文件系统HDFS的地址，或者是Amazon S3的地址等等。下面请切换回spark-shell窗口，看一下如何从本地文件系统中加载数据： 12&gt;&gt;&gt;lines = sc.textFile(&quot;file:///usr/local/spark/mycode/rdd/word.txt&quot;) 1&gt;&gt;&gt;lines.foreach(print) 加载HDFS中的文件为了能够读取HDFS中的文件，请首先启动Hadoop中的HDFS组件。注意，之前我们在“Spark安装”这章内容已经介绍了如何安装Hadoop和Spark，所以，这里我们可以使用以下命令直接启动Hadoop中的HDFS组件（由于用不到MapReduce组件，所以，不需要启动MapReduce或者YARN）。请到第二个终端窗口，使用Linux Shell命令提示符状态，然后输入下面命令： 12cd /usr/local/hadoop./sbin/start-dfs.sh 启动结束后，HDFS开始进入可用状态。如果你在HDFS文件系统中，还没有为当前Linux登录用户创建目录(本教程统一使用用户名hadoop登录Linux系统)，请使用下面命令创建： 1./bin/hdfs dfs -mkdir -p /user/hadoop 也就是说，HDFS文件系统为Linux登录用户开辟的默认目录是“&#x2F;user&#x2F;用户名”（注意：是user，不是usr），本教程统一使用用户名hadoop登录Linux系统，所以，上面创建了“&#x2F;user&#x2F;hadoop”目录，再次强调，这个目录是在HDFS文件系统中，不在本地文件系统中。创建好以后，下面我们使用命令查看一下HDFS文件系统中的目录和文件： 1./bin/hdfs dfs -ls . ** 但这个命令我搞不出来，显示的是这个 – 上面命令中，最后一个点号“.”，表示要查看Linux当前登录用户hadoop在HDFS文件系统中与hadoop对应的目录下的文件，也就是查看HDFS文件系统中“&#x2F;user&#x2F;hadoop&#x2F;”目录下的文件，所以，下面两条命令是等价的： – 12./bin/hdfs dfs -ls ../bin/hdfs dfs -ls /user/hadoop 你自己可以试一试，只有第二个可以用 如果要查看HDFS文件系统根目录下的内容，需要使用下面命令： 1./bin/hdfs dfs -ls / 然后输出的东西见上面那个图，有一个items 下面，我们把本地文件系统中的“&#x2F;usr&#x2F;local&#x2F;spark&#x2F;mycode&#x2F;rdd&#x2F;word.txt”上传到分布式文件系统HDFS中（放到hadoop用户目录下）： 1./bin/hdfs dfs -put /usr/local/spark/mycode/rdd/word.txt /user/hadoop 然后，用命令查看一下HDFS的hadoop用户目录下是否多了word.txt文件，可以使用下面命令列出hadoop目录下的内容： 1./bin/hdfs dfs -ls / 可以看到，确实多了一个word.txt文件，我们使用cat命令查看一个HDFS中的word.txt文件的内容，命令如下： 1./bin/hdfs dfs -cat ./word.txt 上面命令执行后，就会看到HDFS中word.txt的内容了。 现在，让我们切换回到spark-shell窗口，编写语句从HDFS中加载word.txt文件，并显示第一行文本内容： 12&gt;&gt;&gt;lines= sc.textFile(&quot;hdfs://localhost:9000/user/hadoop/word.txt&quot;)&gt;&gt;&gt;lines=sc.foreach(print) 注意，上面三条命令是完全等价的命令，只不过使用了不同的目录形式，你可以使用其中任意一条命令完成数据加载操作。 在使用Spark读取文件时，需要说明以下几点：（1）如果使用了本地文件系统的路径，那么，必须要保证在所有的worker节点上，也都能够采用相同的路径访问到该文件，比如，可以把该文件拷贝到每个worker节点上，或者也可以使用网络挂载共享文件系统。（2）textFile()方法的输入参数，可以是文件名，也可以是目录，也可以是压缩文件等。比如，textFile(“&#x2F;my&#x2F;directory”), textFile(“&#x2F;my&#x2F;directory&#x2F;.txt”), and textFile(“&#x2F;my&#x2F;directory&#x2F;.gz”).（3）textFile()方法也可以接受第2个输入参数（可选），用来指定分区的数目。默认情况下，Spark会为HDFS的每个block创建一个分区（HDFS中每个block默认是128MB）。你也可以提供一个比block数量更大的值作为分区数目，但是，你不能提供一个小于block数量的值作为分区数目。 通过并行集合（数组）创建RDD可以调用SparkContext的parallelize方法，在Driver中一个已经存在的集合（数组）上创建。下面请在spark-shell中操作： 123&gt;&gt;&gt;array = [1,2,3,4,5]&gt;&gt;&gt;rdd = sc.parallelize(array)&gt;&gt;&gt;rdd.foreach(print) RDD操作RDD被创建好以后，在后续使用过程中一般会发生两种操作：*  转换（Transformation）： 基于现有的数据集创建一个新的数据集。*  行动（Action）：在数据集上进行运算，返回计算值。 Ⅰ转换操作对于RDD而言，每一次转换操作都会产生不同的RDD，供给下一个“转换”使用。转换得到的RDD是惰性求值的，也就是说，整个转换过程只是记录了转换的轨迹，并不会发生真正的计算，只有遇到行动操作时，才会发生真正的计算，开始从血缘关系源头开始，进行物理的转换操作。下面列出一些常见的转换操作（Transformation API）：* filter(func)：筛选出满足函数func的元素，并返回一个新的数据集* map(func)：将每个元素传递到函数func中，并将结果返回为一个新的数据集* flatMap(func)：与map()相似，但每个输入元素都可以映射到0或多个输出结果* groupByKey()：应用于(K,V)键值对的数据集时，返回一个新的(K, Iterable)形式的数据集* reduceByKey(func)：应用于(K,V)键值对的数据集时，返回一个新的(K, V)形式的数据集，其中的每个值是将每个key传递到函数func中进行聚合 1.filter(func) 好吧，这个书上说要把word.txt写成 12345Hadoop is goodSpark is fastSpark is better 那我们就 1cd /usr/local/spark/mycode/rdd 1gedit word.txt 然后再 123&gt;&gt;&gt;lines=sc.textFile(&quot;file:///usr/local/spark/mycode/rdd/word.txt&quot;)&gt;&gt;&gt;linesWithSpark = lines.filter(lambda line: &quot;Spark&quot; in line)&gt;&gt;&gt;linesWithSpark.foreach(print) 上面的代码中，lines就是一个RDD。lines.filter()会遍历lines中的每行文本，并对每行文本执行括号中的匿名函数，也就是执行Lamda表达式：line &#x3D;&gt; line.contains(“Spark”)，在执行Lamda表达式时，会把当前遍历到的这行文本内容赋值给参数line，然后，执行处理逻辑line.contains(“Spark”)，也就是只有当改行文本包含“Spark”才满足条件，才会被放入到结果集中。最后，等到lines集合遍历结束后，就会得到一个结果集，这个结果集中包含了所有包含“Spark”的行。最后，对这个结果集调用count()，这是一个行动操作，会计算出结果集中的元素个数。 2.map(func) map(func)：将每个元素传递到函数func中，并将结果返回为一个新的数据集 1234&gt;&gt;&gt; data =[1,2,3,4,5]&gt;&gt;&gt; rdd1 = sc.parallelize(data)&gt;&gt;&gt; rdd2 = rdd1.map(lambda x:x+10)&gt;&gt;&gt; rdd2.foreach(print) 上述语句执行过程如图 所示。第 1行语句创建了一个包含 5 个整型元素的列表 data。第2行语句执行 sc.parallelize(data)，从列表 data 中生成一个 RDD，即 rdd1,rdd1 中包含了5 个整型的元素即1、2、3、4、5。第 3 行语句执行 rdd1.map0操作,map0的输入参数“lambda x:x+10”是一个Lambda表达式。rdd1.map(lambda x:x+10)的含义是，依次取出 rdd1 这个RDD 中的每个元素，对于当前取到的元素，把它赋值给 Lambda 表达式中的变量x，然后，执行 Lambda 表达式的函数体部分“x+10”也就是把变量x的值和 10 相加后，作为函数的返回值，并作为一个元素放入到新的 RDD(即rdd2中。最终，新牛成的RDD (即 rdd2) 中包含了 5 个整型元素，即 11、12、13、14、15。 另外一个实例： 123&gt;&gt;&gt;lines=sc.textFile(&quot;file:///usr/local/spark/mycode/rdd/word.txt&quot;)&gt;&gt;&gt; words = lines.map(lambda line:line.split(&quot; &quot;))&gt;&gt;&gt; words.foreach(print) 上述语句执行过程如图所示。在第 1 行语句中，执行 sc.textFile0方法把 word.txt 文件中的数据加载到内存生成一个 RDD，即 lines，这个RDD 中的每个元素都是字符串类型，即每个 RDD 元素都是一行文本，比如，lines 中的第 1 个元素是”Hadoop is good”，第2 个元素是”Spark is fast”，第3个元素是”Spark is better”。在第 2 行语句中，执行 lies.map0操作，map0的输入参数 lambdaline:line.split(“)是一个 Lambda 表达式。linesmap(lambda line:line.split(“”)的含义是，依次取出 lines这个 RDD 中的每个元素，对于当前取到的元素，把它赋值给 Lambda 表达式中的变量 line，然后，执行 Lambda 表达式的函数体部分 line.split(“”)。因为 line 是一行文本，如”Hadoop is good”，一行文本中包含了很多个单词，单词之间以空格进行分隔，所以，line.split(“”的功能是，以空格作为分隔符把 line 拆分成一个个单词,拆分后得到的单词都封装在一个列表对象中,成为新的 RDD( 即 words)的一个元素，比如，”Hadoop is good”被拆分后，得到”Hadoop”、”is”和”good”3 个单词，会被封装到一个列表对象中，即[“Hadoop”.”is”,”good”]，成为 words 这个 RDD 中的一个元素。 3.flatMap(func)flatMap(func)与 map0相似，但每个输入元素都可以映射到 0 或多个输出结果。例如: 123&gt;&gt;&gt;lines=sc.textFile(&quot;file:///usr/local/spark/mycode/rdd/word.txt&quot;)&gt;&gt;&gt;words =lines.flatMap(lambda line:line.split(&quot; &quot;))&gt;&gt;&gt; words.foreach(print) 上述语句执行过程如图所示。在第 1行语句中，执行 sc.textFile0方法把 wordtxt 文件中的数据加载到内存生成一个RDD，即 lines，这个 RDD 中的每个元素都是字符串类型，即每个RDD 元素都是一行文本。在第2行语句中，执行 linesflatMap0操作，flatMap0的输入参数 line:linesplit(“”)是个Lambda 表达式。lines.flatMap(lambda line:line.split(“”))的结果，等价于如下两步操作的结果。 第1步: map0。执行 lines.map(lambda line: linesplit(“”))操作，从 lines 转换得到一个新的 RDD(即wordArray),wordArray 中的每个元素都是一个列表,比如,第1个元素是[“Hadoop”,”is”，”good”]7.第2个元素是”Spark”，”is”,”fast”]，第3 个元素是[“Spark”,”is””better”]。 第 2步:拍扁 ( flat)。flatMap0操作中的“flat”是一个很形象的动作-“拍扁”，也就是把vordArray 中的每个 RDD 元素都“拍扁”成多个元素。所有这些被拍扁以后得到的元素，构成一个新的 RDD，即 words。比如，wordArray 中的第1个元素是[“Hadoop”,”is”,”good]，被拍扁以后得到3个新的字符串类型的元素,即”Hadoop”、”is”和”good”; wordArray 中的第 2 个元素是[“Spark”,”is”fast”],被拍扁以后得到 3 个新的元素,即”Spark”、”is”和”fast”; wordArray 中的第 3 个元素是[“Spark””is””beter”，被拍扁以后得到 3 个新的元素，即”Spark”、”is”和”beter”。最终，这些被拍扁以后得到的 9 个字符串类型的元素构成一个新的 RDD (即 words )。也就是说，words 里面包含了 9 个字串类型的元素，分别是”Hadoop”、”is”、”good”、”Spark”、”is”、”fast”、”Spark”、”is”和”‘better’。 4.gropByKeygroupByKey()应用于(K,V)键值对的数据集时，返回一个新的(K,Iterable)形式的数据集。 123words=sc.parallelize([(&quot;Hadoop&quot;,1),(&quot;is&quot;,1),(&quot;good&quot;,1),(&quot;Spark&quot;,1),(&quot;is&quot;,1),(&quot;better&quot;,1)])words1=words.groupByKey()words1.foreach(print) 如图所示，在这个实例中，名称为 words 的 RDD 中包含了 9 个元素，每个元素都是(KV)键值对类型。wordsl&#x3D;words.groupByKey0操作执行以后，所有 key 相同的键值对，它们的 value都被归并到一起。比如，(“is”,1)、(“is”,1)、(is”,1)这3 个键值对的 key 相同，就会被归并成一个新的键值对(“is”,(1,1,1))，其中，key 是”is”，value 是(1,1,1)，而且，value 会被封装成 Iterable 对象 (一种可选代集合 )。 5.reduceByKey(func)reduceByKey(func)应用于(KV)键值对的数据集时，返回一个新的(K,V)形式的数据集，其中的每个值是将每个key传递到函数func中进行聚合后得到的结果 123words=sc.parallelize([(&quot;Hadoop&quot;,1),(&quot;is&quot;,1),(&quot;good&quot;,1),(&quot;Spark&quot;,1),(&quot;is&quot;,1),(&quot;better&quot;,1)])words1=words.reduceByKey(lambda a,b:a+b)words1.foreach(print) 如图所示，在这个实例中，名称为 words 的 RDD 中包含了 9个元素，每个元素都是(K,V)键值对类型。words.reduceByKey(lambda a,b;atb)操作执行以后,所有 key 相同的键值对，它们的 value首先被归并到一起，比如，(“is”,1)、(“is”1)、(“is”,1)这3 个键值对的 key 相同，就会被归并成一个新的键值对(“is”,(1,1,1))，其中，key 是”is”，value 是一个 value-list，即(1,1,1)。然后，使用 func 函数把(l,1,1)聚合到一起，这里的 func 函数是一个Lambda 表达式，即 lambda a,b;atb，它的功能是把(1,1,1)这个 value-list 中的每个元素进行汇总求和。首先，把 value-list 中的第1个元素(即 1) 赋值给参数a，把 value-list 中的第 2个元素(也是 1)赋值给参数 b，执行 atb 得到 2，然后，继续对 value-list中的元素执行下一次计算，把刚才求和得到的 2 赋值给 a，把 value-list 中的第 3 个元素(即 1)赋值给b，再次执行 a+b 计算得到 3。最终，就得到聚合后的结果(‘is’,3)。 Ⅱ行动操作行动操作是真正触发计算的地方。Spark程序执行到行动操作时，才会执行真正的计算，从文件中加载数据，完成一次又一次转换操作，最终，完成行动操作得到结果。 用一个例子看看 12rdd =sc.parallelize([1,2,3,4,5])rdd.count() 5 12rdd.first() 1 1rdd.take(3) [1, 2, 3] 1rdd.reduce(lambda a,b:a+b) 15 1rdd.collect() [1, 2, 3, 4, 5] 1rdd.foreach(lambda elem:print(elem)) 1234512345 这里首先使用 sc.parallelize([1,2,3,4,5])生成了一个 RDD,变量名称为 rdd,rdd 中包含了5个元素分别是1、2、3、4和5，因此，rdd.count0语句执行以后返回的结果是 5。执行 rdd.first0语句后，会返回第1个元素，即1。当执行完 rdd.take(3)语句以后，会以列表的形式返回 rdd 中的前 3 个元素即[1,2,3]。执行完rdd.reduce(lambda a,b:a+b)语句后，会得到对 rdd 中的所有元素(即1、2、3、4、5进行求和以后的结果，即 15。在执行 rdd.reduce(lambda a,b;atb)时，系统会把 rdd 中的第1个元素1传入参数 a，把rdd 的第2个元素 2 传入参数 b，执行 a+b 计算得到求和结果 3;然后，把这个求和的结果 3 传入给参数 a，把 rdd 的第 3 个元素3 传入参数 b，执行 atb 计算得到求和结果 6; 然后,把6传入参数 a，把 rdd 的第 4 个元素 4 传入参数 b，执行 a+b 计算得到求和结果 10; 最后，把 10传入参数 a，把 rdd 的第 5个元素 5 传入参数 b，执行 atb 算得到求和结果 S。接下来，执行rdd.collect()，以列表的形式返回 rdd 中的所有元素，可以看出，执行结果是一个列表[1,2,3,4,5]。在这个实例的最后，执行了语句 rdd.foreach(lambda elem:print(elem)，该语句会依次遍历 rdd 中的每个元素，把当前遍历到的元素赋值给变量 elem，并使用 print(elem)打印出 elem 的值。实际上rdd.foreach(lambda elem:print(elem))可以被简化成 rdd.foreach(print)，执行效果是一样的。需要特别强调的是,当采用Local 模式在单机上执行时,rdd.foreach(print)语句会打印出一个RDD中的所有元素。但是，当采用集群模式执行时，在 Worker 节点上执行打印语句是输出到 Worker 节点的 stdout 中，而不是输出到任务控制节点 Driver 中，因此，任务控制节点 Driver 中的 stdout 是不会显示打印语句的这些输出内容的。为了能够把所有 Worker 节点上的打印输出信息也显示到 Driver中，就需要使用 collect0方法，比如，print(rdd.collect())。但是，由于 collect0方法会把各个 Worker节点上的所有 RDD元素都抓取到 Driver 中，因此，这可能会导致 Driver 所在节点发生内存溢出。所以，在实际编程中，需要谨慎使用&#96;&#96;&#96; collect()&#96;&#96;方法。 Ⅲ惰性机制惰性机制是指整个转换过程只是记录了转换的轨迹，并不会发生真正的计算，只有遇到行动操作时，才会触发“从头到尾”的真正的计算。这里给出一段简单的语句来解释 Spark 的惰性机制。 1234lines=sc.textFile(&quot;file:///usr/local/spark/mycode/rdd/word.txt&quot;)lineLengths=lines.map(lambda s:len(s))totalLength=lineLengths.reduce(lambda a,b:a+b)print(totalLength) 在上述语句中，第1 行语句中的 textFile()是一个转换操作，执行后，系统只会记录这次转换，并不会真正读取 wordtxt 文件的数据到内存中;第 2 行语句的 map也是一个转换操作，系统只是记录这次转换，不会真正执行 map()方法;第 3 行语句的 reduce()方法是一个“行动”类型的操作，这时，系统会生成一个作业，触发真正的计算。也就是说，这时才会加载 word.txt 的数据到内存，生成lines 这个RDD。lines 中的每个元素都是一行文本，然后，对 lines 执行 map()方法，计算这个RDD中每个元素的长度(即一行文本包含的单词个数 )，得到新的 RDD，即 lineLengths，这个RDD中每个元素都是整型，表示文本的长度。最后，在 lineLengths 上调用reduce()方法，执行 RDD元素求和，得到所有文本长度的总和。 持久化在 Spark 中，RDD 采用惰性求值的机制，每次遇到行动操作，都会从头开始执行计算。每次调用行动操作，都会触发一次从头开始的计算，这对于迭代计算而言，代价是很大的，因为选代计算经常需要多次重复使用同一组数据。下面就是多次计算同一个 RDD 的例子。 1234list = [&quot;Hadoop&quot;,&quot;Spark&quot;,&quot;Hive&quot;]rdd = sc.parallelize(list)print (rdd.count ()) #行动操作，触发一次真正从头到尾的计算print (&#x27;,&#x27;.join(rdd.collect())) #行动操作，触发一次真正从头到尾的计算Hadoop,Spark,Hive 实际上，可以通过持久化(缓存)机制来避免这种重复计算的开销。具体方法是使用 persist0方法将一个 RDD 标记为持久化，之所以要“标记为持久化”，是因为出现 persist0语句的地方，并不会马上计算生成 RDD 并把它持久化，而是要等到遇到第一个行动操作触发真正计算以后，才会把算结果进行持久化。持久化后的 RDD 将会被保留在计算节点的内存中，被后面的行动操作重复使用persist0的圆括号中包含的是持久化级别参数，可以有如下不同的级别。 persist(MEMORY ONLY): 表示将 RDD作为反序列化的对象存储于JVM 中，如果内存足，就要按照 LRU 原则替换缓存中的内容。 persist(MEMORYAND DISK):表示将RDD作为反序列化的对象存储在JVM中，如果内存不足，超出的分区将会被存放在硬盘上。 一般而言，使用 cache()方法时，会调用 persist(MEMORY ONLY)。针对上面的实例，增加持久化语句以后的执行过程如下: 12345list = [&quot;Hadoop&quot;,&quot;Spark&quot;,&quot;Hive&quot;]rdd = sc.parallelize(list)rdd.cache() #会调用 persist(MEMORY ONLY)，但是，语句执行到这里，并不会缓存 rdd，因为这#时 rdd 还没有被计算生成print(rdd.count()) #第一次行动操作，触发一次真正从头到尾的计算，这时上面的 rdd.cache ()#才会被执行，把这个 rdd 放到缓存中print(&#x27;.&#x27;.join(rdd.collect())) #第二次行动操作，不需要触发从头到尾的计算，只需要重复使#用上面缓存中的 rdd 持久化RDD 会占用内存空间，当不再需要一个 RDD 时，就可以使用 unpersist0方法手动地把持久化的 RDD 从缓存中移除，释放内存空间。 分区1.分区的作用RDD 是弹性分布式数据集，通常 RDD 很大，会被分成很多个分区，分别保存在不同的节点上如图49所示，一个集群中包含 4 个工作节点( WorkerNode )，分别是 WorkerNodel、WorkerNode2WorkerNode3 和 WorkerNode4。假设有两个 RDD，即rdd1 和 rdd2，其中，rdd1 包含5 个分区(即plp2、p3、p4和p5)，rdd2 包含3 个分区(即p6、p7和p8)。对RDD 进行分区，第一个作用是增加并行度。比如，在图 4-9 中，rdd2 的 3 个分区 p6、p7和p8,分布在3 个不同的工作节点 WorkerNode2、WorkerNode3 和 WorkerNode4 上，就可以在这3个T作节点上分别启动 3 个线程对这 3 个分区的数据进行并行处理，增加任务的并行度。 对 RDD 进行分区的第二个作用是减少通信开销。在分布式系统中，通信的代价是巨大的，控制数据分布以获得最少的网络传输可以极大地提升整体性能。Spark 程序可以通过控制 RDD 分区方式来减少网络通信的开销。下面通过一个实例来解释为什么通过分区可以减少网络传输开销。 连接(join)是查询分析中经常使用的一种操作。假设在某种应用中需要对两个表进行连接操作第1个表是一个很大的用户信息表 UserData(UserID,UserInfo)，其中，UserId 和 UserInfo 是 UserData表的两个字段，UserInfo 包含了某个用户所订阅的主题信息。第 2 个表是 Events(UserID,LinkInfo),这个表比较小，只记录了过去 5 分钟内发生的事件，即某个用户查看了哪个链接。为了对用户访问情况进行统计，需要周期性地对 UserData 和 Events 这两个表进行连接操作，获得(UserID,UserInfo,LinkInfo)这种形式的结果，从而知道某个用户订阅的是哪个主题，以及访问了哪个链接。 可以用 Spark 来实现上述应用场景。在执行 Spark 作业时，首先，UserData 表会被加载到内存中生成RDD(假设 RDD的名称为 userData)，RDD 中的每个元素是(UserID,UserInfo)这种形式的键值对,即 key 是 UserID,value 是 UserInfo;Events 表也会被加载到内存中生成RDD(假设名称为 events)RDD中的每个元素是(UserID，LinkInfo)这种形式的键值对，key 是 UserID，value 是 LinkInfo。由于UserData 是一个很大的表，通常会被存放到 HDFS 文件中，Spark 系统会根据每个 RDD 元素的数据来源，把每个 RDD 元素放在相应的节点上。比如，从工作节点 上的 HDFS 文件块 (block)中读取到的记录，其生成的 RDD 元素 ((UserID，UserInfo)形式的键值对 ，就会被放在节点上，从节点上的 HDFS 文件块 (block)中读取到的记录，其生成的 RDD 元素会被放在节点上，最终userData 这个 RDD 的元素就会分布在节点u1、u2…..um上。然后，执行连接操作 userData,join(events)得到连接结果。如图 所示，在默认情况下，连接操作会将两个数据集中的所有的 key 的哈希值都求出来，将哈希值相同的记录传送到同一台机器上之后在该机器上对所有 key 相同的记录进行连接操作。比如，对于 userData 这个 RDD 而言，它在节点山上的所有 RDD 元素，都需要根据 key 的值进行哈，然后，根据哈希值再分发到 j1、j2…..j这些节点上;在节点u上的所有 RDD 元素，也需要根据 key 的值进行哈希，然后，根据哈希值再分发到j1……jk这些节点上;同理，u1……um等节点上的 RDD元素，都需要进行同样的操作对于events 这个RDD 而言，也需要执行同样的操作。可以看出，在这种情况下，每次进行连接操作都会有数据混洗的问题，造成了很大的网络传输开销。 实际上，由于userData 这个 RDD 要比 events 大很多，所以，可以选择对 userData 进行分区。比如.可以采用哈希分区方法，把 userData 这个 RDD 分区成 m 个分区，这些分区分布在节点 、u…“u，上。对userData 进行分区以后，在执行连接操作时，就不会产生图 4-10 中的数据混洗情况。如图所示，由于已经对 userData 根据哈希值进行了分区，因此，在执行连接操作时，不需要再把 userData中的每个元素进行哈希求值以后再分发到其他节点上，只需要对 events 这个 RDD 的每个元素求哈希值(采用与 userData 相同的哈希函数)。然后，根据哈希值把每个 events 中的 RDD 元素分发到对应的节点u、u····um上面。整个过程中，只有 events 发生了数据混洗，产生了网络通信，而 userData的数据都是在本地引用，不会产生网络传输开销。由此可以看出，Spark 通过数据分区，可以大大降低一些特定类型的操作(比如join()、leftOuterJoin()、groupByKey()、reduceByKey()等)的网络传输开销。 2.分区的原则 RDD分区的一个原则是使得分区的个数尽量等于集群中的 CPU核心(Core)数目。对于不同的Spark 部署模式 (Local 模式、Standalone 模式、YARN 模式、Mesos 模式)而言，都可以通过设置spark.defaultparallelism 这个参数的值，来配置默认的分区数目。一般而言，各种模式下的默认分区数目如下。Local模式:默认为本地机器的 CPU 数目，若设置了 local[N]，则默认为 N。Standalone 或YARN模式:在“集群中所有 CPU 核心数目总和”和“2”这二者中取较大值作为默认值。Mesos 模式:默认的分区数为 8。 3.设置分区的个数可以手动设置分区的数量，主要包括两种方式: 创建 RDD 时手动指定分区个数;使用repartition方法重新设置分区个数。 (1)创建RDD 时手动指定分区个数 在调用 textFile()和 parallelize()方法的时候手动指定分区个数即可，语法格式如下: 1sc.textFile(path, partitionNum) 其中，path 参数用于指定要加载的文件的地址，partitionNum 参数用于指定分区个数。下面是个分区的实例。 12list = [1,2,3,4,5]rdd = sc.parallelize(list,2) //设置两个分区 对于 parallelize()而言，如果没有在方法中指定分区数，则默认为 spark.default,parallelism。对于textFile()而言，如果没有在方法中指定分区数，则默认为 min(defaultParallelism,2)，其中defaultParallelism 对应的就是 spark.default,parallelism。如果是从HDFS 中读取文件，则分区数为文件分片数(比如，128MB&#x2F;片 )。 (2)使用repartition 方法重新设置分区个数 通过转换操作得到新 RDD 时，直接调用 repartition 方法即可。例如: 123456data = sc.parallelize([1,2,3,4,5],2)len(data.glom().collect ()) #显示 data 这个 RDD 的分区数量2rdd = data.repartition(1) #对 data 这个RDD进行重新分区len(rdd.glom().collect())#显示 rdd 这个 RDD的分区数量1 4.自定义分区方法 Spark 提供了自带的 HashPartitioner (哈希分区)与 RangePartitioner ( 区城分区)，能够满足大数应用场景的需求。与此同时，Spark 也支持自定义分区方式，即通过提供一个自定义的分区函数来控制 RDD 的分区方式，从而利用领域知识进一步减少通信开销。需要注意的是，Spark 的分区函数针对的是(key;value)类型的 RDD，也就是说，RDD 中的每个元素都是(key,value)类型，然后，分区数根据 key对RDD 元素进行分区。因此，当需要对一些非(key,value)类型的 RDD进行自定义分区时需要首先把 RDD 元素转换为(key,value)类型，然后再使用分区函数。下面是一个实例，要求根据 key 值的最后一位数字将 key 写入到不同的文件中，比如，10 写入到part-00000，11写入到 part-00001，12 写入到 part-00002。打开一个 Linux 终端，使用 vim 编辑器创建一个代码文件“&#x2F;usr&#x2F;local&#x2F;spark&#x2F;mycode&#x2F;rdd&#x2F;TestPartitioner.py”，输入以下代码: 12345678910111213141516171819from pyspark import SparkConf, SparkContextdef MyPartitioner(key): print(&quot;MyPartitioner is running&quot;) print(&#x27;The key is %d&#x27; % key) return key%10def main(): print(&quot;The main function is running&quot;) conf=SparkConf().setMaster(&quot;local&quot;).setAppName(&quot;MyApp&quot;) sc=SparkContext(conf=conf) data=sc.parallelize(range(10),5) data.map(lambda x:(x,1)) \\ .partitionBy(10,MyPartitioner)\\ .map(lambda x:x[0]) \\ .saveAsTextFile(&quot;File:///usr/local/spark/mycode/add/partitioner&quot;)if __name__==&#x27;__main__&#x27;: main() 出现问题 ModuleNotFoundError: No module named &#39;pyspark&#39; 12apt install python3-pippip install pyspark 在上述代码中，data&#x3D;sc.parallelize(range(10),5)这行代码执行后，会生成一个名称为 data 的 RDD这个RDD 中包含了 0、1、2、3…..9 共 10 个整型元素，并被分成 5个分区。data,map(lambda x:(x,1)表示把 data 中的每个整型元素取出来，转换成(key,value)类型。比如，把1 这个元素取出来以后转按成(1,1)，把2这个元素取出来以后转换成(2,1)，这是因为，自定义分区函数要求 RDD 元素的类型必须是(key, value)类型。partitionBy(10,MyPartitioner表示调用自定义分区函数，把(0,1)、(,)、(2,1)、(3,1)….(9,1)这些 RDD 元素根据尾号分成10个分区。划分分区完成以后,再使用 map(ambda x:x[0).把(0,1)、(1,1)、(2,1)、(3,1) .·….(9,1)等(key,value)类型元素的 key 提取出来，得到 0、1、2、3…9.最后调用 saveAsTextFile0方法把 RDD的 10个整型元素写入到本地文件中。 使用如下命令运行 TestPartitioner.py: 12cd /usr/local/spark/mycode/rddpython3 TestPartitioner.py or 12$ cd /usr/local/spark/mycode/rddS /usr/local/spark/bin/spark-submit TestPartitioner.py 程序运行后会返回如下信息: 1234567The main function is runningMyPartitioner is runningThe key is 0MyPartitioner is runningThe key is 1MyPartitioner is runningThe key is 9 运行结束后可以看到，在本地文件系统的“file:&#x2F;&#x2F;&#x2F;usr&#x2F;local&#x2F;spark&#x2F;mycode&#x2F;rdd&#x2F;partitioner”目录下面，会生成 part-00000、part-00001、part-00002…..part-00009 和_SUCCESS 等文件。其中,part-00000文件中包含了数字 0，part-00001 文件中包含了数字 1，part-00002 文件中包含了数字 2 综合实例假设有一个本地文件“&#x2F;usr&#x2F;local&#x2F;spark&#x2F;mycode&#x2F;rdd&#x2F;word.txt”，里面包含了很多行文本，每行文本由多个单词构成，单词之间用空格分隔。可以使用如下语句对 word.txt 中的单词进行词频统计(即统计每个单词出现的次数 ): 1lines=sc.textFile(&quot;file:///usr/local/spark/mycode/rdd/word.txt&quot;) 1wordCount=lines.flatMap(lambda line:line.split(&quot; &quot;)).map(lambda word:(word,1)).reduceByKey(lambda a,b:a+b) 1print(wordCount.collect()) 在实际应用中，单词文件可能非常大，会被保存到分布式文件系统 HDFS 中，Spark 和 Hadoop会统一部署在一个集群上。如图所示，HDFS 的名称节点(HDFS NN)和 Spark 的主节点( SparkMaster)可以分开部署，而HDFS 的数据节点(HDFS DN)和 Spark 的从节点 ( Spark Worker)会部署在一起。这时采用 Spark 进行分布式处理,可以大大提高词频统计程序的执行效率,这是因为,SparkWorker 可以就近处理与自己部署在一起的 HDFS 数据节点中的数据。 对于词频统计程序 WordCount 而言，该程序分布式运行在每个 Slave 节点的每个分区上，统计本分区内的单词计数，然后将它传回给 Driver，再由 Driver 合并来自各个分区的所有单词计数，形成最终的单词计数。","categories":[{"name":"2023","slug":"2023","permalink":"http://example.com/categories/2023/"}],"tags":[{"name":"Spark","slug":"Spark","permalink":"http://example.com/tags/Spark/"}]},{"title":"UML类图 & UML时序图","slug":"UML类图-&-UML时序图","date":"2023-03-20T08:08:25.851Z","updated":"2023-03-20T08:08:25.852Z","comments":true,"path":"2023/03/20/UML类图-&-UML时序图/","link":"","permalink":"http://example.com/2023/03/20/UML%E7%B1%BB%E5%9B%BE-&-UML%E6%97%B6%E5%BA%8F%E5%9B%BE/","excerpt":"","text":"2.1 UML图2.1 UML类图 &amp; UML时序图统一建模语言（Unified Modeling Language，UML）是用来设计软件的可视化建模语言。它的特点是简单、统一、图形化、能表达软件设计中的动态与静态信息。UML是一种为面向对象系统的产品进行说明、可视化和编制文档的标准语言，独立于任何一种具体的程序设计语言。 1997 年 UML 被国际对象管理组织（OMG）采纳为面向对象的建模语言的国际标准。它的特点是简单、统一、图形化、能表达软件设计中的动态与静态信息。 应用场景 UML 能为软件开发的所有阶段提供模型化和可视化支持。而且融入了软件工程领域的新思想、新方法和新技术，使软件设计人员沟通更简明，进一步缩短了设计时间，减少开发成本。 UML 具有很宽的应用领域。其中最常用的是建立软件系统的模型，但它同样可以用于描述非软件领域的系统，如机械系统、企业机构或业务过程，以及处理复杂数据的信息系统、具有实时要求的工业系统或工业过程等。总之，UML 可以对任何具有静态结构和动态行为的系统进行建模，而且使用于从需求规格描述直至系统完成后的测试和维护等系统开发的各个阶段。 UML 模型大多以图表的方式表现出来，一份典型的建模图表通常包含几个块或框、连接线和作为模型附加信息的文本。这些虽简单却非常重要，在 UML 规则中相互联系和扩展。 语言是包括文字和图形的，有很多内容文字是无法表达的。比如建筑设计图纸吗，里面存在多图形，光用文字并不能表达清楚建筑设计。在建筑界，有一套标准来描述设计，同样道理，在软件开发界，也需要一套标准来帮助我们做好软件开发的工作。UML 就是其中的一种标准，注意这可不是唯一标准，只是 UML 是大家比较推崇的一种标准而已。UML 并不是强制性标准，没有规定在软件开发中一定要用 UML，但是我们需要包括 UML 在内的各种标准，来提高软件开发的水平。 基本构件 UML 建模的核心是模型，模型是现实的简化、真实系统的抽象。UML 提供了系统的设计蓝图。当给软件系统建模时，需要采用通用的符号语言，这种描述模型所使用的语言被称为建模语言。在 UML 中，所有的描述由事物、关系和图这些构件组成。下图完整地描述了所有构件的关系。 事物 事物是抽象化的最终结果，分为结构事物、行为事物、分组事物和注释事物。 结构事物 结构事物是模型中的静态部分，用以呈现概念或实体的表现元素，如下表所示。 行为事物 行为事物指 UML 模型中的动态部分，如下表所示。 分组事物 目前只有一种分组事物，即包。包纯碎是概念上的，只存在于开发阶段，结构事物、行为事物甚至分组事物都有可能放在一个包中，如下表所示。 注释事物 注释事物是解释 UML 模型元素的部分，如下表所示。 UML 从目标系统的不同角度出发，UML2.0 一共有 13 种图（UML1.5 定义了 9 种，UML2.0 增加了 4 种），别是类图、对象图、构件图、部署图、活动图、状态图、用例图、时序图、协作图 9 种，以及包图、组合结构图、时间图、交互概览图 4 种。 在 UML 2.0 的 13 种图中，类图（Class Diagrams）是使用频率最高的 UML 图之一。类图描述系统中的类，以及各个类之间的关系的静态视图，能够让我们在正确编写代码之前对系统有一个全面的认识。类图是一种模型类型，确切地说，是一种静态模型类型。类图表示类、接口和它们之间的协作关系，用于系统设计阶段。 2.1.1 类图概述类图(Class diagram)是显示了模型的静态结构，特别是模型中存在的类、类的内部结构以及它们与其他类的关系等。类图不显示暂时性的信息。类图是面向对象建模的主要组成部分。 2.1.2 类图作用 在软件工程中，类图是一种静态的结构图，描述了系统的类的集合，类的属性和类之间的关系，可以简化了人们对系统的理解； 类图是系统分析和设计阶段的重要产物，是系统编码和测试的重要模型。 2.1.3 类图表示 1.类 ​ 类（Class）是指具有相同属性、方法和关系的对象的抽象，它封装了数据和行为，是面向对象程序设计（OOP）的基础，具有封装性、继承性和多态性等三大特性。 (1) 类名（Name）是一个字符串，例如，Student。 (2) 属性（Attribute）是指类的特性，即类的成员变量。 (3) 操作（Operations）是类的任意一个实例对象都可以使用的行为，是类的成员方法。 在UML类图中，类使用包含类名、属性(field) 和方法(method) 且带有分割线的矩形来表示，比如下图表示一个Employee类，它包含name,age和address这3个属性，以及work()方法。 ​ 属性&#x2F;方法名称前加的加号和减号表示了这个属性&#x2F;方法的可见性，UML类图中表示可见性的符号有三种： +：表示public -：表示private #：表示protected ​ 属性的完整表示方式是： 可见性 名称 ：类型 [ &#x3D; 缺省值] ​ 方法的完整表示方式是： 可见性 名称(参数列表) [ ： 返回类型] 注意： 1，中括号中的内容表示是可选的 2，也有将类型放在变量名前面，返回值类型放在方法名前面 举个例子： ​ 上图Demo类定义了三个方法： method()方法：修饰符为public，没有参数，没有返回值。 method1()方法：修饰符为private，没有参数，返回值类型为String。 method2()方法：修饰符为protected，接收两个参数，第一个参数类型为int，第二个参数类型为String，返回值类型是int。 类图中，需注意以下几点： 抽象类或抽象方法用斜体表示 如果是接口，则在类名上方加 &lt;&gt; 字段和方法返回值的数据类型非必需 静态类或静态方法加下划线 另外一个例子： 请看以下这个类图，类之间的关系是我们需要关注的： 车的类图结构为&lt;&gt;，表示车是一个抽象类； 它有两个继承类：小汽车和自行车；它们之间的关系为实现关系，使用带空心箭头的虚线表示； 小汽车为与SUV之间也是继承关系，它们之间的关系为泛化关系，使用带空心箭头的实线表示； 小汽车与发动机之间是组合关系，使用带实心箭头的实线表示； 学生与班级之间是聚合关系，使用带空心箭头的实线表示； 学生与身份证之间为关联关系，使用一根实线表示； 学生上学需要用到自行车，与自行车是一种依赖关系，使用带箭头的虚线表示； 2. 接口 接口（Interface）是一种特殊的类，它具有类的结构但不可被实例化，只可以被子类实现。它包含抽象操作，但不包含属性。它描述了类或组件对外可见的动作。在 UML 中，接口使用一个带有名称的小圆圈来进行表示。 如下所示是图形类接口的 UML 表示。 3. 类图 类图（ClassDiagram）是用来显示系统中的类、接口、协作以及它们之间的静态结构和关系的一种静态模型。它主要用于描述软件系统的结构化设计，帮助人们简化对软件系统的理解，它是系统分析与设计阶段的重要产物，也是系统编码与测试的重要模型依据。 类图中的类可以通过某种编程语言直接实现。类图在软件系统开发的整个生命周期都是有效的，它是面向对象系统的建模中最常见的图。如下所示是“计算长方形和圆形的周长与面积”的类图，图形接口有计算面积和周长的抽象方法，长方形和圆形实现这两个方法供访问类调用。 2.1.4 类与类之间关系的表示 关联关系(association) 关联关系是用一条直线表示的；它描述不同类的对象之间的结构关系；它是一种静态关系， 通常与运行状态无关，一般由常识等因素决定的；它一般用来定义对象之间静态的、天然的结构； 所以，关联关系是一种“强关联”的关系； 比如，乘车人和车票之间就是一种关联关系；学生和学校就是一种关联关系； 关联关系默认不强调方向，表示对象间相互知道；如果特别强调方向，如下图，表示A知道B，但 B不知道A； 注：在最终代码中，关联对象通常是以成员变量的形式实现的； 关联关系是类与类之间最常用的一种关系，分为一般关联关系、聚合关系和组合关系。我们先介绍一般关联。关联又可以分为单向关联，双向关联，自关联。 a）单项关联 在UML类图中单向关联用一个带箭头的实线表示。上图表示每个顾客都有一个地址，这通过让Customer类持有一个类型为Address的成员变量类实现。 b）双向关联 从上图中我们很容易看出，所谓的双向关联就是双方各自持有对方类型的成员变量。 在UML类图中，双向关联用一个不带箭头的直线表示。上图中在Customer类中维护一个List，表示一个顾客可以购买多个商品；在Product类中维护一个Customer类型的成员变量表示这个产品被哪个顾客所购买。 c）自关联 自关联在UML类图中用一个带有箭头且指向自身的线表示。上图的意思就是Node类包含类型为Node的成员变量，也就是“自己包含自己”。 2. 聚合关系(aggregation)聚合关系是关联关系的一种，是强关联关系，是整体和部分之间的关系。 聚合关系也是通过成员对象来实现的，其中成员对象是整体对象的一部分，但是成员对象可以脱离整体对象而独立存在。例如，学校与老师的关系，学校包含老师，但如果学校停办了，老师依然存在。 聚合关系用一条带空心菱形箭头的直线表示，如下图表示A聚合到B上，或者说B由A组成； 下图所示是大学和教师的关系图： 3. 组合关系(composition)组合表示类之间的整体与部分的关系，但它是一种更强烈的聚合关系。 在组合关系中，整体对象可以控制部分对象的生命周期，一旦整体对象不存在，部分对象也将不存在，部分对象不能脱离整体对象而存在。例如，头和嘴的关系，没有了头，嘴也就不存在了。 在 UML 类图中，组合关系用带实心菱形的实线来表示，菱形指向整体。如下图表示A组成B，或者B由A组成； 下图所示是头和嘴的关系图： 与聚合关系一样，组合关系同样表示整体由部分构成的语义；比如公司由多个部门组成； 但组合关系是一种强依赖的特殊聚合关系，如果整体不存在了，则部分也不存在了；例如， 公司不存在了，部门也将不存在了； 4. 依赖关系(dependency)依赖关系是一种使用关系，它是对象之间耦合度最弱的一种关联方式，是临时性的关联。在代码中，某个类的方法通过局部变量、方法的参数或者对静态方法的调用来访问另一个类（被依赖类）中的某些方法来完成一些职责。 在 UML 类图中，依赖关系使用带箭头的虚线来表示，箭头从使用类指向被依赖的类。如下图表示A依赖于B；他描述一个对象在运行期间会用到另一个对象的关系； 下图所示是司机和汽车的关系图，司机驾驶汽车： 与关联关系不同的是，它是一种临时性的关系，通常在运行期间产生，并且随着运行时的变化； 依赖关系也可能发生变化； 显然，依赖也有方向，双向依赖是一种非常糟糕的结构，我们总是应该保持单向依赖，杜绝双向依赖的产生； 注：在最终代码中，依赖关系体现为类构造方法及类方法的传入参数，箭头的指向为调用关系；依赖关系除了临时知道对方外，还是“使用”对方的方法和属性； 5. 继承关系&#x2F;泛化关系(generalization)继承关系是对象之间耦合度最大的一种关系，表示一般与特殊的关系，是父类与子类之间的关系，是一种继承关系。类的继承结构表现在UML中为：泛化(generalize)与实现(realize)： 继承关系为 is-a的关系；两个对象之间如果可以用 is-a 来表示，就是继承关系：（..是..) eg：自行车是车、猫是动物 在 UML 类图中，泛化关系用带空心三角箭头的实线来表示，箭头从子类指向父类。如下图表示（A继承自B）； 例如，汽车在现实中有实现，可用汽车定义具体的对象；汽车与SUV之间为泛化关系； 再比如，Student 类和 Teacher 类都是 Person 类的子类，其类图如下图所示： 注：最终代码中，泛化关系表现为继承非抽象类； 6. 实现关系(realize)实现关系是接口与实现类之间的关系。在这种关系中，类实现了接口，类中的操作实现了接口中所声明的所有的抽象操作。 在 UML 类图中，实现关系使用带空心三角箭头的虚线来表示，箭头从实现类指向接口。 比如：”车”为一个抽象概念，在现实中并无法直接用来定义对象；只有指明具体的子类(汽车还是自行车)，才 可以用来定义对象（”车”这个类在C++中用抽象类表示，在JAVA中有接口这个概念，更容易理解） 再例如，汽车和船实现了交通工具，其类图如图 9 所示。 注：最终代码中，实现关系表现为继承抽象类； 类关系记忆技巧如下表所示。 注意：UML 的标准类关系图中，没有实心箭头。有些 Java 编程的 IDE 自带类生成工具可能出现实心箭头，主要目的是降低理解难度。 下面用一个经典案例来加深和巩固对类图的理解。下图是对动物衍生关系描述的类图。这个图非常有技术含量也非常经典，大家可以好好理解一下。 2.1.5 时序图为了展示对象之间的交互细节，后续对设计模式解析的章节，都会用到时序图； 时序图（Sequence Diagram）是显示对象之间交互的图，这些对象是按时间顺序排列的。时序图中显示的是参与交互的对象及其对象之间消息交互的顺序。 时序图包括的建模元素主要有：对象（Actor）、生命线（Lifeline）、控制焦点（Focus of control）、消息（Message）等等。 角色（Actor）： 系统角色，可以是人、及其甚至其他的系统或者子系统。 对象（Object）： 对象包括三种命名方式： 第一种方式包括对象名和类名； 第二中方式只显示类名不显示对象名，即表示他是一个匿名对象； 第三种方式只显示对象名不显示类明。 生命线（Lifeline）： 生命线在顺序图中表示为从对象图标向下延伸的一条虚线，表示对象存在的时间，如下图 控制焦点（Focus of Control）： 控制焦点是顺序图中表示时间段的符号，在这个时间段内对象将执行相应的操作。用小矩形表示，如下图。 消息（Message）： 消息一般分为同步消息（Synchronous Message），异步消息（Asynchronous Message）和返回消息（Return Message）.如下图所示： 同步消息&#x3D;调用消息（Synchronous Message）： 消息的发送者把控制传递给消息的接收者，然后停止活动，等待消息的接收者放弃或者返回控制。用来表示同步的意义。 异步消息（Asynchronous Message）： 消息发送者通过消息把信号传递给消息的接收者，然后继续自己的活动，不等待接受者返回消息或者控制。异步消息的接收者和发送者是并发工作的。 返回消息（Return Message）： 返回消息表示从过程调用返回 自关联消息（Self-Message）： 表示方法的自身调用以及一个对象内的一个方法调用另外一个方法。 组合片段示例： Alternative fragment（denoted “alt”） 与 if…then…else对应 Option fragment (denoted “opt”) 与 Switch对应 Parallel fragment (denoted “par”) 表示同时发生 Loop fragment(denoted “loop”) 与 for 或者 Foreach对应 时序图实例分析（Sequece Diagram Example Analysis） 完成课程创建功能，主要流程有： 1、请求添加课程页面，填写课程表单，点击【create】按钮 2、添加课程信息到数据库 3、向课程对象追加主题信息 4、为课程指派教师 5、完成课程创建功能 1、序号1.0-1.3 完成页面的初始化 2、序号1.4-1.5 课程管理员填充课程表单 3、序号1.6-1.7 课程管理员点击【Create】按钮，并响应点击事件 4、序号1.8 Service层创建课程 5、序号1.9-1.10 添加课程到数据库，并返回课程编号CourseId 6、序号1.11-1.12 添加课程主题到数据库，并返回主题编号topicId 7、序号1.13 给课程指派教师 8、序号1.14 向界面抛创建课程成功与否的消息","categories":[{"name":"2023","slug":"2023","permalink":"http://example.com/categories/2023/"}],"tags":[{"name":"设计模式","slug":"设计模式","permalink":"http://example.com/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"}]},{"title":"Python类","slug":"Python类","date":"2023-03-20T04:58:38.022Z","updated":"2023-03-20T07:04:48.617Z","comments":true,"path":"2023/03/20/Python类/","link":"","permalink":"http://example.com/2023/03/20/Python%E7%B1%BB/","excerpt":"","text":"Python类类(class) 和 对象(object)类：创建对象的模板，定义对象将会拥有的属性和函数 __init__函数：每个类必须定义的函数，对象创建语句时自动执行 123456789class myday: #建立一个类模板 def __init__(): .....day1 = myday() #创建一个myday类的对象 python类类名：mayday属性：name和emotion函数：init函数，wake函数，eat函数 1234567891011121314151617181920# 类(class)class myday: def __init__(self): #每个类必须定义(def) __init__函数，每个函数第一参数都是self self.name = &quot;Xiao Ming&quot; #myday对象拥有属性name和emotion self.emotion = &quot;happy&quot; def wake(self,event): if event == &quot;上课&quot;: self.emotion = &quot;still happy&quot; def eat(self, food): if food == &quot;牛肉&quot;: self.emotion = &quot;more happy&quot; #def __eq__(self,other): #return self.name == other.nameday2 = myday()#创建对象时会自动执行__init__方法print(day2.emotion)print(day2.name) __init__函数添加参数 创建对象时传入self之后的参数 12345678910111213141516171819class myday: def __init__(self,name,emotion): self.emotion = emotion #定义对象属性“self.emotion”，将这个属性赋值为函数传入的参数“emotion” self.name = name def wake(self,event): if event == &quot;上课&quot;: self.emotion = &quot;still happy&quot; def eat(self, food): if food == &quot;牛肉&quot;: self.emotion = &quot;more happy&quot; #def __eq__(self,other): #return self.name == other.nameday2 = myday(&quot;me&quot;,&quot;very happy&quot;)#创建对象时会自动执行__init__函数print(day2.name)print(day2.emotion) 1234567891011121314151617181920212223class myday: def __init__(self,name,emotion): self.emotion = emotion #定义对象属性“self.emotion”，将这个属性赋值为函数传入的参数“emotion” self.name = name def wake(self,event): if event == &quot;上课&quot;: self.emotion = &quot;still happy&quot; def eat(self, food): if food == &quot;牛肉&quot;: self.emotion = &quot;more happy&quot; #def __eq__(self,other): #return self.name == other.nameday2 = myday(&quot;me&quot;,&quot;very happy&quot;)#调用对象函数时，从self之后的参数开始传入day2.eat(&quot;jiaozi&quot;)print(day2.emotion)day2.eat(&quot;牛肉&quot;)print(day2.emotion) 任务：编写一个类继承myday类12345678910111213141516171819202122232425262728293031323334class myday: def __init__(self,name,emotion): self.emotion = emotion #定义对象属性“self.emotion”，将这个属性赋值为函数传入的参数“emotion” self.name = name def wake(self,event): if event == &quot;上课&quot;: self.emotion = &quot;still happy&quot; def eat(self, food): if food == &quot;牛肉&quot;: self.emotion = &quot;more happy&quot; #def __eq__(self,other): #return self.name == other.nameday2 = myday(&quot;me&quot;,&quot;very happy&quot;)#创建对象时，程序会自动执行__init__函数day2.eat(&quot;jiaozi&quot;)print(day2.emotion)day2.eat(&quot;牛肉&quot;)print(day2.emotion)#类的继承 和 函数重写class night(myday): #night类继承myday类 def __init__(self): self.emotion = &quot;nice&quot; self.name = &quot;me&quot; def play(self): self.emotion = &quot;so nice&quot;night1 = night()night1.eat(&quot;羊肉&quot;) #night继承myday类除__init__之外的函数print(night1.emotion)night1.eat(&quot;牛肉&quot;)print(night1.emotion) 一个类是否等于另一个类？1234567day1 = myday(&quot;a&quot;,&quot;happy&quot;)day2 = myday(&quot;a&quot;,&quot;happy&quot;)day1.name == day2.name #True or Falseday1 == day2 #True or False?#（如果我们在类里定义一个__eq__函数，当我们执行 day1 == day2语句的时候，程序会自动执行__eq__函数） 多线程开发案例123456789101112131415161718192021import timeimport threadingclass TestThread(threading.Thread): def __init__(self, para=&#x27;hi&#x27;, sleep=3): super().__init__() self.para = para self.sleep = sleep def run(self): &quot;&quot;&quot;线程内容&quot;&quot;&quot; time.sleep(self.sleep) print(self.para)thread_hi = TestThread()thread_hello = TestThread(&#x27;hello&#x27;, 1) # 启动线程thread_hi.start()thread_hello.start() 任务！：按照如下描述定义一个类，代表一个企业class company: init函数：定义资金（money)属性，产品(product)属性和价格（price）属性 register函数：公司注册，修改资金属性 produce函数：制造，修改资金属性，修改产品属性 sale函数：销售，修改资金属性和产品属性 research函数：研发，修改资金属性和价格属性 任务！：定义另一个类，继承company类，重写research函数（子类需要添加至少一个新的函数，并重写至少一个父类的函数。） 12345678910111213141516171819class company: def __init__(self,money,product,price) : self.money=money self.product=product self.price=price def register(self,tol_money):#注册资金 self.money=tol_money def produce(self,pro_money,product_num): self.money-=pro_money#生产就减少了 self.product+=product_num#产品多了 def sale(self,sal_money,product_num): self.money+=sal_money#钱多了 self.product-=product_num#产品减少了 def research(self,re_money,re_price): self.money-=re_money#钱减少了 self.price+=re_price#价格上去了company1=company(&quot;1000&quot;,&quot;机器&quot;,&quot;100/2&quot;)company1.register(&quot;5000&quot;)print(company1.money) research函数：研发，修改资金属性和价格属性，产品属性 invert函数:投资，修改金钱属性 12345678910111213141516class BigCompany(company): def __init__(self,money,product,price): super().__init__(money,product,price) def research(self,re_money,re_price,re_prodcut): self.money=re_money#钱减少了 self.price+=re_price#价格上去了 self.product+=re_prodcut#产品多了 def inverst(self,invstment_money): self.money-=invstment_moneycompany2=BigCompany(7000,2,50)company2.research(8000,80,90)company2.inverst(908070)print(company2.money)","categories":[{"name":"2023","slug":"2023","permalink":"http://example.com/categories/2023/"}],"tags":[{"name":"python","slug":"python","permalink":"http://example.com/tags/python/"}]},{"title":"如何在Linux系统下编译C++","slug":"如何在Linux系统下编译C++","date":"2023-03-17T13:50:45.280Z","updated":"2023-03-17T14:05:29.847Z","comments":true,"path":"2023/03/17/如何在Linux系统下编译C++/","link":"","permalink":"http://example.com/2023/03/17/%E5%A6%82%E4%BD%95%E5%9C%A8Linux%E7%B3%BB%E7%BB%9F%E4%B8%8B%E7%BC%96%E8%AF%91C++/","excerpt":"","text":"如何在Linux系统下编译C++方法一:12345678#include&lt;iostream&gt;#include&lt;cstdio&gt;using namespace std;int main()&#123; cout&lt;&lt;&quot;hello_word&quot;; return 0;&#125; 编译 1gcc 1.cpp -lstdc++ 生a.out文件 运行a.out 1./a.out 方法二:12345678#include&lt;iostream&gt;#include&lt;cstdio&gt;using namespace std;int main()&#123; cout&lt;&lt;&quot;hello_word222&quot;; return 0;&#125; 编译 1g++ 2.cpp -o 2output 运行2output 1./2output","categories":[{"name":"2023","slug":"2023","permalink":"http://example.com/categories/2023/"}],"tags":[{"name":"linux_c++","slug":"linux-c","permalink":"http://example.com/tags/linux-c/"}]},{"title":"操作系统——进程同步——生产者消费者问题","slug":"进程同步","date":"2023-03-17T03:21:38.374Z","updated":"2023-03-24T00:36:45.212Z","comments":true,"path":"2023/03/17/进程同步/","link":"","permalink":"http://example.com/2023/03/17/%E8%BF%9B%E7%A8%8B%E5%90%8C%E6%AD%A5/","excerpt":"","text":"进程同步 pv 操作 互斥锁 1234P --wait(信号量S)&#123; S&lt;=0 S-- //上锁&#125; 成对出现 123V --signal(信号量)&#123; S++ //开锁&#125; 生产者 123456789101112131415int in(),out=();item butter[n];semaphore mutex=1,empty=n,full=();//mutex必须为1 ,empty空位置,full有多少个void proceducer()&#123; do&#123; producer an item nextp; …… wait(empty); //enpty-- wait(mutex); //上锁 butter[in]=nextp; //生产一个 in:=(in+1)%n; // 生产一个 signal(mutex); //解锁 signal(full); //full++ &#125;while(TRUE)；&#125; 消费者 1234567891011void consumer()&#123; do&#123; wait(full)； //full-1 wait(mutex); //上锁 nextc=butter[out]; //消费一个 out=(out+1)%n; //消费一个 signal(mutex); //解锁 signal(empty); //empty++ consumer the item in nextc; &#125;while(TRUE);&#125; 12345void main()&#123; cobegin proceducer();consumer(); coend&#125; 第1关：生产者消费者同步控制任务描述本关任务：编写生产者消费者同步控制程序。 相关知识为了完成本关任务，你需要掌握：1.理解生产者消费者同步问题，2.线程的编写方法，3.使用信号量实现线程间同步控制。 线程并发引起的同步问题线程以并发形式运行，当并发的线程间访问共享数据时，会发后争用现象，不进行同步控制的线程运行会造成不恰当的结果。 生产者消费者同步问题生产者消费者是典型的同步问题，他们共享了一个缓冲池(全局变量数组)，当缓冲池有空位时生产者线程向缓冲池中依次赋值，如果缓冲池满则等待。当缓冲池中有数据时消费者线程从中取走数据，如果缓冲池空则等待。 如何解决线程间访问共享变量的冲突问题当多个线程访问同一个共享变量时，共享变量成为临界资源，它需要操作系统提供同步控制机制，以保证多个线程可以依序访问，当一个线程操作临界资源时其它线程不会中断其操作，因此对临界资源的操作是安全的。 下面是linux平台使用信号量的头文件和方法。 #include &lt;semaphore.h&gt; int sem_init(sem_t * sem, int pshared, unsigned int value);&#x2F;&#x2F;创建信号量变量，value是信号量的初值 int sem_destroy(sem_t *sem);&#x2F;&#x2F;销毁信号量 int sem_post(sem_t * sem); &#x2F;&#x2F;信号量值增加1，并激活处于等待状态的线程 int sem_wait(sem_t * sem); &#x2F;&#x2F;信号量值减少1 为0时将调用该方法的线程被OS阻塞 编程要求主线程序启动生产者线程和消费者线程，并等待两个线程的结束。 两个线程使用三个信号量，其中生产者线程向全局变量进行十次赋值(代表生产)，每次赋值前都要检查是否有空位，有空位的情况下 需要获得互斥量sem_mutex，并对共享缓冲区进行赋值，然后释放互斥量以便消费者线程可以操作缓冲区临界资源。 消费者线程要从缓冲区取值，取值前先检查是否有可用数据，有可用数据的情况下再获得互斥量sem_mutex，再取出缓冲区的值。 要特别说明的是生产者和消费者线程工作的速率是不同的，但在同步信号控制下，两个线程节奏互相配合步调一致。在《计算机操作系统》 教材中使用了伪代码，并且循环体没有结束条件，在此用C语言改写原程序，生产者一共只生产十个数据。 ####测试说明 为简化数据操作，程序没有输入，主线程已经写好， void * producer(void * arg); void * consumer(void * arg); static sem_t sem_empty;&#x2F;&#x2F;空位个数 static sem_t sem_full; &#x2F;&#x2F;可用数据个数 static sem_t sem_mutex; &#x2F;&#x2F;互斥量，用于控制两个线程互斥访问缓冲区 static int buffer[]&#x3D;{0,0,0}; int main(int argc,char * argv[]) { pthread_t id_prod,id_consum; sem_init(&amp;sem_empty,0,3); &#x2F;&#x2F;初值为3，空位为3， sem_init(&amp;sem_full,0,0); &#x2F;&#x2F;初值为0，可用数据个数为0， sem_init(&amp;sem_mutex,0,1); &#x2F;&#x2F;初值为1，用于控制两个线程互斥访问缓冲区 pthread_create(&amp;id_prod, NULL,producer,NULL);&#x2F;&#x2F;创建生产者线程 pthread_create(&amp;id_consum,NULL,consumer,NULL);&#x2F;&#x2F;创建消费者线程 pthread_join(id_prod,NULL); &#x2F;&#x2F;主线程等待生产者线程结束 pthread_join(id_consum,NULL);&#x2F;&#x2F;主线程等待消费者线程结束 sem_destroy(&amp;sem_empty); sem_destroy(&amp;sem_full); sem_destroy(&amp;sem_mutex); return 0; } 学生需要补充producer线程与consumer中关于同步控制部分的程序。 输出：1至10 (需由学生根据程序生成正确结果) 开始你的任务吧，祝你成功！ 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667//stu001.c 生产者消费者同步控制，由学生完成缺失代码。 //主线程序启动生产者线程和消费者线程，全局变量初值为0//生产者线程向全局变量进行10次赋值(代表生产)，消费者线程从全局变量读取值，///并重新赋值0(代表消费了产品)#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt; #include &lt;pthread.h&gt;#include &lt;semaphore.h&gt; void * producer(void * arg);void * consumer(void * arg);static sem_t sem_empty;//空位个数static sem_t sem_full; //可用数据个数static sem_t sem_mutex; //互斥量，用于控制两个线程互斥访问缓冲区static int buffer[]=&#123;0,0,0&#125;;//共享的缓冲区int main(int argc,char * argv[])&#123; pthread_t id_prod,id_consum; sem_init(&amp;sem_empty,0,3); //初值为3，空位为3， sem_init(&amp;sem_full,0,0); //初值为0，可用数据个数为0， sem_init(&amp;sem_mutex,0,1); //初值为1，用于控制两个线程互斥访问缓冲区 pthread_create(&amp;id_prod, NULL,producer,NULL);//创建生产者线程 pthread_create(&amp;id_consum,NULL,consumer,NULL);//创建消费者线程 pthread_join(id_prod,NULL); //主线程等待生产者线程结束 pthread_join(id_consum,NULL);//主线程等待消费者线程结束 sem_destroy(&amp;sem_empty); sem_destroy(&amp;sem_full); sem_destroy(&amp;sem_mutex); return 0;&#125;void * producer(void * arg)&#123; int i,pIndex=0; for(i=11;i&lt;21;i++) &#123; //请在begin end语句间补全程序语句实现生产者向缓冲区赋值操作 /* begin *******************程序代码约六行******************************* */ sem_wait(&amp;sem_empty);//empty-- sem_wait(&amp;sem_mutex); //枷锁 buffer[pIndex]=i; //缓冲区只有三个位置 pIndex=(pIndex+1)%3;// 11-- 0 12--1 13--2 14--0 15--1 16--2 sem_post(&amp;sem_mutex);//解锁 sem_post(&amp;sem_full);//full++ /* end ************************************************************** */ &#125; return NULL;&#125;void * consumer(void *arg)&#123; int i,cIndex=0; for(i=11;i&lt;21;i++) &#123; //请在begin end语句间补全程序语句实现扫描算法，算出总访问磁道数存入totaltracks变量 /* begin *******************程序代码约六行******************************* */ sem_wait(&amp;sem_full);//full-- sem_wait(&amp;sem_mutex);//枷锁 printf(&quot;%d,&quot;,buffer[cIndex]); cIndex=(cIndex+1)%3;//与上面对应 sem_post(&amp;sem_mutex);//解锁 sem_post(&amp;sem_empty);//empty++ /* end ************************************************************** */ &#125; return NULL;&#125; 参考Linux下c++的东西 https://man7.org/linux/man-pages/man3/sem_wait.3.html 123sem_wait是一个函数，也是一个原子操作，它的作用是从信号量的值减去一个“1”，但它永远会先等待该信号量为一个非零值才开始做减法。也就是说，如果你对一个值为2的信号量调用sem_wait()，线程将会继续执行，将信号量的值将减到1。如果对一个值为0的信号量调用sem_wait()，这个函数就会原地等待直到有其它线程增加了这个值使它不再是0为止。如果有两个线程都在sem_wait()中等待同一个信号量变成非零值，那么当它被第三个线程增加 一个“1”时，等待线程中只有一个能够对信号量做减法并继续执行，另一个还将处于等待状态。sem_trywait(sem_t *sem)是函数sem_wait的非阻塞版，它直接将信号量sem减1，同时返回错误代码。(不得不说，百度确实蛮会复制粘贴翻译的，只不过没有那个网站格式做的好hhh) 1sem_post是给信号量的值加上一个“1”，它是一个“原子操作”－－－即同时对同一个信号量做加“1”操作的两个线程是不会冲突的；而同 时对同一个文件进行读和写操作的两个程序就有可能会引起冲突。 1sem_t C语言中，信号量的数据类型为结构sem_t，它本质上是一个长整型的数。 https://blog.51cto.com/u_13999641/4314815 没看完【argc，argv是什么】 真的忘的差不多了0.0","categories":[{"name":"2023","slug":"2023","permalink":"http://example.com/categories/2023/"}],"tags":[{"name":"操作系统","slug":"操作系统","permalink":"http://example.com/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"}]},{"title":"java数据类型","slug":"java数据类型","date":"2023-03-16T14:06:57.039Z","updated":"2023-03-20T07:57:15.646Z","comments":true,"path":"2023/03/16/java数据类型/","link":"","permalink":"http://example.com/2023/03/16/java%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/","excerpt":"","text":"Java数据类型定义Java语言是强类型语言，对于每一种数据都定义了明确的具体的数据类型，在内存中分配了不同大小的内存空间。 分类 基本数据类型 数值型 整数类型(byte,short,int,long) 浮点类型(float,double) 字符型(char) 布尔型(boolean) 引用数据类型 类(class) 接口(interface) 数组([]) 计算机存储单元 定义：变量是内存中的小容器，用来存储数据。那么计算机内存是怎么存储数据的呢？无论是内存还是硬盘，计算机存储设备的最小信息单元叫“位（bit）”，我们又称之为“比特位”，通常用小写的字母b表示。而计算机最小的存储单元叫“字节（byte）”，通常用大写字母B表示，字节是由连续的8个位组成。 常用存储单元关系 1B&#x3D; 8b1KB &#x3D; 1024B1MB &#x3D; 1024KB1GB &#x3D; 1024MB1TB &#x3D; 1024GB Java基本数据类型图 定义 数据类型的转换是在所赋值的数值类型和被变量接收的数据类型不一致时发生的，它需要从一种数据类型转换成另一种数据类型。 分类 隐式转换 定义 在运算过程中，由于不同的数据类型会转换成同一种数据类型，所以整型、浮点型以及字符型都可以参与混合运算。自动转换的规则是从低级类型数据转换成高级类型数据。 转换规则 数值型数据的转换：byte→short→int→long→float→double。 字符型转换为整型：char→int。 转换条件 自动类型转换的实现需要同时满足两个条件：①两种数据类型彼此兼容，②目标类型的取值范围大于源数据类型（低级类型数据转换成高级类型数据）。例如 byte 类型向 short 类型转换时，由于 short 类型的取值范围较大，会自动将 byte 转换为 short 类型。 显式转换 定义 当两种数据类型不兼容，或目标类型的取值范围小于源类型时，自动转换将无法进行，这时就需要进行强制类型转换。 语法格式 目标类型 变量名 &#x3D; (目标类型) (被转换的数据);举例：int b &#x3D; (byte)(a + b); 注意 如果超出了被赋值的数据类型的取值范围得到的结果会与你期望的结果不同 不建议强制转换，因为会有精度的损失。","categories":[{"name":"2023","slug":"2023","permalink":"http://example.com/categories/2023/"}],"tags":[{"name":"java","slug":"java","permalink":"http://example.com/tags/java/"}]},{"title":"3-15-2023","slug":"3-15-2023","date":"2023-03-15T14:51:14.942Z","updated":"2023-03-15T14:59:29.047Z","comments":true,"path":"2023/03/15/3-15-2023/","link":"","permalink":"http://example.com/2023/03/15/3-15-2023/","excerpt":"三月中自我崩溃","text":"三月中自我崩溃 1.每日单词 考试周，复习无进展，极度自我焦虑, 看的上海的学校今年分数下来了， 崩溃，高了40分，崩溃,换学校， 觉得三年青春换水硕不值 转战留学","categories":[{"name":"2023","slug":"2023","permalink":"http://example.com/categories/2023/"}],"tags":[{"name":"casual_talk","slug":"casual-talk","permalink":"http://example.com/tags/casual-talk/"}]},{"title":"设计模式homework(1)","slug":"设计模式homework(1)","date":"2023-03-15T09:56:02.491Z","updated":"2023-03-20T07:53:52.155Z","comments":true,"path":"2023/03/15/设计模式homework(1)/","link":"","permalink":"http://example.com/2023/03/15/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8Fhomework(1)/","excerpt":"","text":"2023_Week1_Exp_Upload1. (简答题)用 UMLet 工具对下面代码绘制类图 【关联关系】：是一种拥有的关系，它使一个类知道另一个类的属性和方法 【代码体现】：成员变量 【箭头及指向】：带普通箭头的实心线，指向被拥有者 1.上图中，课程与学生是双向关联，课程有多名学生，学生也可能有多个课程。 2.但学生与成绩间的关系为单向关联，一名学生可能要有多门成绩，成绩有学生信息，但学生类不拥有成绩变量 3.【组合关系】：是整体与部分的关系，但部分不能离开整体而单独存在。如公司和部门是整体和部分的关系，没有公司就不存在部门。 组合关系是关联关系的一种，是比聚合关系还要强的关系，它要求普通的聚合关系中代表整体的对象负责代表部分的对象的生命周期。 【代码体现】：成员变量 【箭头及指向】：带实心菱形的实线，菱形指向整体 上图中课程为整体，成绩没有课程就不存在。 4.【依赖关系】：是一种使用的关系，即一个类的实现需要另一个类的协助，所以要尽量不使用双向的互相依赖. 【代码表现】：局部变量、方法的参数或者对静态方法的调用 【箭头及指向】：带箭头的虚线，指向被使用者 一个宿舍类的实现需要另一个学生类的协助，宿舍是被使用者","categories":[{"name":"2023","slug":"2023","permalink":"http://example.com/categories/2023/"}],"tags":[{"name":"设计模式","slug":"设计模式","permalink":"http://example.com/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"}]},{"title":"UML&&面向对象设计原则","slug":"UML类图&&原则概述","date":"2023-03-15T09:32:42.087Z","updated":"2023-03-15T09:33:49.550Z","comments":true,"path":"2023/03/15/UML类图&&原则概述/","link":"","permalink":"http://example.com/2023/03/15/UML%E7%B1%BB%E5%9B%BE&&%E5%8E%9F%E5%88%99%E6%A6%82%E8%BF%B0/","excerpt":"","text":"一、单一职责原则**就一个类而言，应该仅有一个引起它变化的原因。 如果一个类承担的职责过多，就等于把这些职责耦合在一起，一个职责的变化可能会削弱或者抑制这个类完成其他职责的能力。这种耦合会导致脆弱他的设计，当变化发生时，设计会遭受到意想不到的破坏；软件设计真正要做的许多内容就是发现职责并把那些职责相互分离。 二、开放-封闭原则软件实体应该可以扩展，但不可修改。该原则是面向对象设计的核心所在，遵循这个原则可以带来面向对象技术所声称的可维护、可扩展、可复用、灵活性好。 设计人员必须对于他设计的模块应该对哪种变化封闭做出选择，必须先猜测出最有可能发生的变化种类，然后构造抽象来隔离那些变化。最初编写程序时假设变化不会发生，当变化发生时，就创建抽象来隔离以后发生的同类变化，拒绝不成熟的抽象。 三、里氏代换原则子类型必须能够替换掉它们的父类型。由于子类型的可替换性才使得使用父类类型的模块在无需修改的情况下就可以扩展。 四、依赖倒转原则高层模块不应该依赖低层模块，两个都应该依赖抽象；抽象不应该依赖细节，细节应该依赖抽象。 要针对接口编程，不要针对实现编程。该原则可以说是面向对象设计的标志，编写时考虑的是如何对抽象编程而不是针对细节编程，即程序中所有的依赖关系都是终止于抽象类或者接口。 五、迪迷特原则（最少知识原则）如果两个类不必彼此直接通信，那么这两个类就不应当发生直接的相互作用；如果其中一个类需要调用另一个类的某一个方法的话，可以通过第三者转发这个调用。 该原则其根本思想，是强调了类之间的松耦合；类之间的耦合越弱，越利于复用，一个处在弱耦合的类被修改，不会对有关系的类造成波及。在类的结构设计上，每一个类都应当尽量降低成员的访问权限。 六、合成&#x2F;聚合复用原则尽量使用合成&#x2F;聚合，尽量不要使用类继承。 聚合表示一种弱的“拥有”关系，体现的是A对象可以包含B对象，但B对象不是A对象的一部分；合成则是一种强的“拥有”关系，体现了严格的部分和整体的关系，部分和整体的生命周期一样。 优先使用对象的合成&#x2F;聚合将有助于你保持每个类被封装，并被击中在单个任务上，这样类和类继承层次会保持较小规模，并且不太可能增长为不可控制的庞然大物。 七、UML例图‘+’表示public，‘-’表示private，‘#’表示protected； 接口顶端有《interface》显示，只有两行；同时另一个表示方法为棒棒糖表示法； 聚合表示一种弱的’拥有’关系，体现的是A对象可以包含B对象，但B对象不是A对象的一部分； 合成是一种强的’拥有’关系，体现了严格的部分和整体的关系，部分和整体的生命周期一样； 在UML类图中，常见的有以下几种关系: 泛化（Generalization）, 实现（Realization），关联（Association)，聚合（Aggregation），组合(Composition)，依赖(Dependency) 1. 泛化（Generalization）【泛化关系】：是一种继承关系，表示一般与特殊的关系，它指定了子类如何特化父类的所有特征和行为。例如：老虎是动物的一种，即有老虎的特性也有动物的共性。 【箭头指向】：带三角箭头的实线，箭头指向父类 2. 实现（Realization）【实现关系】：是一种类与接口的关系，表示类是接口所有特征和行为的实现. 【箭头指向】：带三角箭头的虚线，箭头指向接口 3. 关联（Association)【关联关系】：是一种拥有的关系，它使一个类知道另一个类的属性和方法；如：老师与学生，丈夫与妻子关联可以是双向的，也可以是单向的。双向的关联可以有两个箭头或者没有箭头，单向的关联有一个箭头。 【代码体现】：成员变量 【箭头及指向】：带普通箭头的实心线，指向被拥有者 上图中，老师与学生是双向关联，老师有多名学生，学生也可能有多名老师。但学生与某课程间的关系为单向关联，一名学生可能要上多门课程，课程是个抽象的东西他不拥有学生。 下图为自身关联： 4. 聚合（Aggregation）【聚合关系】：是整体与部分的关系，且部分可以离开整体而单独存在。如车和轮胎是整体和部分的关系，轮胎离开车仍然可以存在。 聚合关系是关联关系的一种，是强的关联关系；关联和聚合在语法上无法区分，必须考察具体的逻辑关系。 【代码体现】：成员变量 【箭头及指向】：带空心菱形的实心线，菱形指向整体 5. 组合(Composition)【组合关系】：是整体与部分的关系，但部分不能离开整体而单独存在。如公司和部门是整体和部分的关系，没有公司就不存在部门。 组合关系是关联关系的一种，是比聚合关系还要强的关系，它要求普通的聚合关系中代表整体的对象负责代表部分的对象的生命周期。 【代码体现】：成员变量 【箭头及指向】：带实心菱形的实线，菱形指向整体 6. 依赖(Dependency)【依赖关系】：是一种使用的关系，即一个类的实现需要另一个类的协助，所以要尽量不使用双向的互相依赖. 【代码表现】：局部变量、方法的参数或者对静态方法的调用 【箭头及指向】：带箭头的虚线，指向被使用者 各种关系的强弱顺序： 泛化 &#x3D; 实现 &gt; 组合 &gt; 聚合 &gt; 关联 &gt; 依赖 下面这张UML图，比较形象地展示了各种类图关系： 创建型1. Factory Method（工厂方法） 意图： 定义一个用于创建对象的接口，让子类决定实例化哪一个类。Factory Method 使一个类的实例化延迟到其子类。 适用性： 当一个类不知道它所必须创建的对象的类的时候。 当一个类希望由它的子类来指定它所创建的对象的时候。 当类将创建对象的职责委托给多个帮助子类中的某一个，并且你希望将哪一个帮助子类是代理者这一信息局部化的时候。 详解：设计模式是什么鬼（工厂方法） 2. Abstract Factory（抽象工厂） 意图： 提供一个创建一系列相关或相互依赖对象的接口，而无需指定它们具体的类。 适用性： 一个系统要独立于它的产品的创建、组合和表示时。 一个系统要由多个产品系列中的一个来配置时。 当你要强调一系列相关的产品对象的设计以便进行联合使用时。 当你提供一个产品类库，而只想显示它们的接口而不是实现时。 详解：设计模式是什么鬼（抽象工厂） 3. Builder（建造者） 意图： 将一个复杂对象的构建与它的表示分离，使得同样的构建过程可以创建不同的表示。 适用性： 当创建复杂对象的算法应该独立于该对象的组成部分以及它们的装配方式时。 当构造过程必须允许被构造的对象有不同的表示时。 详解：设计模式是什么鬼（建造者） 4. Prototype（原型） 意图： 用原型实例指定创建对象的种类，并且通过拷贝这些原型创建新的对象。 适用性： 当要实例化的类是在运行时刻指定时，例如，通过动态装载；或者 为了避免创建一个与产品类层次平行的工厂类层次时；或者 当一个类的实例只能有几个不同状态组合中的一种时。建立相应数目的原型并克隆它们可能比每次用合适的状态手工实例化该类更方便一些。 详解：设计模式是什么鬼（原型） 5. Singleton（单例） 意图： 保证一个类仅有一个实例，并提供一个访问它的全局访问点。 适用性： 当类只能有一个实例而且客户可以从一个众所周知的访问点访问它时。 当这个唯一实例应该是通过子类化可扩展的，并且客户应该无需更改代码就能使用一个扩展的实例时。 详解：设计模式是什么鬼（单例） 结构型6. Adapter Class&#x2F;Object（适配器） 意图： 将一个类的接口转换成客户希望的另外一个接口。Adapter 模式使得原本由于接口不兼容而不能一起工作的那些类可以一起工作。 适用性： 你想使用一个已经存在的类，而它的接口不符合你的需求。 你想创建一个可以复用的类，该类可以与其他不相关的类或不可预见的类（即那些接口可能不一定兼容的类）协同工作。 （仅适用于对象Adapter ）你想使用一些已经存在的子类，但是不可能对每一个都进行子类化以匹配它们的接口。对象适配器可以适配它的父类接口。 详解：设计模式是什么鬼（适配器） 7. Bridge（桥接） 意图： 将抽象部分与它的实现部分分离，使它们都可以独立地变化。 适用性： 你不希望在抽象和它的实现部分之间有一个固定的绑定关系。例如这种情况可能是因为，在程序运行时刻实现部分应可以被选择或者切换。 类的抽象以及它的实现都应该可以通过生成子类的方法加以扩充。这时Bridge 模式使你可以对不同的抽象接口和实现部分进行组合，并分别对它们进行扩充。 对一个抽象的实现部分的修改应对客户不产生影响，即客户的代码不必重新编译。 （C++）你想对客户完全隐藏抽象的实现部分。在C++中，类的表示在类接口中是可见的。 有许多类要生成。这样一种类层次结构说明你必须将一个对象分解成两个部分。Rumbaugh 称这种类层次结构为“嵌套的普化”（nested generalizations ）。 你想在多个对象间共享实现（可能使用引用计数），但同时要求客户并不知道这一点。一个简单的例子便是Coplien 的String 类[ Cop92 ]，在这个类中多个对象可以共享同一个字符串表示（StringRep ）。 详解：设计模式是什么鬼（桥接） 8. Composite（组合） 意图： 将对象组合成树形结构以表示“部分-整体”的层次结构。C o m p o s i t e 使得用户对单个对象和组合对象的使用具有一致性。 适用性： 你想表示对象的部分-整体层次结构。 你希望用户忽略组合对象与单个对象的不同，用户将统一地使用组合结构中的所有对象。 详解：设计模式是什么鬼（组合） 9. Decorator（装饰） 意图： 动态地给一个对象添加一些额外的职责。就增加功能来说，Decorator 模式相比生成子类更为灵活。 适用性： 在不影响其他对象的情况下，以动态、透明的方式给单个对象添加职责。 处理那些可以撤消的职责。 当不能采用生成子类的方法进行扩充时。一种情况是，可能有大量独立的扩展，为支持每一种组合将产生大量的子类，使得子类数目呈爆炸性增长。另一种情况可能是因为类定义被隐藏，或类定义不能用于生成子类。 详解：设计模式是什么鬼（装饰） 10. Facade（外观） 意图： 为子系统中的一组接口提供一个一致的界面，Facade模式定义了一个高层接口，这个接口使得这一子系统更加容易使用。 适用性： 当你要为一个复杂子系统提供一个简单接口时。子系统往往因为不断演化而变得越来越复杂。大多数模式使用时都会产生更多更小的类。这使得子系统更具可重用性，也更容易对子系统进行定制，但这也给那些不需要定制子系统的用户带来一些使用上的困难。Facade 可以提供一个简单的缺省视图，这一视图对大多数用户来说已经足够，而那些需要更多的可定制性的用户可以越过facade层。 客户程序与抽象类的实现部分之间存在着很大的依赖性。引入facade 将这个子系统与客户以及其他的子系统分离，可以提高子系统的独立性和可移植性。 当你需要构建一个层次结构的子系统时，使用facade模式定义子系统中每层的入口点。如果子系统之间是相互依赖的，你可以让它们仅通过facade进行通讯，从而简化了它们之间的依赖关系。 详解：设计模式是什么鬼（门面） 11. Flyweight（享元） 意图： 运用共享技术有效地支持大量细粒度的对象。 适用性： 一个应用程序使用了大量的对象。 完全由于使用大量的对象，造成很大的存储开销。 对象的大多数状态都可变为外部状态。 如果删除对象的外部状态，那么可以用相对较少的共享对象取代很多组对象。 应用程序不依赖于对象标识。由于Flyweight 对象可以被共享，对于概念上明显有别的对象，标识测试将返回真值。 详解：设计模式是什么鬼（享元） 12. Proxy（代理） 意图： 为其他对象提供一种代理以控制对这个对象的访问。 适用性： 在需要用比较通用和复杂的对象指针代替简单的指针的时候，使用Proxy模式。下面是一 些可以使用Proxy 模式常见情况： 远程代理（Remote Proxy ）为一个对象在不同的地址空间提供局部代表。NEXTSTEP[Add94] 使用NXProxy 类实现了这一目的。Coplien[Cop92] 称这种代理为“大使” （Ambassador ）。 虚代理（Virtual Proxy ）根据需要创建开销很大的对象。在动机一节描述的ImageProxy 就是这样一种代理的例子。 保护代理（Protection Proxy ）控制对原始对象的访问。保护代理用于对象应该有不同 的访问权限的时候。例如，在Choices 操作系统[ CIRM93]中KemelProxies为操作系统对象提供 了访问保护。 智能指引（Smart Reference ）取代了简单的指针，它在访问对象时执行一些附加操作。它的典型用途包括： 对指向实际对象的引用计数，这样当该对象没有引用时，可以自动释放它(也称为SmartPointers[Ede92 ] )。 当第一次引用一个持久对象时，将它装入内存。 在访问一个实际对象前，检查是否已经锁定了它，以确保其他对象不能改变它。 详解：设计模式是什么鬼（代理） 行为型13. Interpreter（解释器） 意图： 给定一个语言，定义它的文法的一种表示，并定义一个解释器，这个解释器使用该表示来解释语言中的句子。 适用性： 当有一个语言需要解释执行, 并且你可将该语言中的句子表示为一个抽象语法树时，可使用解释器模式。而当存在以下情况时该模式效果最好： 该文法简单对于复杂的文法, 文法的类层次变得庞大而无法管理。此时语法分析程序生成器这样的工具是更好的选择。它们无需构建抽象语法树即可解释表达式, 这样可以节省空间而且还可能节省时间。 效率不是一个关键问题最高效的解释器通常不是通过直接解释语法分析树实现的, 而是首先将它们转换成另一种形式。例如，正则表达式通常被转换成状态机。但即使在这种情况下, 转换器仍可用解释器模式实现, 该模式仍是有用的。 详解：设计模式是什么鬼（解释器） 14. Template Method（模板方法） 意图： 定义一个操作中的算法的骨架，而将一些步骤延迟到子类中。TemplateMethod 使得子类可以不改变一个算法的结构即可重定义该算法的某些特定步骤。 适用性： 一次性实现一个算法的不变的部分，并将可变的行为留给子类来实现。 各子类中公共的行为应被提取出来并集中到一个公共父类中以避免代码重复。这是Opdyke 和Johnson 所描述过的“重分解以一般化”的一个很好的例子[ OJ93 ]。首先识别现有代码中的不同之处，并且将不同之处分离为新的操作。最后，用一个调用这些新的操作的模板方法来替换这些不同的代码。 控制子类扩展。模板方法只在特定点调用“hook ”操作（参见效果一节），这样就只允许在这些点进行扩展。 详解：设计模式是什么鬼（模板方法） 15. Chain of Responsibility（责任链） 意图： 使多个对象都有机会处理请求，从而避免请求的发送者和接收者之间的耦合关系。将这些对象连成一条链，并沿着这条链传递该请求，直到有一个对象处理它为止。 适用性： 有多个的对象可以处理一个请求，哪个对象处理该请求运行时刻自动确定。 你想在不明确指定接收者的情况下，向多个对象中的一个提交一个请求。 可处理一个请求的对象集合应被动态指定。 详解：设计模式是什么鬼（责任链） 16. Command（命令） 意图： 将一个请求封装为一个对象，从而使你可用不同的请求对客户进行参数化；对请求排队或记录请求日志，以及支持可撤消的操作。 适用性： 抽象出待执行的动作以参数化某对象，你可用过程语言中的回调（call back）函数表达这种参数化机制。所谓回调函数是指函数先在某处注册，而它将在稍后某个需要的时候被调用。Command 模式是回调机制的一个面向对象的替代品。 在不同的时刻指定、排列和执行请求。一个Command对象可以有一个与初始请求无关的生存期。如果一个请求的接收者可用一种与地址空间无关的方式表达，那么就可将负责该请求的命令对象传送给另一个不同的进程并在那儿实现该请求。 支持取消操作。Command的Excute 操作可在实施操作前将状态存储起来，在取消操作时这个状态用来消除该操作的影响。Command 接口必须添加一个Unexecute操作，该操作取消上一次Execute调用的效果。执行的命令被存储在一个历史列表中。可通过向后和向前遍历这一列表并分别调用Unexecute和Execute来实现重数不限的“取消”和“重做”。 支持修改日志，这样当系统崩溃时，这些修改可以被重做一遍。在Command接口中添加装载操作和存储操作，可以用来保持变动的一个一致的修改日志。从崩溃中恢复的过程包括从磁盘中重新读入记录下来的命令并用Execute操作重新执行它们。 用构建在原语操作上的高层操作构造一个系统。这样一种结构在支持事务( transaction)的信息系统中很常见。一个事务封装了对数据的一组变动。Command模式提供了对事务进行建模的方法。Command有一个公共的接口，使得你可以用同一种方式调用所有的事务。同时使用该模式也易于添加新事务以扩展系统。 详解：设计模式是什么鬼（命令模式） 17. Iterator（迭代器） 意图： 提供一种方法顺序访问一个聚合对象中各个元素, 而又不需暴露该对象的内部表示。 适用性： 访问一个聚合对象的内容而无需暴露它的内部表示。 支持对聚合对象的多种遍历。 为遍历不同的聚合结构提供一个统一的接口(即, 支持多态迭代)。 详解：设计模式是什么鬼（迭代器） 18. Mediator（中介者） 意图： 用一个中介对象来封装一系列的对象交互。中介者使各对象不需要显式地相互引用，从而使其耦合松散，而且可以独立地改变它们之间的交互。 适用性： 一组对象以定义良好但是复杂的方式进行通信。产生的相互依赖关系结构混乱且难以理解。 一个对象引用其他很多对象并且直接与这些对象通信,导致难以复用该对象。 想定制一个分布在多个类中的行为，而又不想生成太多的子类。 详解：设计模式是什么鬼（中介） 19. Memento（备忘录） 意图： 在不破坏封装性的前提下，捕获一个对象的内部状态，并在该对象之外保存这个状态。这样以后就可将该对象恢复到原先保存的状态。 适用性： 必须保存一个对象在某一个时刻的(部分)状态, 这样以后需要时它才能恢复到先前的状态。 如果一个用接口来让其它对象直接得到这些状态，将会暴露对象的实现细节并破坏对象的封装性。 详解：设计模式是什么鬼（备忘录） 20. Observer（观察者） 意图： 定义对象间的一种一对多的依赖关系,当一个对象的状态发生改变时, 所有依赖于它的对象都得到通知并被自动更新。 适用性： 当一个抽象模型有两个方面, 其中一个方面依赖于另一方面。将这二者封装在独立的对象中以使它们可以各自独立地改变和复用。 当对一个对象的改变需要同时改变其它对象, 而不知道具体有多少对象有待改变。 当一个对象必须通知其它对象，而它又不能假定其它对象是谁。换言之, 你不希望这些对象是紧密耦合的。 详解：设计模式是什么鬼（观察者） 21. State（状态） 意图： 允许一个对象在其内部状态改变时改变它的行为。对象看起来似乎修改了它的类。 适用性： 一个对象的行为取决于它的状态, 并且它必须在运行时刻根据状态改变它的行为。 一个操作中含有庞大的多分支的条件语句，且这些分支依赖于该对象的状态。这个状态通常用一个或多个枚举常量表示。通常, 有多个操作包含这一相同的条件结构。State模式将每一个条件分支放入一个独立的类中。这使得你可以根据对象自身的情况将对象的状态作为一个对象，这一对象可以不依赖于其他对象而独立变化。 详解：设计模式是什么鬼（状态） 22. Strategy（策略） 意图： 定义一系列的算法,把它们一个个封装起来, 并且使它们可相互替换。本模式使得算法可独立于使用它的客户而变化。 适用性： 许多相关的类仅仅是行为有异。“策略”提供了一种用多个行为中的一个行为来配置一个类的方法。 需要使用一个算法的不同变体。例如，你可能会定义一些反映不同的空间&#x2F;时间权衡的算法。当这些变体实现为一个算法的类层次时[H087] ,可以使用策略模式。 算法使用客户不应该知道的数据。可使用策略模式以避免暴露复杂的、与算法相关的数据结构。 一个类定义了多种行为, 并且这些行为在这个类的操作中以多个条件语句的形式出现。将相关的条件分支移入它们各自的Strategy类中以代替这些条件语句。 详解：设计模式是什么鬼（策略） 23. Visitor（访问者） 意图： 定义一个操作中的算法的骨架，而将一些步骤延迟到子类中。TemplateMethod 使得子类可以不改变一个算法的结构即可重定义该算法的某些特定步骤。 适用性： 一次性实现一个算法的不变的部分，并将可变的行为留给子类来实现。 各子类中公共的行为应被提取出来并集中到一个公共父类中以避免代码重复。这是Opdyke和Johnson所描述过的“重分解以一般化”的一个很好的例子[OJ93]。首先识别现有代码中的不同之处，并且将不同之处分离为新的操作。最后，用一个调用这些新的操作的模板方法来替换这些不同的代码。 控制子类扩展。模板方法只在特定点调用“hook ”操作（参见效果一节），这样就只允许在这些点进行扩展。 详解：设计模式是什么鬼（访问者） 1来源：blog.csdn.net/zsjlovesm521/article/details/94382666","categories":[{"name":"2023","slug":"2023","permalink":"http://example.com/categories/2023/"}],"tags":[{"name":"设计模式","slug":"设计模式","permalink":"http://example.com/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"}]},{"title":"软件体系结构","slug":"软件体系结构","date":"2023-03-15T09:24:47.975Z","updated":"2023-03-15T10:50:24.862Z","comments":true,"path":"2023/03/15/软件体系结构/","link":"","permalink":"http://example.com/2023/03/15/%E8%BD%AF%E4%BB%B6%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84/","excerpt":"","text":"软件体系结构​ 软件体系结构是有关软件系统如何组织的描述。体系结构影响了系统的性能、安全性和可用性。软件工程师可以在给定的体系结构类型中使用不同的体系结构风格和模式，而不同的模式描述了不同的系统类别、构建、连接件及约束。 ​ 软件体系结构脱胎于软件工程．但其形成同时借鉴了计算机体系结构和网络体系结构中很多宝贵的思想和方法。最近几年软件体系结构研究完全独立于软件工程的研究，成为计算机科学的一个最新的研究方向和独立学科分支。 软件体系结构是对系统的高层设计，是从一个较高的层次来考虑组成系统的构建、构建之间的连接关系，以及系统需满足的约束等。设计模式可以用于软件体系结构的设计，以实现体系结构级的设计复用。用于软件体系结构的设计模式通常称为架构模式（Architectural Pattern）或体系机构风格（Architectural Style）。 在《Pattern - Oriented Software Architecture》第一卷中，Buschmann等人根据问题的规模或抽象层次将软件设计模式分为三个层次：架构模式（Architectural Patterns）、设计模式（Design Patterns）和习惯用法（Idioms）。 （1）架构模式 架构模式是一种高层模式，用于描述系统级的结构组成、相互关系及相关约束。对架构模式的选择是最基本的设计决策，将决定系统的基本架构，并决定后续的设计及开发活动。 例如，模型 - 视图 - 控制器（Model - View - Controller，MVC）即是一种架构模式，该模式给出了一种交互式系统的架构设计，该模式的主要思想式实现业务逻辑、用户界面的分离。 （2）设计模式 设计模式是中层模式，是针对系统局部设计问题给出的解决方案。一般情况下，人们所讲的设计模式都是指中层模式。设计模式的选择对系统的基本架构没有影响，但在实现架构模式时，则可能采用多种设计模式。 例如，在实现MVC架构模式时，采用的主要设计模式有观察者模式、组合模式和策略模式等。 （3）习惯用法 架构模式和设计模式被认为是与具体编程语言无关的，而习惯用法则通常被认为是与具体编程语言相关的一种低层模式。习惯用法给出的解决方案通常与具体编程语言的某种语法机制相关。 本课程中，软件体系结构就是指架构模式，可以认为是：软件体系结构 &#x3D; 构件 + 连接件 + 约束 。 构件 构件是具有某种功能的可复用的软件结构单元，表示系统中主要的计算元素 和 数据存储。 构件是一个抽象的概念，在程序中可以指程序函数、模块、对象、类等。 连接件 连接是构件间建立和维护行为关联与信息传递的途径。连接包含下面两种要素： 其中，机制指的实际中的消息传递方式。 而协议则决定了 消息的语义理解。 连接件表示构件之间的交互并实现构件之间的连接。 软件体系结构目标为了更好理解后面的软件体系结构涉及的原则和体系结构风格，请牢记这些目标，时不时的对照后面的内容回顾这些目标。 所有的设计原则等理论基本上都可以映射到下面一个或几个目标上。 体系结构的发展现在软件的复杂性及多变性，导致了软件粒度越来越粗，越来越开放。 下面是常见的软件体系结构 软件体系结构与软件设计模式的区别","categories":[{"name":"2023","slug":"2023","permalink":"http://example.com/categories/2023/"}],"tags":[{"name":"设计模式","slug":"设计模式","permalink":"http://example.com/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"}]},{"title":"设计模式概述","slug":"设计模式(1)","date":"2023-03-15T09:18:35.137Z","updated":"2023-03-20T13:02:46.547Z","comments":true,"path":"2023/03/15/设计模式(1)/","link":"","permalink":"http://example.com/2023/03/15/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F(1)/","excerpt":"","text":"设计模式概述（1）1.1 软件设计模式的产生背景“设计模式”最初并不是出现在软件设计中，而是被用于建筑领域的设计中。 1977年美国著名建筑大师、加利福尼亚大学伯克利分校环境结构中心主任克里斯托夫·亚历山大（Christopher Alexander）在他的著作《建筑模式语言：城镇、建筑、构造》（A Pattern Language: Towns Building Construction）中描述了一些常见的建筑设计问题，并提出了 253 种关于对城镇、邻里、住宅、花园和房间等进行设计的基本模式。 1979 年他的另一部经典著作《建筑的永恒之道》（The Timeless Way of Building）进一步强化了设计模式的思想，为后来的建筑设计指明了方向。 1987 年，肯特·贝克（Kent Beck）和沃德·坎宁安（Ward Cunningham）首先将克里斯托夫·亚历山大的模式思想应用在 Smalltalk 中的图形用户接口的生成中，但没有引起软件界的关注。 1990年软件工程界开始研讨设计模式的话题，后来召开了多次关于设计模式的研讨会。直到1995 年，艾瑞克·伽马（ErichGamma）、理査德·海尔姆（Richard Helm）、拉尔夫·约翰森（Ralph Johnson）、约翰·威利斯迪斯（John Vlissides）等 4 位作者合作出版了《设计模式：可复用面向对象软件的基础》一书，在此书中收录了 23 个设计模式，这是设计模式领域里程碑的事件，导致了软件设计模式的突破。这 4 位作者在软件开发领域里也以他们的“四人组”（Gang of Four，GoF）著称。 1.2 软件设计模式的概念软件设计模式（Software Design Pattern），又称设计模式，“解决如下的在特定的环境中反复出现的设计问题，并且为其提供了解决方案”(Buschmann, et. al. 1996)，是一套被反复使用、多数人知晓的、经过分类编目的、代码设计经验的总结。它描述了在软件设计过程中的一些不断重复发生的问题，以及该问题的解决方案。也就是说，它是解决特定问题的一系列套路，是前辈们的代码设计经验的总结，具有一定的普遍性，可以反复使用。 1.3 学习设计模式的必要性设计模式的本质是面向对象设计原则的实际运用，是对类的封装性、继承性和多态性以及类的关联关系和组合关系的充分理解。 正确使用设计模式具有以下优点。 可以提高程序员的思维能力、编程能力和设计能力。 使程序设计更加标准化、代码编制更加工程化，使软件开发效率大大提高，从而缩短软件的开发周期。 使设计的代码可重用性高、可读性强、可靠性高、灵活性好、可维护性强。 成为优秀的软件工程师。 当然，软件设计模式只是一个引导。在具体的软件幵发中，必须根据设计的应用系统的特点和要求来恰当选择。对于简单的程序开发，苛能写一个简单的算法要比引入某种设计模式更加容易。但对大项目的开发或者框架设计，用设计模式来组织代码显然更好。 1.4 软件设计模式的基本要素软件设计模式使人们可以更加简单方便地复用成功的设计和体系结构，它通常包含以下几个基本要素：模式名称、别名、动机、问题、解决方案、效果、结构、模式角色、合作关系、实现方法、适用性、已知应用、例程、模式扩展和相关模式等，其中最关键的元素包括以下 4 个主要部分。 模式名称 每一个模式都有自己的名字，通常用一两个词来描述，可以根据模式的问题、特点、解决方案、功能和效果来命名。模式名称（PatternName）有助于我们理解和记忆该模式，也方便我们来讨论自己的设计。 问题 问题（Problem）描述了该模式的应用环境，即何时使用该模式。它解释了设计问题和问题存在的前因后果，以及必须满足的一系列先决条件。 解决方案 模式问题的解决方案（Solution）包括设计的组成成分、它们之间的相互关系及各自的职责和协作方式。因为模式就像一个模板，可应用于多种不同场合，所以解决方案并不描述一个特定而具体的设计或实现，而是提供设计问题的抽象描述和怎样用一个具有一般意义的元素组合（类或对象的 组合）来解决这个问题。 效果 描述了模式的应用效果以及使用该模式应该权衡的问题，即模式的优缺点。主要是对时间和空间的衡量，以及该模式对系统的灵活性、扩充性、可移植性的影响，也考虑其实现问题。显式地列出这些效果（Consequence）对理解和评价这些模式有很大的帮助。 1.5 根据目的分类 创建型模式 用于描述“怎样创建对象”，它的主要特点是“将对象的创建与使用分离”。GoF（四人组）书中提供了单例、原型、工厂方法、抽象工厂、建造者等 5 种创建型模式。 结构型模式 用于描述如何将类或对象按某种布局组成更大的结构，GoF（四人组）书中提供了代理、适配器、桥接、装饰、外观、享元、组合等 7 种结构型模式。 行为型模式 用于描述类或对象之间怎样相互协作共同完成单个对象无法单独完成的任务，以及怎样分配职责。GoF（四人组）书中提供了模板方法、策略、命令、职责链、状态、观察者、中介者、迭代器、访问者、备忘录、解释器等 11 种行为型模式。 1.6 根据作用范围来分根据模式是主要用于类上还是主要用于对象上来分，这种方式可分为类模式和对象模式两种。 类模式：用于处理类与子类之间的关系，这些关系通过继承来建立，是静态的，在编译时刻便确定下来了。GoF中的工厂方法、（类）适配器、模板方法、解释器属于该模式。 对象模式：用于处理对象之间的关系，这些关系可以通过组合或聚合来实现，在运行时刻是可以变化的，更具动态性。GoF 中除了以上 4 种，其他的都是对象模式。 1.7. GoF的23种设计模式的功能简介前面说明了 GoF 的 23 种设计模式的分类，现在对各个模式的功能进行介绍。 单例（Singleton）模式：某个类只能生成一个实例，该类提供了一个全局访问点供外部获取该实例，其拓展是有限多例模式。 原型（Prototype）模式：将一个对象作为原型，通过对其进行复制而克隆出多个和原型类似的新实例。 工厂方法（Factory Method）模式：定义一个用于创建产品的接口，由子类决定生产什么产品。 抽象工厂（AbstractFactory）模式：提供一个创建产品族的接口，其每个子类可以生产一系列相关的产品。 建造者（Builder）模式：将一个复杂对象分解成多个相对简单的部分，然后根据不同需要分别创建它们，最后构建成该复杂对象。 代理（Proxy）模式：为某对象提供一种代理以控制对该对象的访问。即客户端通过代理间接地访问该对象，从而限制、增强或修改该对象的一些特性。 适配器（Adapter）模式：将一个类的接口转换成客户希望的另外一个接口，使得原本由于接口不兼容而不能一起工作的那些类能一起工作。 桥接（Bridge）模式：将抽象与实现分离，使它们可以独立变化。它是用组合关系代替继承关系来实现，从而降低了抽象和实现这两个可变维度的耦合度。 装饰（Decorator）模式：动态的给对象增加一些职责，即增加其额外的功能。 外观（Facade）模式：为多个复杂的子系统提供一个一致的接口，使这些子系统更加容易被访问。 享元（Flyweight）模式：运用共享技术来有效地支持大量细粒度对象的复用。 组合（Composite）模式：将对象组合成树状层次结构，使用户对单个对象和组合对象具有一致的访问性。 模板方法（TemplateMethod）模式：定义一个操作中的算法骨架，而将算法的一些步骤延迟到子类中，使得子类可以不改变该算法结构的情况下重定义该算法的某些特定步骤。 策略（Strategy）模式：定义了一系列算法，并将每个算法封装起来，使它们可以相互替换，且算法的改变不会影响使用算法的客户。 命令（Command）模式：将一个请求封装为一个对象，使发出请求的责任和执行请求的责任分割开。 职责链（Chain of Responsibility）模式：把请求从链中的一个对象传到下一个对象，直到请求被响应为止。通过这种方式去除对象之间的耦合。 状态（State）模式：允许一个对象在其内部状态发生改变时改变其行为能力。 观察者（Observer）模式：多个对象间存在一对多关系，当一个对象发生改变时，把这种改变通知给其他多个对象，从而影响其他对象的行为。 中介者（Mediator）模式：定义一个中介对象来简化原有对象之间的交互关系，降低系统中对象间的耦合度，使原有对象之间不必相互了解。 迭代器（Iterator）模式：提供一种方法来顺序访问聚合对象中的一系列数据，而不暴露聚合对象的内部表示。 访问者（Visitor）模式：在不改变集合元素的前提下，为一个集合中的每个元素提供多种访问方式，即每个元素有多个访问者对象访问。 备忘录（Memento）模式：在不破坏封装性的前提下，获取并保存一个对象的内部状态，以便以后恢复它。 解释器（Interpreter）模式：提供如何定义语言的文法，以及对语言句子的解释方法，即解释器。 必须指出，这 23 种设计模式不是孤立存在的，很多模式之间存在一定的关联关系，在大的系统开发中常常同时使用多种设计模式。","categories":[{"name":"2023","slug":"2023","permalink":"http://example.com/categories/2023/"}],"tags":[{"name":"设计模式","slug":"设计模式","permalink":"http://example.com/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"}]},{"title":"虚拟机和主机双向复制","slug":"虚拟机和主机双向复制","date":"2023-03-13T16:19:02.512Z","updated":"2023-03-13T17:01:33.362Z","comments":true,"path":"2023/03/14/虚拟机和主机双向复制/","link":"","permalink":"http://example.com/2023/03/14/%E8%99%9A%E6%8B%9F%E6%9C%BA%E5%92%8C%E4%B8%BB%E6%9C%BA%E5%8F%8C%E5%90%91%E5%A4%8D%E5%88%B6/","excerpt":"虚拟机和主机双向复制","text":"虚拟机和主机双向复制 vmware tools黑了 http://www.360doc.com/content/22/1205/19/81029453_1059073619.shtml 试试这个吧 手工安装Vmware tools方法 这种方法是通过Ubuntu的安装命令直接从网上进行安装，打开终端窗口直接执行下列命令即可，安装之前要保证虚拟机可以连接外网，要能连上软件更新服务器，该服务器有可能在国外（根据你自己的设置）。命令如下： 1234sudo apt-get autoremove open-vm-toolssudo apt-get install open-vm-toolssudo apt-get install open-vm-tools-desktop 安装完之后最好重启一下虚拟机。安装完Vmware tools并正确配置后就可以实现主机和虚拟机双向内容复制、粘贴，包括文件的拷贝。","categories":[{"name":"2023","slug":"2023","permalink":"http://example.com/categories/2023/"}],"tags":[{"name":"vmware","slug":"vmware","permalink":"http://example.com/tags/vmware/"}]},{"title":"Spark入门：RDD编程","slug":"sparkRDD编程","date":"2023-03-13T13:47:53.892Z","updated":"2023-03-13T17:00:55.622Z","comments":true,"path":"2023/03/13/sparkRDD编程/","link":"","permalink":"http://example.com/2023/03/13/sparkRDD%E7%BC%96%E7%A8%8B/","excerpt":"Spark入门：RDD编程","text":"Spark入门：RDD编程 RDD创建RDD可以通过两种方式创建： 第一种：读取一个外部数据集。比如，从本地文件加载数据集，或者从HDFS文件系统、HBase、Cassandra、Amazon S3等外部数据源中加载数据集。Spark可以支持文本文件、SequenceFile文件（Hadoop提供的 SequenceFile是一个由二进制序列化过的key&#x2F;value的字节流组成的文本存储文件）和其他符合Hadoop InputFormat格式的文件。 第二种：调用SparkContext的parallelize方法，在Driver中一个已经存在的集合（数组）上创建 在即将进行相关的实践操作之前，我们首先要登录Linux系统（本教程统一采用hadoop用户登录），然后，打开命令行“终端”，请按照下面的命令启动Hadoop中的HDFS组件： 创建RDD之前的准备工作在即将进行相关的实践操作之前，我们首先要登录Linux系统（本教程统一采用hadoop用户登录），然后，打开命令行“终端”，请按照下面的命令启动Hadoop中的HDFS组件： 12cd /usr/local/hadoop./sbin/start-dfs.sh 然后，我们按照下面命令启动spark-shell： 12cd /usr/local/spark./bin/pyspark 然后，新建第二个“终端”，方法是，在前面已经建设的第一个终端窗口的左上方，点击“终端”菜单，在弹出的子菜单中选择“新建终端”，就可以打开第二个终端窗口，现在，我们切换到第二个终端窗口，在第二个终端窗口中，执行以下命令，进入之前已经创建好的“&#x2F;usr&#x2F;local&#x2F;spark&#x2F;mycode&#x2F;”目录，在这个目录下新建rdd子目录，用来存放本章的代码和相关文件： 12cd usr/local/spark/mycode/mkdir rdd 然后，使用vim编辑器，在rdd目录下新建一个word.txt文件，你可以在文件里面随便输入几行英文语句用来测试。 经过上面的准备工作以后，我们就可以开始创建RDD了。 从文件系统中加载数据创建RDDSpark采用textFile()方法来从文件系统中加载数据创建RDD，该方法把文件的URI作为参数，这个URI可以是本地文件系统的地址，或者是分布式文件系统HDFS的地址，或者是Amazon S3的地址等等。下面请切换回spark-shell窗口，看一下如何从本地文件系统中加载数据： 12&gt;&gt;&gt;lines = sc.textFile(&quot;file:///usr/local/spark/mycode/rdd/word.txt&quot;) 1&gt;&gt;&gt;lines.foreach(print) 加载HDFS中的文件为了能够读取HDFS中的文件，请首先启动Hadoop中的HDFS组件。注意，之前我们在“Spark安装”这章内容已经介绍了如何安装Hadoop和Spark，所以，这里我们可以使用以下命令直接启动Hadoop中的HDFS组件（由于用不到MapReduce组件，所以，不需要启动MapReduce或者YARN）。请到第二个终端窗口，使用Linux Shell命令提示符状态，然后输入下面命令： 12cd /usr/local/hadoop./sbin/start-dfs.sh 启动结束后，HDFS开始进入可用状态。如果你在HDFS文件系统中，还没有为当前Linux登录用户创建目录(本教程统一使用用户名hadoop登录Linux系统)，请使用下面命令创建： 1./bin/hdfs dfs -mkdir -p /user/hadoop 也就是说，HDFS文件系统为Linux登录用户开辟的默认目录是“&#x2F;user&#x2F;用户名”（注意：是user，不是usr），本教程统一使用用户名hadoop登录Linux系统，所以，上面创建了“&#x2F;user&#x2F;hadoop”目录，再次强调，这个目录是在HDFS文件系统中，不在本地文件系统中。创建好以后，下面我们使用命令查看一下HDFS文件系统中的目录和文件： 1./bin/hdfs dfs -ls . ** 但这个命令我搞不出来，显示的是这个 – 上面命令中，最后一个点号“.”，表示要查看Linux当前登录用户hadoop在HDFS文件系统中与hadoop对应的目录下的文件，也就是查看HDFS文件系统中“&#x2F;user&#x2F;hadoop&#x2F;”目录下的文件，所以，下面两条命令是等价的： – 12./bin/hdfs dfs -ls ../bin/hdfs dfs -ls /user/hadoop 你自己可以试一试，只有第二个可以用 如果要查看HDFS文件系统根目录下的内容，需要使用下面命令： 1./bin/hdfs dfs -ls / 然后输出的东西见上面那个图，有一个items 下面，我们把本地文件系统中的“&#x2F;usr&#x2F;local&#x2F;spark&#x2F;mycode&#x2F;rdd&#x2F;word.txt”上传到分布式文件系统HDFS中（放到hadoop用户目录下）： 1./bin/hdfs dfs -put /usr/local/spark/mycode/rdd/word.txt /user/hadoop 然后，用命令查看一下HDFS的hadoop用户目录下是否多了word.txt文件，可以使用下面命令列出hadoop目录下的内容： 1./bin/hdfs dfs -ls / 可以看到，确实多了一个word.txt文件，我们使用cat命令查看一个HDFS中的word.txt文件的内容，命令如下： 1./bin/hdfs dfs -cat ./word.txt 上面命令执行后，就会看到HDFS中word.txt的内容了。 现在，让我们切换回到spark-shell窗口，编写语句从HDFS中加载word.txt文件，并显示第一行文本内容： 12&gt;&gt;&gt;lines= sc.textFile(&quot;hdfs://localhost:9000/user/hadoop/word.txt&quot;)&gt;&gt;&gt;lines=sc.foreach(print) 注意，上面三条命令是完全等价的命令，只不过使用了不同的目录形式，你可以使用其中任意一条命令完成数据加载操作。 在使用Spark读取文件时，需要说明以下几点：（1）如果使用了本地文件系统的路径，那么，必须要保证在所有的worker节点上，也都能够采用相同的路径访问到该文件，比如，可以把该文件拷贝到每个worker节点上，或者也可以使用网络挂载共享文件系统。（2）textFile()方法的输入参数，可以是文件名，也可以是目录，也可以是压缩文件等。比如，textFile(“&#x2F;my&#x2F;directory”), textFile(“&#x2F;my&#x2F;directory&#x2F;.txt”), and textFile(“&#x2F;my&#x2F;directory&#x2F;.gz”).（3）textFile()方法也可以接受第2个输入参数（可选），用来指定分区的数目。默认情况下，Spark会为HDFS的每个block创建一个分区（HDFS中每个block默认是128MB）。你也可以提供一个比block数量更大的值作为分区数目，但是，你不能提供一个小于block数量的值作为分区数目。 通过并行集合（数组）创建RDD可以调用SparkContext的parallelize方法，在Driver中一个已经存在的集合（数组）上创建。下面请在spark-shell中操作： 123&gt;&gt;&gt;array = [1,2,3,4,5]&gt;&gt;&gt;rdd = sc.parallelize(array)&gt;&gt;&gt;rdd.foreach(print) RDD操作RDD被创建好以后，在后续使用过程中一般会发生两种操作：*  转换（Transformation）： 基于现有的数据集创建一个新的数据集。*  行动（Action）：在数据集上进行运算，返回计算值。 转换操作对于RDD而言，每一次转换操作都会产生不同的RDD，供给下一个“转换”使用。转换得到的RDD是惰性求值的，也就是说，整个转换过程只是记录了转换的轨迹，并不会发生真正的计算，只有遇到行动操作时，才会发生真正的计算，开始从血缘关系源头开始，进行物理的转换操作。下面列出一些常见的转换操作（Transformation API）：* filter(func)：筛选出满足函数func的元素，并返回一个新的数据集* map(func)：将每个元素传递到函数func中，并将结果返回为一个新的数据集* flatMap(func)：与map()相似，但每个输入元素都可以映射到0或多个输出结果* groupByKey()：应用于(K,V)键值对的数据集时，返回一个新的(K, Iterable)形式的数据集* reduceByKey(func)：应用于(K,V)键值对的数据集时，返回一个新的(K, V)形式的数据集，其中的每个值是将每个key传递到函数func中进行聚合 1.filter(func) 好吧，这个书上说要把word.txt写成 12345Hadoop is goodSpark is fastSpark is better 那我们就 1cd /usr/local/spark/mycode/rdd 1gedit word.txt 然后再 123&gt;&gt;&gt;lines=sc.textFile(&quot;file:///usr/local/spark/mycode/rdd/word.txt&quot;)&gt;&gt;&gt;linesWithSpark = lines.filter(lambda line: &quot;Spark&quot; in line)&gt;&gt;&gt;linesWithSpark.foreach(print) 上面的代码中，lines就是一个RDD。lines.filter()会遍历lines中的每行文本，并对每行文本执行括号中的匿名函数，也就是执行Lamda表达式：line &#x3D;&gt; line.contains(“Spark”)，在执行Lamda表达式时，会把当前遍历到的这行文本内容赋值给参数line，然后，执行处理逻辑line.contains(“Spark”)，也就是只有当改行文本包含“Spark”才满足条件，才会被放入到结果集中。最后，等到lines集合遍历结束后，就会得到一个结果集，这个结果集中包含了所有包含“Spark”的行。最后，对这个结果集调用count()，这是一个行动操作，会计算出结果集中的元素个数。 2.map(func) map(func)：将每个元素传递到函数func中，并将结果返回为一个新的数据集 1234&gt;&gt;&gt; data =[1,2,3,4,5]&gt;&gt;&gt; rdd1 = sc.parallelize(data)&gt;&gt;&gt; rdd2 = rdd1.map(lambda x:x+10)&gt;&gt;&gt; rdd2.foreach(print) 上述语句执行过程如图 所示。第 1行语句创建了一个包含 5 个整型元素的列表 data。第2行语句执行 sc.parallelize(data)，从列表 data 中生成一个 RDD，即 rdd1,rdd1 中包含了5 个整型的元素即1、2、3、4、5。第 3 行语句执行 rdd1.map0操作,map0的输入参数“lambda x:x+10”是一个Lambda表达式。rdd1.map(lambda x:x+10)的含义是，依次取出 rdd1 这个RDD 中的每个元素，对于当前取到的元素，把它赋值给 Lambda 表达式中的变量x，然后，执行 Lambda 表达式的函数体部分“x+10”也就是把变量x的值和 10 相加后，作为函数的返回值，并作为一个元素放入到新的 RDD(即rdd2中。最终，新牛成的RDD (即 rdd2) 中包含了 5 个整型元素，即 11、12、13、14、15。 另外一个实例： 123&gt;&gt;&gt;lines=sc.textFile(&quot;file:///usr/local/spark/mycode/rdd/word.txt&quot;)&gt;&gt;&gt; words = lines.map(lambda line:line.split(&quot; &quot;))&gt;&gt;&gt; words.foreach(print) 上述语句执行过程如图所示。在第 1 行语句中，执行 sc.textFile0方法把 word.txt 文件中的数据加载到内存生成一个 RDD，即 lines，这个RDD 中的每个元素都是字符串类型，即每个 RDD 元素都是一行文本，比如，lines 中的第 1 个元素是”Hadoop is good”，第2 个元素是”Spark is fast”，第3个元素是”Spark is better”。在第 2 行语句中，执行 lies.map0操作，map0的输入参数 lambdaline:line.split(“)是一个 Lambda 表达式。linesmap(lambda line:line.split(“”)的含义是，依次取出 lines这个 RDD 中的每个元素，对于当前取到的元素，把它赋值给 Lambda 表达式中的变量 line，然后，执行 Lambda 表达式的函数体部分 line.split(“”)。因为 line 是一行文本，如”Hadoop is good”，一行文本中包含了很多个单词，单词之间以空格进行分隔，所以，line.split(“”的功能是，以空格作为分隔符把 line 拆分成一个个单词,拆分后得到的单词都封装在一个列表对象中,成为新的 RDD( 即 words)的一个元素，比如，”Hadoop is good”被拆分后，得到”Hadoop”、”is”和”good”3 个单词，会被封装到一个列表对象中，即[“Hadoop”.”is”,”good”]，成为 words 这个 RDD 中的一个元素。 3.flatMap(func)flatMap(func)与 map0相似，但每个输入元素都可以映射到 0 或多个输出结果。例如: 123&gt;&gt;&gt;lines=sc.textFile(&quot;file:///usr/local/spark/mycode/rdd/word.txt&quot;)&gt;&gt;&gt;words =lines.flatMap(lambda line:line.split(&quot; &quot;))&gt;&gt;&gt; words.foreach(print) 上述语句执行过程如图所示。在第 1行语句中，执行 sc.textFile0方法把 wordtxt 文件中的数据加载到内存生成一个RDD，即 lines，这个 RDD 中的每个元素都是字符串类型，即每个RDD 元素都是一行文本。在第2行语句中，执行 linesflatMap0操作，flatMap0的输入参数 line:linesplit(“”)是个Lambda 表达式。lines.flatMap(lambda line:line.split(“”))的结果，等价于如下两步操作的结果。 第1步: map0。执行 lines.map(lambda line: linesplit(“”))操作，从 lines 转换得到一个新的 RDD(即wordArray),wordArray 中的每个元素都是一个列表,比如,第1个元素是[“Hadoop”,”is”，”good”]7.第2个元素是”Spark”，”is”,”fast”]，第3 个元素是[“Spark”,”is””better”]。 第 2步:拍扁 ( flat)。flatMap0操作中的“flat”是一个很形象的动作-“拍扁”，也就是把vordArray 中的每个 RDD 元素都“拍扁”成多个元素。所有这些被拍扁以后得到的元素，构成一个新的 RDD，即 words。比如，wordArray 中的第1个元素是[“Hadoop”,”is”,”good]，被拍扁以后得到3个新的字符串类型的元素,即”Hadoop”、”is”和”good”; wordArray 中的第 2 个元素是[“Spark”,”is”fast”],被拍扁以后得到 3 个新的元素,即”Spark”、”is”和”fast”; wordArray 中的第 3 个元素是[“Spark””is””beter”，被拍扁以后得到 3 个新的元素，即”Spark”、”is”和”beter”。最终，这些被拍扁以后得到的 9 个字符串类型的元素构成一个新的 RDD (即 words )。也就是说，words 里面包含了 9 个字串类型的元素，分别是”Hadoop”、”is”、”good”、”Spark”、”is”、”fast”、”Spark”、”is”和”。","categories":[{"name":"2023","slug":"2023","permalink":"http://example.com/categories/2023/"}],"tags":[{"name":"Spark","slug":"Spark","permalink":"http://example.com/tags/Spark/"}]},{"title":"3-8-2023","slug":"3-8-2023","date":"2023-03-08T05:19:53.978Z","updated":"2023-03-08T05:45:39.860Z","comments":true,"path":"2023/03/08/3-8-2023/","link":"","permalink":"http://example.com/2023/03/08/3-8-2023/","excerpt":"三月初自我反省","text":"三月初自我反省 1.退实验室✔ 2.数学第一章✔ 3.单词200 per day✔ 4.后端增删查改✔ 1234567891011121314151617181920212223def department_list(request): member_list=Department.objects.all() return render(request,&#x27;dep.html&#x27;,&#123;&#x27;member&#x27;:member_list&#125;)def add_dep(request): if request.method==&#x27;GET&#x27;: return render(request,&#x27;adddep.html&#x27;) elif request.method==&#x27;POST&#x27;: title=request.POST.get(&#x27;aatitle&#x27;) Department.objects.create(tittle=title) return redirect(&quot;/dep/list&quot;)def delete_dep(request): memid=request.GET.get(&#x27;memid&#x27;) Department.objects.filter(id=memid).delete() return redirect(&quot;/dep/list&quot;)def edit_dep(request,memid): if request.method==&#x27;GET&#x27;: nnmame=Department.objects.filter(id=memid).first() return render(request,&#x27;editdpt.html&#x27;,&#123;&#x27;nnmame&#x27;:nnmame.tittle&#125;) aatitle=request.POST.get(&#x27;aatitle&#x27;) Department.objects.filter(id=memid).update(tittle=aatitle) return redirect(&quot;/dep/list&quot;) 5.数据结构 图(floyd，dijkstra)✔ 1234567891011121314151617181920212223242526272829303132#include&lt;cstdio&gt;#include&lt;iostream&gt;#include&lt;cmath&gt;#include&lt;cstring&gt;using namespace std;int a[101][3];double f[101][101];int n,i,j,k,x,y,m,s,e;int main()&#123;// freopen(&quot;short.in&quot;,&quot;r&quot;,stdin);// freopen(&quot;short.out&quot;,&quot;w&quot;,stdout); cin&gt;&gt;n; for(i=1;i&lt;=n;i++) cin&gt;&gt;a[i][1]&gt;&gt;a[i][2]; cin&gt;&gt;m; memset(f,0x7f,sizeof(f)); //初始化为最大值 for(i=1;i&lt;=m;i++)&#123; cin&gt;&gt;x&gt;&gt;y;// int temp1=;// int temp2=; f[y][x]=f[x][y]=sqrt(pow(double(a[x][1]-a[y][1]),2)+pow(double(a[x][2]-a[y][2]),2)); &#125; cin&gt;&gt;s&gt;&gt;e; for(k=1;k&lt;=n;k++) for(j=1;j&lt;=n;j++) for(i=1;i&lt;=n;i++) if(f[i][k]+f[k][j]&lt;f[i][j]) f[i][j]=f[i][k]+f[k][j]; printf(&quot;%.2lf\\n&quot;,f[s][e]); return 0; &#125; 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849#include&lt;cstdio&gt;#include&lt;cstring&gt;#define INF 1e4+10using namespace std;const int M=1e4+10;const int N=1000+10;int n,m,s;int mp[N][M];int dis[N],vis[N];void initmp()&#123;memset(mp,INF,sizeof(mp)); &#125;void dijkstra(int s)&#123; //求s点到其它点的最短路径 memset(vis,0,sizeof(vis));//0表示蓝点(未确定最短路径的点)，1表示白点（确定路径的点） memset(dis,0x3f,sizeof(dis));//默认情况下设置为无穷大 dis[s]=0; while(1)&#123; int mini=0,min_=INF; for(int j=1;j&lt;=n;j++)&#123; if(!vis[j]&amp;&amp;min_&gt;dis[j])&#123;//从蓝点中找出最小的点 .vis[j](蓝点)为0,那么!vis[j]就为1了.dis[j]是权值 mini=j;//记录第几个点 min_=dis[j]; //记录最短的路的距离 &#125; &#125; //如果没有蓝点就提前结束 if(mini==0) break; vis[mini]=1;//变成白点 for(int i=1;i&lt;=n;i++)&#123; if(dis[i]&gt;dis[mini]+mp[mini][i]) dis[i]=dis[mini]+mp[mini][i]; &#125; &#125; &#125;int main()&#123; memset(mp,INF,sizeof(mp)); while(scanf(&quot;%d %d&quot;,&amp;n,&amp;m)!=EOF&amp;&amp;n)&#123; initmp();//每次清空mp for(int i=0;i&lt;m;i++)&#123; int u,v,w; scanf(&quot;%d %d %d&quot;,&amp;u,&amp;v,&amp;w); if(mp[u][v]&gt;w) mp[u][v]=mp[v][u]=w; &#125; dijkstra(1); printf(&quot;%d\\n&quot;,dis[n]); &#125; return 0;&#125;","categories":[{"name":"2023","slug":"2023","permalink":"http://example.com/categories/2023/"}],"tags":[{"name":"casual_talk","slug":"casual-talk","permalink":"http://example.com/tags/casual-talk/"}]},{"title":"DataError at /index/add_member 1366, \"Incorrect string value :\\\\xE4\\\\xBC\\\\x98\\\\xE","slug":"ERROR 1366 (HY000)Incorrect string value解决方案","date":"2023-03-05T03:11:11.586Z","updated":"2023-03-08T05:16:49.900Z","comments":true,"path":"2023/03/05/ERROR 1366 (HY000)Incorrect string value解决方案/","link":"","permalink":"http://example.com/2023/03/05/ERROR%201366%20(HY000)Incorrect%20string%20value%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/","excerpt":"&#56;&#x32;&#53;&#x35;&#55;&#55;&#x39;&#x34;&#x30;&#64;&#113;&#113;&#46;&#99;&#x6f;&#109; DataError at &#x2F;index&#x2F;add_member 1366, “Incorrect string value: ‘\\xE4\\xBC\\x98\\xE ERROR 1366 (HY000):Incorrect string value解决方案","text":"&#56;&#x32;&#53;&#x35;&#55;&#55;&#x39;&#x34;&#x30;&#64;&#113;&#113;&#46;&#99;&#x6f;&#109; DataError at &#x2F;index&#x2F;add_member 1366, “Incorrect string value: ‘\\xE4\\xBC\\x98\\xE ERROR 1366 (HY000):Incorrect string value解决方案 https://zhuanlan.zhihu.com/p/53941345 after before 然后把数据库删除，重新创建数据库，再导入数据库文件，就又是一条好汉","categories":[{"name":"2023","slug":"2023","permalink":"http://example.com/categories/2023/"}],"tags":[{"name":"mysql","slug":"mysql","permalink":"http://example.com/tags/mysql/"}]},{"title":"远离不规范书籍，不然会变得不幸","slug":"远离不规范书籍，不然会变得不幸","date":"2023-03-04T09:14:48.511Z","updated":"2023-03-08T05:16:54.675Z","comments":true,"path":"2023/03/04/远离不规范书籍，不然会变得不幸/","link":"","permalink":"http://example.com/2023/03/04/%E8%BF%9C%E7%A6%BB%E4%B8%8D%E8%A7%84%E8%8C%83%E4%B9%A6%E7%B1%8D%EF%BC%8C%E4%B8%8D%E7%84%B6%E4%BC%9A%E5%8F%98%E5%BE%97%E4%B8%8D%E5%B9%B8/","excerpt":"远离不规范书籍,不然会变得不幸","text":"远离不规范书籍,不然会变得不幸","categories":[{"name":"2023","slug":"2023","permalink":"http://example.com/categories/2023/"}],"tags":[{"name":"casual_talk","slug":"casual-talk","permalink":"http://example.com/tags/casual-talk/"}]},{"title":"2月开学总结","slug":"2月开学总结","date":"2023-03-01T06:57:51.608Z","updated":"2023-03-08T05:15:23.317Z","comments":true,"path":"2023/03/01/2月开学总结/","link":"","permalink":"http://example.com/2023/03/01/2%E6%9C%88%E5%BC%80%E5%AD%A6%E6%80%BB%E7%BB%93/","excerpt":"2月开学总结","text":"2月开学总结 每日200单词，真的坚持不下来（我妈说过一句老话：新的马桶只有三天是香的） 周五-周日每日50页django目前停滞（p117），在后渲前的简单&#123;&#123;&#125;&#125;不清楚具体语法，有时间看b具体简单讲解，我实在无法理解，这种书怎么出版的，前20页每页都有错误，这个人抄官方文档都能抄错？？？？！！！ 问了师姐她复习进度，四月之前（include四月）刷完1800,以及师姐说英二难度比江苏高考英语难度小 临时接了挑战杯的复赛答辩，要准备讲演稿子 目前数学进度第一章（第一遍做不到不看视频（看视频时真的费时间），但已经都忘了（为什么上学期我要拒绝高数老师让我做她的助教（扇自己耳光））） 英语6级太难了 准备算法考试 所有的东西并行真的做不到，一天只能选一个（上周多线程进行复习&amp;&amp;学习，效率极低） 佛山顺德愿望get 实验室老师开始整幺蛾子了：周四下午7、8节加了一节选修课。明天去一节看看情况，不行就退实验室;以及未来一个月内实验室搬迁，不行就退。 昨天去交材料，党建的辅导老师说：好久没看见你了，你最近在干嘛。 我：准备考研，和实验室的东西。 老师:你准备考研的话要平衡比赛和考研准备的东西 老师:考研的书差不多要买了 我：嗯嗯12.仰天长叹，下个月三场考试，4月份一轮，师姐说828要在这学期内过完，操作系统跟着这学期的老师好好学一遍，就没什么问题，我真的能平衡吗……实验室感觉差不多可以退了，但又想拼一把计算机设计大赛，自己再做个东西出来…… emoji format 本来想花15min解决的note，花了1个小时的原因窒息","categories":[{"name":"2023","slug":"2023","permalink":"http://example.com/categories/2023/"}],"tags":[{"name":"casual_talk","slug":"casual-talk","permalink":"http://example.com/tags/casual-talk/"}]},{"title":"Import pymysql could not be resolved from","slug":"Import pymysql could not be resolved from","date":"2023-02-26T13:23:28.035Z","updated":"2023-03-13T16:56:38.944Z","comments":true,"path":"2023/02/26/Import pymysql could not be resolved from/","link":"","permalink":"http://example.com/2023/02/26/Import%20pymysql%20could%20not%20be%20resolved%20from/","excerpt":"Import “pymysql” could not be resolved from","text":"Import “pymysql” could not be resolved from 在anaconda里面装一个 首先先切进django的虚拟环境里面 在Anaconda中，可以通过使用conda命令来创建和管理虚拟环境。要切换已创建的虚拟环境，可以使用以下命令： 列出已有环境： 1conda info --envs 激活目标环境： 1conda activate &lt;env_name&gt; 这里&lt;env_name&gt;是你想要激活的虚拟环境的名称。激活环境后，你可以在该环境中使用安装的软件包和工具。 取消激活当前环境： 1conda deactivate 这将使当前环境不再处于活动状态，回到默认的基础环境。 注意：如果你在使用Anaconda Navigator，也可以通过选择“Environments”选项卡，然后单击目标环境的名称来激活虚拟环境。 conda install pymysql 看你anaconda用的是什么源，国内的记得关闭魔法上网工具","categories":[{"name":"2023","slug":"2023","permalink":"http://example.com/categories/2023/"}],"tags":[{"name":"django","slug":"django","permalink":"http://example.com/tags/django/"}]},{"title":"官方文档","slug":"null¶","date":"2023-02-24T12:24:35.657Z","updated":"2023-03-01T07:09:14.756Z","comments":true,"path":"2023/02/24/null¶/","link":"","permalink":"http://example.com/2023/02/24/null%C2%B6/","excerpt":"https://stackoverflow.com/questions/19428572/django-templatesyntaxerror-could-not-parse-the-remainder","text":"https://stackoverflow.com/questions/19428572/django-templatesyntaxerror-could-not-parse-the-remainder 模型字段参考 字段选项 https://docs.djangoproject.com/zh-hans/4.1/ref/models/fields/#validators 以下参数对所以字段类型均有效，且是可选的。 null¶ Field.``null¶ 如果是 True， Django 将在数据库中存储空值为 NULL。默认为 False。 避免在基于字符串的字段上使用 null，如 CharField 和 TextField。如果一个基于字符串的字段有 null=True，这意味着它有两种可能的“无数据”值。NULL，和空字符串。在大多数情况下，“无数据”有两种可能的值是多余的，Django 的惯例是使用空字符串，而不是 NULL。一个例外是当一个 CharField 同时设置了 unique=True 和 blank=True。在这种情况下，null=True 是需要的，以避免在保存具有空白值的多个对象时违反唯一约束。 无论是基于字符串的字段还是非字符串的字段，如果希望在表单中允许空值，还需要设置 blank=True，因为 null 参数只影响数据库的存储（参见 blank ）。","categories":[{"name":"2023","slug":"2023","permalink":"http://example.com/categories/2023/"}],"tags":[{"name":"django","slug":"django","permalink":"http://example.com/tags/django/"}]},{"title":"Module \"django.contrib.sessions.serializers\" does not define a \"PicleSerializer\" attribute/class","slug":"Module django.contrib.sessions.serializers does not define a PicleSerializer attributeclass","date":"2023-02-24T07:05:59.648Z","updated":"2023-03-01T07:09:09.742Z","comments":true,"path":"2023/02/24/Module django.contrib.sessions.serializers does not define a PicleSerializer attributeclass/","link":"","permalink":"http://example.com/2023/02/24/Module%20django.contrib.sessions.serializers%20does%20not%20define%20a%20PicleSerializer%20attributeclass/","excerpt":"Module “django.contrib.sessions.serializers” does not define a “PicleSerializer” attribute&#x2F;class","text":"Module “django.contrib.sessions.serializers” does not define a “PicleSerializer” attribute&#x2F;class 是这本书打错了hhhh https://docs.djangoproject.com/zh-hans/4.1/topics/http/sessions/ 在这里ctrl+F找 serializers 最后一个 serializers.``PickleSerializer tmd是这个玩意儿！ 不是picle睡觉哦pick 服了这个写书的老六！","categories":[{"name":"2023","slug":"2023","permalink":"http://example.com/categories/2023/"}],"tags":[{"name":"django","slug":"django","permalink":"http://example.com/tags/django/"}]},{"title":"无法加载文件C:\\Users\\xxx\\Documents\\WindowsPowerShell\\profile.ps1","slug":"无法加载文件CUsersxxxDocumentsWindowsPowerShellprofile.ps1，因为在此系统上禁止运行脚本","date":"2023-02-24T04:38:04.277Z","updated":"2023-03-01T07:08:52.941Z","comments":true,"path":"2023/02/24/无法加载文件CUsersxxxDocumentsWindowsPowerShellprofile.ps1，因为在此系统上禁止运行脚本/","link":"","permalink":"http://example.com/2023/02/24/%E6%97%A0%E6%B3%95%E5%8A%A0%E8%BD%BD%E6%96%87%E4%BB%B6CUsersxxxDocumentsWindowsPowerShellprofile.ps1%EF%BC%8C%E5%9B%A0%E4%B8%BA%E5%9C%A8%E6%AD%A4%E7%B3%BB%E7%BB%9F%E4%B8%8A%E7%A6%81%E6%AD%A2%E8%BF%90%E8%A1%8C%E8%84%9A%E6%9C%AC/","excerpt":"无法加载文件C:\\Users\\xxx\\Documents\\WindowsPowerShell\\profile.ps1，因为在此系统上禁止运行脚本","text":"无法加载文件C:\\Users\\xxx\\Documents\\WindowsPowerShell\\profile.ps1，因为在此系统上禁止运行脚本 问题描述打开 PowerShell 提示如下报错信息。 123456789101112Windows PowerShell版权所有（C） Microsoft Corporation。保留所有权利。安装最新的 PowerShell，了解新功能和改进！https://aka.ms/PSWindows. : 无法加载文件 C:\\Users\\87897\\Documents\\WindowsPowerShell\\profile.ps1，因为在此系统上禁止运行脚本。有关详细信息，请参阅 https:/go.microsoft.com/fwlink/?LinkID=135170 中的 about_Execution_Policies。所在位置 行:1 字符: 3+ . &#x27;C:\\Users\\87897\\Documents\\WindowsPowerShell\\profile.ps1&#x27;+ ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ + CategoryInfo : SecurityError: (:) []，PSSecurityException1234567891011 原因分析输入 get-ExecutionPolicy 输出 Restricted，即脚本执行策略受限。 123PS C:\\Windows\\system32&gt; get-ExecutionPolicyRestricted12 解决方案更换脚本执行策略：set-ExecutionPolicy RemoteSigned，然后输入 Y。 1234567PS C:\\Windows\\system32&gt; set-ExecutionPolicy RemoteSigned执行策略更改执行策略可帮助你防止执行不信任的脚本。更改执行策略可能会产生安全风险，如 https:/go.microsoft.com/fwlink/?LinkID=135170中的 about_Execution_Policies 帮助主题所述。是否要更改执行策略?[Y] 是(Y) [A] 全是(A) [N] 否(N) [L] 全否(L) [S] 暂停(S) [?] 帮助 (默认值为“N”): Y123456 更换完成后，再次使用命令 get-ExecutionPolicy 查看脚本执行策略。 123PS C:\\Windows\\system32&gt; get-ExecutionPolicyRemoteSigned12 可以发现已经更改了。问题完美解决，over~~😊","categories":[{"name":"2023","slug":"2023","permalink":"http://example.com/categories/2023/"}],"tags":[{"name":"powershell","slug":"powershell","permalink":"http://example.com/tags/powershell/"}]},{"title":"anaconda安装其他东西","slug":"Win10下Anaconda使用conda activate报错Your shell has not been properly configured to use 'conda activate'","date":"2023-02-24T04:23:35.093Z","updated":"2023-03-08T05:18:49.483Z","comments":true,"path":"2023/02/24/Win10下Anaconda使用conda activate报错Your shell has not been properly configured to use 'conda activate'/","link":"","permalink":"http://example.com/2023/02/24/Win10%E4%B8%8BAnaconda%E4%BD%BF%E7%94%A8conda%20activate%E6%8A%A5%E9%94%99Your%20shell%20has%20not%20been%20properly%20configured%20to%20use%20'conda%20activate'/","excerpt":"Win10下Anaconda使用conda activate报错Your shell has not been properly configured to use ‘conda activate’","text":"Win10下Anaconda使用conda activate报错Your shell has not been properly configured to use ‘conda activate’ 1234567891011121314151617181920212223PS E:\\dijango&gt; conda activate baseCommandNotFoundError: Your shell has not been properly configured to use &#x27;conda activate&#x27;.If using &#x27;conda activate&#x27; from a batch script, change yourinvocation to &#x27;CALL conda.bat activate&#x27;.To initialize your shell, run $ conda init &lt;SHELL_NAME&gt;Currently supported shells are:- bash- cmd.exe- fish- tcsh- xonsh- zsh- powershellSee &#x27;conda init --help&#x27; for more information and options.IMPORTANT: You may need to close and restart your shell after running &#x27;conda init&#x27;. 先以管理员身份打开cmd。试一下conda activate 环境名称。如果命令行提示 1Your shell has not been properly configured to use ‘conda activate’. 然后下面还提示 conda init &lt;SHELL NAME&gt; 就按照他的要求，输入一下 conda init cmd.exe 或者 conda init powershell 这两条都试试，回车，重启cmd说不定就好了。反正我好了。","categories":[{"name":"2023","slug":"2023","permalink":"http://example.com/categories/2023/"}],"tags":[{"name":"anaconda","slug":"anaconda","permalink":"http://example.com/tags/anaconda/"}]},{"title":"闭包","slug":"闭包","date":"2023-02-23T14:17:31.662Z","updated":"2023-02-23T13:50:32.190Z","comments":true,"path":"2023/02/23/闭包/","link":"","permalink":"http://example.com/2023/02/23/%E9%97%AD%E5%8C%85/","excerpt":"闭包","text":"闭包 12345678910111213141516171819202122232425262728// 1.污染环境的全局变量实现函数执行一次次数减一 var a=10; function fa()&#123; a--; console.log(a); &#125; // 2.那就换成局部变量试试 function fb()&#123; var a=10; a--; console.log(a); &#125;/*它居然不动了*/ // 3.闭包 function fc()&#123; let a=10; function fd()&#123; a--; console.log(a); &#125; return fd; &#125; var fm=fc();//完成这句才算闭包 // 总结 // 1.有嵌套函数 // 2.内部函数引用外部作用域 // 3.返回值是函数 // 4.船舰一个对象函数，让其长期驻留","categories":[{"name":"2022","slug":"2022","permalink":"http://example.com/categories/2022/"}],"tags":[{"name":"js","slug":"js","permalink":"http://example.com/tags/js/"}]},{"title":"reat-router","slug":"router","date":"2023-02-23T14:17:31.647Z","updated":"2023-02-23T13:50:45.673Z","comments":true,"path":"2023/02/23/router/","link":"","permalink":"http://example.com/2023/02/23/router/","excerpt":"随意使用您选择的打包器，例如 Create React App 1npx create-react-app router-tutorial","text":"随意使用您选择的打包器，例如 Create React App 1npx create-react-app router-tutorial 然后安装 React Router 依赖项： 12cd router-tutorialnpm install react-router-dom@6 history@5 然后编辑你的App.js，让它变得很无聊: 1234567export default function App() &#123; return ( &lt;div&gt; &lt;h1&gt;Bookkeeper!&lt;/h1&gt; &lt;/div&gt; );&#125; 最后，确认index.js or main.jsx（取决于你的打包工具）是可用的： root渲染App 123456import &#123; render &#125; from &quot;react-dom&quot;;import App from &quot;./App&quot;;const rootElement = document.getElementById(&quot;root&quot;);render(&lt;App /&gt;, rootElement); 然后是删了一点东西 启动您的React应用： 1npm start 连接路由首先，我们想把你的应用连接到路由: import ‘ BrowserRouter ‘，并用它包裹你的整个应用。(修改index.js) 1234567891011import &#123; render &#125; from &quot;react-dom&quot;;import &#123; BrowserRouter &#125; from &quot;react-router-dom&quot;;import App from &quot;./App&quot;;const rootElement = document.getElementById(&quot;root&quot;);render( &lt;BrowserRouter&gt; &lt;App /&gt; &lt;/BrowserRouter&gt;, rootElement); 应用程序中没有任何变化，但现在我们已准备好开始处理路由。 添加一些链接打开 src&#x2F;App.js、导入 Link 并添加一些全局导航。注：在本教程中不要对待样式太认真，我们只是为了方便而使用内联样式，你可以根据需要设置样式。 123456789101112131415161718import &#123; Link &#125; from &quot;react-router-dom&quot;;export default function App() &#123; return ( &lt;div&gt; &lt;h1&gt;Bookkeeper&lt;/h1&gt; &lt;nav style=&#123;&#123; borderBottom: &quot;solid 1px&quot;, paddingBottom: &quot;1rem&quot; &#125;&#125; &gt; &lt;Link to=&quot;/invoices&quot;&gt;Invoices&lt;/Link&gt; |&#123;&quot; &quot;&#125; &lt;Link to=&quot;/expenses&quot;&gt;Expenses&lt;/Link&gt; &lt;/nav&gt; &lt;/div&gt; );&#125; 单击链接和后退&#x2F;前进按钮。React Router 现在正在控制 URL！ 我们还没有在 URL 更改时呈现任何路由，但 Link 可以更改 URL，而不会导致整个页面重新加载。 添加一些路由添加几个新文件： src/routes/invoices.jsx src/routes/expenses.jsx (文件的位置并不重要，但是当你想要自动生成后端API，服务器渲染，代码分割或者更多的功能时，像这样命名你的文件可以很容易地将这个应用程序移植到其他项目，Remix😉) 现在在文件中加入以下代码： expenses.jsx 1234567export default function Expenses() &#123; return ( &lt;main style=&#123;&#123; padding: &quot;1rem 0&quot; &#125;&#125;&gt; &lt;h2&gt;Expenses&lt;/h2&gt; &lt;/main&gt; );&#125; invoices.jsx 1234567export default function Invoices() &#123; return ( &lt;main style=&#123;&#123; padding: &quot;1rem 0&quot; &#125;&#125;&gt; &lt;h2&gt;Invoices&lt;/h2&gt; &lt;/main&gt; );&#125; 最后，让我们通过在main.jsx或者index.js 中创建我们的第一个“路由配置”来让 React Router 在不同的 URL 上呈现我们的界面。 123456789101112131415161718192021import &#123; render &#125; from &quot;react-dom&quot;;import &#123; BrowserRouter, Routes, Route&#125; from &quot;react-router-dom&quot;;import App from &quot;./App&quot;;import Expenses from &quot;./routes/expenses&quot;;import Invoices from &quot;./routes/invoices&quot;;const rootElement = document.getElementById(&quot;root&quot;);render( &lt;BrowserRouter&gt; &lt;Routes&gt; &lt;Route path=&quot;/&quot; element=&#123;&lt;App /&gt;&#125; /&gt; &lt;Route path=&quot;expenses&quot; element=&#123;&lt;Expenses /&gt;&#125; /&gt; &lt;Route path=&quot;invoices&quot; element=&#123;&lt;Invoices /&gt;&#125; /&gt; &lt;/Routes&gt; &lt;/BrowserRouter&gt;, rootElement); 注意：当路由为”&#x2F;“时它渲染App组件，在”&#x2F;invoices”时它渲染Invoices组件。 所以到这里我们可以看出，点击后会整页都会变换掉 嵌套路由你可能已经注意到，当点击链接时，“App”中的布局会消失。共享布局是一件令人头疼的事情。我们已经知道，大多数UI都是一系列嵌套布局，这些布局总会映射到URL上，所以这个思路被直接植入到React Router中。 12345678910111213141516171819202122import &#123; render &#125; from &quot;react-dom&quot;;import &#123; BrowserRouter, Routes, Route&#125; from &quot;react-router-dom&quot;;import App from &quot;./App&quot;;import Expenses from &quot;./routes/expenses&quot;;import Invoices from &quot;./routes/invoices&quot;;const rootElement = document.getElementById(&quot;root&quot;);render( &lt;BrowserRouter&gt; &lt;Routes&gt; &lt;Route path=&quot;/&quot; element=&#123;&lt;App /&gt;&#125;&gt; &lt;Route path=&quot;expenses&quot; element=&#123;&lt;Expenses /&gt;&#125; /&gt; &lt;Route path=&quot;invoices&quot; element=&#123;&lt;Invoices /&gt;&#125; /&gt; &lt;/Route&gt; &lt;/Routes&gt; &lt;/BrowserRouter&gt;, rootElement); 当路由有子节点时，它会做两件事： 它嵌套了 URL (&quot;/&quot; + &quot;expenses&quot; 和 &quot;/&quot; + &quot;invoices&quot;) 当子路由匹配时，它将嵌套共享布局的 UI 组件： 但是，为了使（2）生效，我们需要在App.jsx“父”路由中渲染一个 组件。 12345678910111213141516171819import &#123; Outlet, Link &#125; from &quot;react-router-dom&quot;;export default function App() &#123; return ( &lt;div&gt; &lt;h1&gt;Bookkeeper&lt;/h1&gt; &lt;nav style=&#123;&#123; borderBottom: &quot;solid 1px&quot;, paddingBottom: &quot;1rem&quot; &#125;&#125; &gt; &lt;Link to=&quot;/invoices&quot;&gt;Invoices&lt;/Link&gt; |&#123;&quot; &quot;&#125; &lt;Link to=&quot;/expenses&quot;&gt;Expenses&lt;/Link&gt; &lt;/nav&gt; &lt;Outlet /&gt; &lt;/div&gt; );&#125; 现在再次单击。父路由 ( App.js) 仍然存在，而 &lt;Outlet&gt; 在两个子路由 (&lt;Invoices&gt; 和 &lt;Expenses&gt;)之间切换！ 正如我们稍后将看到的，这适用于路由层次结构的任何级别，并且非常强大。 列出发票通常你会从某个地方的服务器获取数据，但在本教程中，让我们造一些数据，这样我们就可以专注于路由。 创建一个文件src&#x2F;data.js并将其复制&#x2F;粘贴到那里： 123456789101112131415161718192021222324252627282930313233343536let invoices = [ &#123; name: &quot;Santa Monica&quot;, number: 1995, amount: &quot;$10,800&quot;, due: &quot;12/05/1995&quot; &#125;, &#123; name: &quot;Stankonia&quot;, number: 2000, amount: &quot;$8,000&quot;, due: &quot;10/31/2000&quot; &#125;, &#123; name: &quot;Ocean Avenue&quot;, number: 2003, amount: &quot;$9,500&quot;, due: &quot;07/22/2003&quot; &#125;, &#123; name: &quot;Tubthumper&quot;, number: 1997, amount: &quot;$14,000&quot;, due: &quot;09/01/1997&quot; &#125;, &#123; name: &quot;Wide Open Spaces&quot;, number: 1998, amount: &quot;$4,600&quot;, due: &quot;01/27/2998&quot; &#125;];export function getInvoices() &#123; return invoices;&#125; 现在我们可以在发票路由中使用它。让我们也添加一些样式来获得侧边栏导航布局。随意复制&#x2F;粘贴所有这些，但要特别注意 &lt;Link&gt; 组件需要 to 属性： 1234567891011121314151617181920212223242526import &#123; Link &#125; from &quot;react-router-dom&quot;;import &#123; getInvoices &#125; from &quot;../data&quot;;export default function Invoices() &#123; let invoices = getInvoices(); return ( &lt;div style=&#123;&#123; display: &quot;flex&quot; &#125;&#125;&gt; &lt;nav style=&#123;&#123; borderRight: &quot;solid 1px&quot;, padding: &quot;1rem&quot; &#125;&#125; &gt; &#123;invoices.map(invoice =&gt; ( &lt;Link style=&#123;&#123; display: &quot;block&quot;, margin: &quot;1rem 0&quot; &#125;&#125; to=&#123;`/invoices/$&#123;invoice.number&#125;`&#125; key=&#123;invoice.number&#125; &gt; &#123;invoice.name&#125; &lt;/Link&gt; ))&#125; &lt;/nav&gt; &lt;/div&gt; );&#125;","categories":[{"name":"2022","slug":"2022","permalink":"http://example.com/categories/2022/"}],"tags":[{"name":"reat","slug":"reat","permalink":"http://example.com/tags/reat/"}]},{"title":"匿名函数","slug":"匿名函数","date":"2023-02-23T14:17:31.647Z","updated":"2023-02-23T13:50:36.485Z","comments":true,"path":"2023/02/23/匿名函数/","link":"","permalink":"http://example.com/2023/02/23/%E5%8C%BF%E5%90%8D%E5%87%BD%E6%95%B0/","excerpt":"匿名函数","text":"匿名函数 123456789101112131415161718// 1.表达式赋值给变量来使用var fa =function()&#123; console.log(20);&#125;fa();// 2.当作函数来被调用setTimeout(function()&#123;console.log(30);&#125;,1000);// 3.通过函数嵌套当成闭包里的返回函数来调用function fb()&#123; return function()&#123;console.log(40);&#125;&#125;var fm=fb();fm();// 4.函数自己调用自己，也就是自调用。!function()&#123;console.log(50);&#125;();//匿名函数智能被调用或是自调用。//带参数的匿名函数自调用!function(a,b)&#123;console.log(a+b);&#125;(40,50);","categories":[{"name":"2022","slug":"2022","permalink":"http://example.com/categories/2022/"}],"tags":[{"name":"js","slug":"js","permalink":"http://example.com/tags/js/"}]},{"title":"回调函数","slug":"回调函数","date":"2023-02-23T14:17:31.647Z","updated":"2023-02-23T13:50:29.285Z","comments":true,"path":"2023/02/23/回调函数/","link":"","permalink":"http://example.com/2023/02/23/%E5%9B%9E%E8%B0%83%E5%87%BD%E6%95%B0/","excerpt":"回调函数","text":"回调函数 12345678910111213141516171819// 先定义一个函数，用来做短时间或无法脱身的事情，同步function sdo(does)&#123; console.log(does);&#125;// 在定义以恶搞函数，用来做长时间等待的事情，异步//用回调解决这个问题function ldo(doing,callback)&#123; setTimeout(()=&gt;&#123; console.log(doing); callback(&#x27;吃鸡&#x27;) &#125;,1000);&#125;// 接下来要开始迫害只因sdo(&#x27;买鸡&#x27;)sdo(&#x27;杀鸡&#x27;)ldo(&#x27;炖鸡&#x27;,sdo)//===&gt;函数作为参数// sdo(&#x27;吃鸡&#x27;)// 会发现不对劲","categories":[{"name":"2022","slug":"2022","permalink":"http://example.com/categories/2022/"}],"tags":[{"name":"js","slug":"js","permalink":"http://example.com/tags/js/"}]},{"title":"箭头函数","slug":"箭头函数","date":"2023-02-23T14:17:31.647Z","updated":"2023-02-23T13:50:33.998Z","comments":true,"path":"2023/02/23/箭头函数/","link":"","permalink":"http://example.com/2023/02/23/%E7%AE%AD%E5%A4%B4%E5%87%BD%E6%95%B0/","excerpt":"箭头函数","text":"箭头函数 12345678910111213141516// 1.箭头函数常见写法let fun1=(a,b)=&gt;&#123;return a+b;&#125;// 2.箭头函数没有参数，那么也要写括号let fun2=()=&gt;&#123;console.log(&#x27;你好&#x27;);&#125;// 3.如果只有一个参数，那么括号可以省略let fun3=name=&gt;&#123;console.log(`你好$&#123;name&#125;`);&#125;// 4.如果函数体只有一句执行代码，那么可以省略大括号，同时代码默认会被ruturn出去let fun4=name=&gt;`你好$&#123;name&#125;`;console.log(fun4(&#x27;小明&#x27;));// 5.箭头函数没有自己的this，他的this是来自于上层作用域的this let obj=&#123; fun5()&#123;console.log(&#x27;fun5:&#x27;,this);&#125;, fun6:()=&gt;&#123;console.log(&#x27;fun6:&#x27;,this);&#125; &#125; obj.fun5(); obj.fun6();","categories":[{"name":"2022","slug":"2022","permalink":"http://example.com/categories/2022/"}],"tags":[{"name":"js","slug":"js","permalink":"http://example.com/tags/js/"}]},{"title":"解决bash hexo command not found","slug":"解决bash hexo command not found","date":"2023-02-23T14:17:31.647Z","updated":"2023-03-01T07:08:49.612Z","comments":true,"path":"2023/02/23/解决bash hexo command not found/","link":"","permalink":"http://example.com/2023/02/23/%E8%A7%A3%E5%86%B3bash%20hexo%20command%20not%20found/","excerpt":"解决bash: hexo: command not found","text":"解决bash: hexo: command not found 检查 nodejs 和 npm 是否正常，依次输入命令 node -v 和 npm -v 看看是否有相关版本信息 出现了版本信息就证明 nodejs 和 npm 是没有问题的，那么就应该是环境变量的配置问题了，在【此电脑】右键【属性】，依次选择【高级系统设置】-【环境变量】，选择系统变量 Path，将 node_modules 下的 .bin 文件路径添加到 Path 里面 注意你的博客目录下应该有两个 node_modules 文件夹 F:\\blog 和F:\\blog\\BLOG 我是加了第一个module在环境变量 别的博主有的加了第二个module 总之自己试一下按哪个 环境变量添加好了之后重新打开 git 即可运行 hexo 命令，如果此时仍然无法执行 hexo 命令，那就只能拿出终极绝招了，运行命令 npm install hexo-cli -g 重新安装 hexo 即可！","categories":[{"name":"2023","slug":"2023","permalink":"http://example.com/categories/2023/"}],"tags":[{"name":"hexo","slug":"hexo","permalink":"http://example.com/tags/hexo/"}]},{"title":"PyQt5显示图片","slug":"PyQt5显示图片","date":"2023-02-23T14:17:31.640Z","updated":"2023-02-23T14:03:39.746Z","comments":true,"path":"2023/02/23/PyQt5显示图片/","link":"","permalink":"http://example.com/2023/02/23/PyQt5%E6%98%BE%E7%A4%BA%E5%9B%BE%E7%89%87/","excerpt":"PyQt5显示图片","text":"PyQt5显示图片 123redImg=QImage()QImage.load(redImg,&#x27;path&#x27;,format=&#x27;png&#x27;)self.label_3.setPixmap(QtGui.QPixmap(redImg)) 123img_path=&#x27;path&#x27;self.showImage = QPixmap(img_path).scaled(self.label_3.width(), self.label_3.height()) # 适应窗口大小self.label_3.setPixmap(self.showImage) # 显示图片 1234567image=cv2.imread(&#x27;path&#x27;)def showImageRed(self): self.image_1 = self.image self.image_1 = QtGui.QImage(self.image_1.data, self.image_1.shape[1],self.image_1.shape[0],QtGui.QImage.Format_RGB888).rgbSwapped() self.label_3.setPixmap(QtGui.QPixmap.fromImage(self.image_1)) 第三种方法可能会有斜影子，修改成下方这样 1234def showImageRed(self): self.image_1 = self.image self.image_1 = QtGui.QImage(self.image_1.data, self.image_1.shape[1], self.image_1.shape[0],self.image_1.shape[1]*3, QtGui.QImage.Format_RGB888).rgbSwapped() self.label_3.setPixmap(QtGui.QPixmap.fromImage(self.image_1)) 感觉应该是三通道问题","categories":[{"name":"2022","slug":"2022","permalink":"http://example.com/categories/2022/"}],"tags":[{"name":"PyQt5","slug":"PyQt5","permalink":"http://example.com/tags/PyQt5/"}]},{"title":"Hello World","slug":"hello-world","date":"2023-02-23T14:17:31.624Z","updated":"2023-02-06T13:37:47.659Z","comments":true,"path":"2023/02/23/hello-world/","link":"","permalink":"http://example.com/2023/02/23/hello-world/","excerpt":"hello","text":"hello Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new &quot;My New Post&quot; More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","categories":[],"tags":[]},{"title":"maven 找不到依赖项 javax.servlet:servlet-api:${servlet-api.version}","slug":"maven","date":"2023-02-23T14:17:31.624Z","updated":"2023-02-23T14:10:17.356Z","comments":true,"path":"2023/02/23/maven/","link":"","permalink":"http://example.com/2023/02/23/maven/","excerpt":"找不到依赖项 javax.servlet:servlet-api:${servlet-api.version}1.下载maven百度","text":"找不到依赖项 javax.servlet:servlet-api:${servlet-api.version}1.下载maven百度 2.maven仓库查找 https://mvnrepository.com/ 直接搜索 比如 直接搜索 然后 点击之后往下移动 找到这一行 贴到pom.xml文件里 坐标组成 配置本地仓库 中央仓库 id唯一标识符，用来区分不同的mirror元素 mirrorOf代替哪个仓库 url镜像的URL","categories":[{"name":"2023","slug":"2023","permalink":"http://example.com/categories/2023/"}],"tags":[{"name":"maven","slug":"maven","permalink":"http://example.com/tags/maven/"}]},{"title":"mysql报错ERROR 1045 (28000) Access denied for user 'root'@'localhost' (using password:NO)","slug":"mysql启动","date":"2023-02-23T14:17:31.624Z","updated":"2023-02-23T14:12:54.315Z","comments":true,"path":"2023/02/23/mysql启动/","link":"","permalink":"http://example.com/2023/02/23/mysql%E5%90%AF%E5%8A%A8/","excerpt":"ERROR 1045 (28000): Access denied for user ‘root‘@’localhost’ (using password: NO)","text":"ERROR 1045 (28000): Access denied for user ‘root‘@’localhost’ (using password: NO) E:\\jeecg\\jeecg-boot-master\\db\\jeecgboot-mysql-5.7.sql","categories":[{"name":"2023","slug":"2023","permalink":"http://example.com/categories/2023/"}],"tags":[{"name":"mysql","slug":"mysql","permalink":"http://example.com/tags/mysql/"}]},{"title":"npm install 包，没有报错，提示安装成功，但是项目中没有出现node_modules也没有安装的包","slug":"npm npm install hexo-cli -g","date":"2023-02-23T14:17:31.624Z","updated":"2023-03-01T07:07:25.030Z","comments":true,"path":"2023/02/23/npm npm install hexo-cli -g/","link":"","permalink":"http://example.com/2023/02/23/npm%20npm%20install%20hexo-cli%20-g/","excerpt":"npm install 包，没有报错，提示安装成功，但是项目中没有出现node_modules也没有安装的包1npm install hexo-cli -g","text":"npm install 包，没有报错，提示安装成功，但是项目中没有出现node_modules也没有安装的包1npm install hexo-cli -g 在当前文件夹目录下npm安装 hexo-cli -g 在当前文件夹不显示 因为这是全局安装 所以会跑到node.js文件夹目录底下 去这边找会发现一个hexo-cli的文件夹 点击这个博客[https://blog.csdn.net/qq_38613992/article/details/103769192] 查看npm的配置 1npm config list 一开始我是没有global&#x3D;？？？ 的 2.查看全局下，是否有自己安装的包 123npm root -g//获取到全局安装目录 一般看上面那个F盘的图，会在那里 3.修改npm配置信息，查看 图例1，global属性是否安装到全局，如果你的这里是true，那么，就算你安装一个包时，没有写-g，它也会自动将你的包安装到全局！ — 修改配置信息 方法一：命令行输入 123npm config set global=false，npm config set global=false 再次查看配置，确认是否修改 1npm config list 然后再 1npm install hexo-cli 后面不要-g就会在自己的文件夹里出现node_moudle了 你可以试试有-g的&#96;&#96;&#96;npm install hexo-cli&#96;&#96;，这样的话，就又会跑到node.js的global的moudle的文件夹里了 安装完成，如图","categories":[{"name":"2023","slug":"2023","permalink":"http://example.com/categories/2023/"}],"tags":[{"name":"hexo","slug":"hexo","permalink":"http://example.com/tags/hexo/"}]},{"title":"PyQt5","slug":"pyqt5","date":"2023-02-23T14:17:31.624Z","updated":"2023-02-23T14:03:21.742Z","comments":true,"path":"2023/02/23/pyqt5/","link":"","permalink":"http://example.com/2023/02/23/pyqt5/","excerpt":"安装PyQt5打开Anaconda Promt，切换到对应环境输入：","text":"安装PyQt5打开Anaconda Promt，切换到对应环境输入： 1pip install PyQt5 -i https://pypi.douban.com/simple 安装PyQt5-tools 12pip install PyQt5-tools -i https://pypi.douban.com/simple 打开 Anaconda prompt 输入: 1PyQt5-tools designer 它有很多东西 1234designerinstalluicqmlsceneqmltestrunner 不知道其他是啥（待解决） 直接点击创建（main window） 随便拖两个button上去 另存为 然后回到anaconda那个窗口， 我们要把这个.ui文件转化为py文件 方法一： 1python -m PyQt5.uic.pyuic test.ui -o test.py 要切换到相对应的文件夹路径下再运行 已经生成了 方法二： 太烦了，不写 F:\\anaconda\\EMPYTY\\pkgs\\pyqt-5.9.2-py39hd77b12b_6\\Library\\bin 大概在这个路径里面 很鸡肋，虽然写的前面的那玩意少了点，但是要吧ui移到当前文件夹里面，辣鸡 1pyuic5 test.ui -o test.py 方法三：直接使用扩展程序打开 pycharm扩展程序（vscode没找到在哪） 不太好搞（不想写，没看懂） 综上，用方法一 1.水平布局 回到vscode里面 123456789101112131415import sysimport shuipingfrom PyQt5.QtWidgets import QApplication,QMainWindow#创建QApplication类的实例app=QApplication(sys.argv)#创建一个窗口mainWindow=QMainWindow()#向主窗口添加控件ui=shuiping.Ui_MainWindow()ui.setupUi(mainWindow)# 显示窗口mainWindow.show()# 进入程序的主循环、并通过exit函数确保主循环安全结束sys.exit(app.exec_()) 表单布局 垂直布局 栅格布局 尺寸策略 伙伴关系 tab顺序 编辑信号和槽","categories":[{"name":"2022","slug":"2022","permalink":"http://example.com/categories/2022/"}],"tags":[{"name":"PyQt5","slug":"PyQt5","permalink":"http://example.com/tags/PyQt5/"}]},{"title":"之前的博客慢慢再修复，先把最近的东西放上来，sos！","slug":"breautiful","date":"2023-02-23T14:17:31.609Z","updated":"2023-02-23T13:41:12.493Z","comments":true,"path":"2023/02/23/breautiful/","link":"","permalink":"http://example.com/2023/02/23/breautiful/","excerpt":"","text":"之前的博客慢慢再修复，先把最近的东西放上来，sos！","categories":[{"name":"2023","slug":"2023","permalink":"http://example.com/categories/2023/"}],"tags":[{"name":"casual_talk","slug":"casual-talk","permalink":"http://example.com/tags/casual-talk/"}]},{"title":"Failed to scan","slug":"Failed to scan [fileFmavenrepositoryorgspringframeworkspring-aspects5","date":"2023-02-23T14:17:31.609Z","updated":"2023-02-23T13:53:39.577Z","comments":true,"path":"2023/02/23/Failed to scan [fileFmavenrepositoryorgspringframeworkspring-aspects5/","link":"","permalink":"http://example.com/2023/02/23/Failed%20to%20scan%20[fileFmavenrepositoryorgspringframeworkspring-aspects5/","excerpt":"Failed to scan [file:&#x2F;F:&#x2F;maven&#x2F;repository&#x2F;org&#x2F;springframework&#x2F;spring-aspects&#x2F;5.1.9.RELEASE&#x2F;spring-aspects-5.1.9.RELEASE.jar] from classloader hierarchyjava.util.zip.ZipException: error in opening zip file","text":"Failed to scan [file:&#x2F;F:&#x2F;maven&#x2F;repository&#x2F;org&#x2F;springframework&#x2F;spring-aspects&#x2F;5.1.9.RELEASE&#x2F;spring-aspects-5.1.9.RELEASE.jar] from classloader hierarchyjava.util.zip.ZipException: error in opening zip file 1mvn install:install-file -DgroupId=com.qiyuesuo.sdk -DartifactId=sdk-java -Dversion=3.4.1 -Dpackaging=jar -Dfile=D:\\jar\\sdk-java-3.4.1.jar 1F:\\maven\\repository\\org\\springframework\\spring-aspects\\5.1.9.RELEASE org.springframework.spring-aspects 12mvn install:install-file -DgroupId=org.springframework.spring-aspects-DartifactId=spring-aspects -Dversion=5.3.1 -Dpackaging=jar -Dfile=F:\\maven\\spring-aspects-5.3.1.jar mvn install:install-file -DgroupId&#x3D;org.springframework.spring-aspects-DartifactId&#x3D;spring-aspects -Dversion&#x3D;5.3.1 -Dpackaging&#x3D;jar -Dfile&#x3D;F:\\maven\\spring-aspects-5.3.1.jar","categories":[{"name":"2023","slug":"2023","permalink":"http://example.com/categories/2023/"}],"tags":[{"name":"maven","slug":"maven","permalink":"http://example.com/tags/maven/"}]},{"title":"C++文件操作之freopen","slug":"C++文件操作之freopen","date":"2023-02-23T14:17:31.609Z","updated":"2023-02-23T13:51:59.659Z","comments":true,"path":"2023/02/23/C++文件操作之freopen/","link":"","permalink":"http://example.com/2023/02/23/C++%E6%96%87%E4%BB%B6%E6%93%8D%E4%BD%9C%E4%B9%8Bfreopen/","excerpt":"C++文件操作之freopen","text":"C++文件操作之freopen 12freopen(&quot;xxx.in&quot;,&quot;r&quot;,stdin); //输入文件freopen(&quot;xxx.out&quot;,&quot;w&quot;,stdout); //输出文件 1234567891011121314#include&lt;cstdio&gt;#include&lt;iostream&gt;using namespace std;int main()&#123; freopen(&quot;a+b.in&quot;,&quot;r&quot;,stdin); freopen(&quot;a+b.out&quot;,&quot;w&quot;,stdout); //以上是模板 int a,b; cin&gt;&gt;a&gt;&gt;b; cout&lt;&lt;a+b&lt;&lt;endl; return 0;&#125;","categories":[{"name":"2023","slug":"2023","permalink":"http://example.com/categories/2023/"}],"tags":[{"name":"c++","slug":"c","permalink":"http://example.com/tags/c/"}]}],"categories":[{"name":"2023","slug":"2023","permalink":"http://example.com/categories/2023/"},{"name":"2022","slug":"2022","permalink":"http://example.com/categories/2022/"}],"tags":[{"name":"操作系统","slug":"操作系统","permalink":"http://example.com/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"},{"name":"casual_talk","slug":"casual-talk","permalink":"http://example.com/tags/casual-talk/"},{"name":"设计模式","slug":"设计模式","permalink":"http://example.com/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"},{"name":"django","slug":"django","permalink":"http://example.com/tags/django/"},{"name":"Spark","slug":"Spark","permalink":"http://example.com/tags/Spark/"},{"name":"python","slug":"python","permalink":"http://example.com/tags/python/"},{"name":"linux_c++","slug":"linux-c","permalink":"http://example.com/tags/linux-c/"},{"name":"java","slug":"java","permalink":"http://example.com/tags/java/"},{"name":"vmware","slug":"vmware","permalink":"http://example.com/tags/vmware/"},{"name":"mysql","slug":"mysql","permalink":"http://example.com/tags/mysql/"},{"name":"powershell","slug":"powershell","permalink":"http://example.com/tags/powershell/"},{"name":"anaconda","slug":"anaconda","permalink":"http://example.com/tags/anaconda/"},{"name":"js","slug":"js","permalink":"http://example.com/tags/js/"},{"name":"reat","slug":"reat","permalink":"http://example.com/tags/reat/"},{"name":"hexo","slug":"hexo","permalink":"http://example.com/tags/hexo/"},{"name":"PyQt5","slug":"PyQt5","permalink":"http://example.com/tags/PyQt5/"},{"name":"maven","slug":"maven","permalink":"http://example.com/tags/maven/"},{"name":"c++","slug":"c","permalink":"http://example.com/tags/c/"}]}