{"meta":{"title":"睡觉万岁","subtitle":"","description":"在梦里啥都有","author":"毛","url":"http://example.com","root":"/"},"pages":[{"title":"about","date":"2022-12-31T14:33:19.000Z","updated":"2023-03-15T10:30:14.364Z","comments":true,"path":"about/index.html","permalink":"http://example.com/about/index.html","excerpt":"","text":"欠的债迟早都要还的！~！~！~！~！ 不要急躁，静心高效做好每一件事情"},{"title":"分类","date":"2022-12-31T14:33:04.000Z","updated":"2022-12-31T14:36:05.876Z","comments":false,"path":"categories/index.html","permalink":"http://example.com/categories/index.html","excerpt":"","text":""},{"title":"资源","date":"2022-12-31T14:33:21.000Z","updated":"2022-12-31T14:37:12.176Z","comments":false,"path":"resources/index.html","permalink":"http://example.com/resources/index.html","excerpt":"","text":""},{"title":"标签","date":"2022-12-31T14:33:16.000Z","updated":"2022-12-31T14:36:40.295Z","comments":false,"path":"tags/index.html","permalink":"http://example.com/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"Python类","slug":"Python类","date":"2023-03-20T04:58:38.022Z","updated":"2023-03-20T07:04:48.617Z","comments":true,"path":"2023/03/20/Python类/","link":"","permalink":"http://example.com/2023/03/20/Python%E7%B1%BB/","excerpt":"","text":"Python类类(class) 和 对象(object)类：创建对象的模板，定义对象将会拥有的属性和函数 __init__函数：每个类必须定义的函数，对象创建语句时自动执行 123456789class myday: #建立一个类模板 def __init__(): .....day1 = myday() #创建一个myday类的对象 python类类名：mayday属性：name和emotion函数：init函数，wake函数，eat函数 1234567891011121314151617181920# 类(class)class myday: def __init__(self): #每个类必须定义(def) __init__函数，每个函数第一参数都是self self.name = &quot;Xiao Ming&quot; #myday对象拥有属性name和emotion self.emotion = &quot;happy&quot; def wake(self,event): if event == &quot;上课&quot;: self.emotion = &quot;still happy&quot; def eat(self, food): if food == &quot;牛肉&quot;: self.emotion = &quot;more happy&quot; #def __eq__(self,other): #return self.name == other.nameday2 = myday()#创建对象时会自动执行__init__方法print(day2.emotion)print(day2.name) __init__函数添加参数 创建对象时传入self之后的参数 12345678910111213141516171819class myday: def __init__(self,name,emotion): self.emotion = emotion #定义对象属性“self.emotion”，将这个属性赋值为函数传入的参数“emotion” self.name = name def wake(self,event): if event == &quot;上课&quot;: self.emotion = &quot;still happy&quot; def eat(self, food): if food == &quot;牛肉&quot;: self.emotion = &quot;more happy&quot; #def __eq__(self,other): #return self.name == other.nameday2 = myday(&quot;me&quot;,&quot;very happy&quot;)#创建对象时会自动执行__init__函数print(day2.name)print(day2.emotion) 1234567891011121314151617181920212223class myday: def __init__(self,name,emotion): self.emotion = emotion #定义对象属性“self.emotion”，将这个属性赋值为函数传入的参数“emotion” self.name = name def wake(self,event): if event == &quot;上课&quot;: self.emotion = &quot;still happy&quot; def eat(self, food): if food == &quot;牛肉&quot;: self.emotion = &quot;more happy&quot; #def __eq__(self,other): #return self.name == other.nameday2 = myday(&quot;me&quot;,&quot;very happy&quot;)#调用对象函数时，从self之后的参数开始传入day2.eat(&quot;jiaozi&quot;)print(day2.emotion)day2.eat(&quot;牛肉&quot;)print(day2.emotion) 任务：编写一个类继承myday类12345678910111213141516171819202122232425262728293031323334class myday: def __init__(self,name,emotion): self.emotion = emotion #定义对象属性“self.emotion”，将这个属性赋值为函数传入的参数“emotion” self.name = name def wake(self,event): if event == &quot;上课&quot;: self.emotion = &quot;still happy&quot; def eat(self, food): if food == &quot;牛肉&quot;: self.emotion = &quot;more happy&quot; #def __eq__(self,other): #return self.name == other.nameday2 = myday(&quot;me&quot;,&quot;very happy&quot;)#创建对象时，程序会自动执行__init__函数day2.eat(&quot;jiaozi&quot;)print(day2.emotion)day2.eat(&quot;牛肉&quot;)print(day2.emotion)#类的继承 和 函数重写class night(myday): #night类继承myday类 def __init__(self): self.emotion = &quot;nice&quot; self.name = &quot;me&quot; def play(self): self.emotion = &quot;so nice&quot;night1 = night()night1.eat(&quot;羊肉&quot;) #night继承myday类除__init__之外的函数print(night1.emotion)night1.eat(&quot;牛肉&quot;)print(night1.emotion) 一个类是否等于另一个类？1234567day1 = myday(&quot;a&quot;,&quot;happy&quot;)day2 = myday(&quot;a&quot;,&quot;happy&quot;)day1.name == day2.name #True or Falseday1 == day2 #True or False?#（如果我们在类里定义一个__eq__函数，当我们执行 day1 == day2语句的时候，程序会自动执行__eq__函数） 多线程开发案例123456789101112131415161718192021import timeimport threadingclass TestThread(threading.Thread): def __init__(self, para=&#x27;hi&#x27;, sleep=3): super().__init__() self.para = para self.sleep = sleep def run(self): &quot;&quot;&quot;线程内容&quot;&quot;&quot; time.sleep(self.sleep) print(self.para)thread_hi = TestThread()thread_hello = TestThread(&#x27;hello&#x27;, 1) # 启动线程thread_hi.start()thread_hello.start() 任务！：按照如下描述定义一个类，代表一个企业class company: init函数：定义资金（money)属性，产品(product)属性和价格（price）属性 register函数：公司注册，修改资金属性 produce函数：制造，修改资金属性，修改产品属性 sale函数：销售，修改资金属性和产品属性 research函数：研发，修改资金属性和价格属性 任务！：定义另一个类，继承company类，重写research函数（子类需要添加至少一个新的函数，并重写至少一个父类的函数。） 12345678910111213141516171819class company: def __init__(self,money,product,price) : self.money=money self.product=product self.price=price def register(self,tol_money):#注册资金 self.money=tol_money def produce(self,pro_money,product_num): self.money-=pro_money#生产就减少了 self.product+=product_num#产品多了 def sale(self,sal_money,product_num): self.money+=sal_money#钱多了 self.product-=product_num#产品减少了 def research(self,re_money,re_price): self.money-=re_money#钱减少了 self.price+=re_price#价格上去了company1=company(&quot;1000&quot;,&quot;机器&quot;,&quot;100/2&quot;)company1.register(&quot;5000&quot;)print(company1.money) research函数：研发，修改资金属性和价格属性，产品属性 invert函数:投资，修改金钱属性 12345678910111213141516class BigCompany(company): def __init__(self,money,product,price): super().__init__(money,product,price) def research(self,re_money,re_price,re_prodcut): self.money=re_money#钱减少了 self.price+=re_price#价格上去了 self.product+=re_prodcut#产品多了 def inverst(self,invstment_money): self.money-=invstment_moneycompany2=BigCompany(7000,2,50)company2.research(8000,80,90)company2.inverst(908070)print(company2.money)","categories":[{"name":"2023","slug":"2023","permalink":"http://example.com/categories/2023/"}],"tags":[{"name":"python","slug":"python","permalink":"http://example.com/tags/python/"}]},{"title":"如何在Linux系统下编译C++","slug":"如何在Linux系统下编译C++","date":"2023-03-17T13:50:45.280Z","updated":"2023-03-17T14:05:29.847Z","comments":true,"path":"2023/03/17/如何在Linux系统下编译C++/","link":"","permalink":"http://example.com/2023/03/17/%E5%A6%82%E4%BD%95%E5%9C%A8Linux%E7%B3%BB%E7%BB%9F%E4%B8%8B%E7%BC%96%E8%AF%91C++/","excerpt":"","text":"如何在Linux系统下编译C++方法一:12345678#include&lt;iostream&gt;#include&lt;cstdio&gt;using namespace std;int main()&#123; cout&lt;&lt;&quot;hello_word&quot;; return 0;&#125; 编译 1gcc 1.cpp -lstdc++ 生a.out文件 运行a.out 1./a.out 方法二:12345678#include&lt;iostream&gt;#include&lt;cstdio&gt;using namespace std;int main()&#123; cout&lt;&lt;&quot;hello_word222&quot;; return 0;&#125; 编译 1g++ 2.cpp -o 2output 运行2output 1./2output","categories":[{"name":"2023","slug":"2023","permalink":"http://example.com/categories/2023/"}],"tags":[{"name":"linux_c++","slug":"linux-c","permalink":"http://example.com/tags/linux-c/"}]},{"title":"","slug":"进程同步","date":"2023-03-17T03:21:38.374Z","updated":"2023-03-17T14:28:50.527Z","comments":true,"path":"2023/03/17/进程同步/","link":"","permalink":"http://example.com/2023/03/17/%E8%BF%9B%E7%A8%8B%E5%90%8C%E6%AD%A5/","excerpt":"","text":"123title: 如何在Linux系统下编译C++tag: linux_c++categories: 2023 进程同步 pv 操作 互斥锁 1234P --wait(信号量S)&#123; S&lt;=0 S-- //上锁&#125; 成对出现 123V --signal(信号量)&#123; S++ //开锁&#125; 生产者 123456789101112131415int in(),out=();item butter[n];semaphore mutex=1,empty=n,full=();//mutex必须为1 ,empty空位置,full有多少个void proceducer()&#123; do&#123; producer an item nextp; …… wait(empty); //enpty-- wait(mutex); //上锁 butter[in]=nextp; //生产一个 in:=(in+1)%n; // 生产一个 signal(mutex); //解锁 signal(full); //full++ &#125;while(TRUE)；&#125; 消费者 1234567891011void consumer()&#123; do&#123; wait(full)； //full-1 wait(mutex); //上锁 nextc=butter[out]; //消费一个 out=(out+1)%n; //消费一个 signal(mutex); //解锁 signal(empty); //empty++ consumer the item in nextc; &#125;while(TRUE);&#125; 12345void main()&#123; cobegin proceducer();consumer(); coend&#125; 第1关：生产者消费者同步控制任务描述本关任务：编写生产者消费者同步控制程序。 相关知识为了完成本关任务，你需要掌握：1.理解生产者消费者同步问题，2.线程的编写方法，3.使用信号量实现线程间同步控制。 线程并发引起的同步问题线程以并发形式运行，当并发的线程间访问共享数据时，会发后争用现象，不进行同步控制的线程运行会造成不恰当的结果。 生产者消费者同步问题生产者消费者是典型的同步问题，他们共享了一个缓冲池(全局变量数组)，当缓冲池有空位时生产者线程向缓冲池中依次赋值，如果缓冲池满则等待。当缓冲池中有数据时消费者线程从中取走数据，如果缓冲池空则等待。 如何解决线程间访问共享变量的冲突问题当多个线程访问同一个共享变量时，共享变量成为临界资源，它需要操作系统提供同步控制机制，以保证多个线程可以依序访问，当一个线程操作临界资源时其它线程不会中断其操作，因此对临界资源的操作是安全的。 下面是linux平台使用信号量的头文件和方法。 #include &lt;semaphore.h&gt; int sem_init(sem_t * sem, int pshared, unsigned int value);&#x2F;&#x2F;创建信号量变量，value是信号量的初值 int sem_destroy(sem_t *sem);&#x2F;&#x2F;销毁信号量 int sem_post(sem_t * sem); &#x2F;&#x2F;信号量值增加1，并激活处于等待状态的线程 int sem_wait(sem_t * sem); &#x2F;&#x2F;信号量值减少1 为0时将调用该方法的线程被OS阻塞 编程要求主线程序启动生产者线程和消费者线程，并等待两个线程的结束。 两个线程使用三个信号量，其中生产者线程向全局变量进行十次赋值(代表生产)，每次赋值前都要检查是否有空位，有空位的情况下 需要获得互斥量sem_mutex，并对共享缓冲区进行赋值，然后释放互斥量以便消费者线程可以操作缓冲区临界资源。 消费者线程要从缓冲区取值，取值前先检查是否有可用数据，有可用数据的情况下再获得互斥量sem_mutex，再取出缓冲区的值。 要特别说明的是生产者和消费者线程工作的速率是不同的，但在同步信号控制下，两个线程节奏互相配合步调一致。在《计算机操作系统》 教材中使用了伪代码，并且循环体没有结束条件，在此用C语言改写原程序，生产者一共只生产十个数据。 ####测试说明 为简化数据操作，程序没有输入，主线程已经写好， void * producer(void * arg); void * consumer(void * arg); static sem_t sem_empty;&#x2F;&#x2F;空位个数 static sem_t sem_full; &#x2F;&#x2F;可用数据个数 static sem_t sem_mutex; &#x2F;&#x2F;互斥量，用于控制两个线程互斥访问缓冲区 static int buffer[]&#x3D;{0,0,0}; int main(int argc,char * argv[]) { pthread_t id_prod,id_consum; sem_init(&amp;sem_empty,0,3); &#x2F;&#x2F;初值为3，空位为3， sem_init(&amp;sem_full,0,0); &#x2F;&#x2F;初值为0，可用数据个数为0， sem_init(&amp;sem_mutex,0,1); &#x2F;&#x2F;初值为1，用于控制两个线程互斥访问缓冲区 pthread_create(&amp;id_prod, NULL,producer,NULL);&#x2F;&#x2F;创建生产者线程 pthread_create(&amp;id_consum,NULL,consumer,NULL);&#x2F;&#x2F;创建消费者线程 pthread_join(id_prod,NULL); &#x2F;&#x2F;主线程等待生产者线程结束 pthread_join(id_consum,NULL);&#x2F;&#x2F;主线程等待消费者线程结束 sem_destroy(&amp;sem_empty); sem_destroy(&amp;sem_full); sem_destroy(&amp;sem_mutex); return 0; } 学生需要补充producer线程与consumer中关于同步控制部分的程序。 输出：1至10 (需由学生根据程序生成正确结果) 开始你的任务吧，祝你成功！ 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667//stu001.c 生产者消费者同步控制，由学生完成缺失代码。 //主线程序启动生产者线程和消费者线程，全局变量初值为0//生产者线程向全局变量进行10次赋值(代表生产)，消费者线程从全局变量读取值，///并重新赋值0(代表消费了产品)#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt; #include &lt;pthread.h&gt;#include &lt;semaphore.h&gt; void * producer(void * arg);void * consumer(void * arg);static sem_t sem_empty;//空位个数static sem_t sem_full; //可用数据个数static sem_t sem_mutex; //互斥量，用于控制两个线程互斥访问缓冲区static int buffer[]=&#123;0,0,0&#125;;//共享的缓冲区int main(int argc,char * argv[])&#123; pthread_t id_prod,id_consum; sem_init(&amp;sem_empty,0,3); //初值为3，空位为3， sem_init(&amp;sem_full,0,0); //初值为0，可用数据个数为0， sem_init(&amp;sem_mutex,0,1); //初值为1，用于控制两个线程互斥访问缓冲区 pthread_create(&amp;id_prod, NULL,producer,NULL);//创建生产者线程 pthread_create(&amp;id_consum,NULL,consumer,NULL);//创建消费者线程 pthread_join(id_prod,NULL); //主线程等待生产者线程结束 pthread_join(id_consum,NULL);//主线程等待消费者线程结束 sem_destroy(&amp;sem_empty); sem_destroy(&amp;sem_full); sem_destroy(&amp;sem_mutex); return 0;&#125;void * producer(void * arg)&#123; int i,pIndex=0; for(i=11;i&lt;21;i++) &#123; //请在begin end语句间补全程序语句实现生产者向缓冲区赋值操作 /* begin *******************程序代码约六行******************************* */ sem_wait(&amp;sem_empty);//empty-- sem_wait(&amp;sem_mutex); //枷锁 buffer[pIndex]=i; //缓冲区只有三个位置 pIndex=(pIndex+1)%3;// 11-- 0 12--1 13--2 14--0 15--1 16--2 sem_post(&amp;sem_mutex);//解锁 sem_post(&amp;sem_full);//full++ /* end ************************************************************** */ &#125; return NULL;&#125;void * consumer(void *arg)&#123; int i,cIndex=0; for(i=11;i&lt;21;i++) &#123; //请在begin end语句间补全程序语句实现扫描算法，算出总访问磁道数存入totaltracks变量 /* begin *******************程序代码约六行******************************* */ sem_wait(&amp;sem_full);//full-- sem_wait(&amp;sem_mutex);//枷锁 printf(&quot;%d,&quot;,buffer[cIndex]); cIndex=(cIndex+1)%3;//与上面对应 sem_post(&amp;sem_mutex);//解锁 sem_post(&amp;sem_empty);//empty++ /* end ************************************************************** */ &#125; return NULL;&#125; 参考Linux下c++的东西 https://man7.org/linux/man-pages/man3/sem_wait.3.html 123sem_wait是一个函数，也是一个原子操作，它的作用是从信号量的值减去一个“1”，但它永远会先等待该信号量为一个非零值才开始做减法。也就是说，如果你对一个值为2的信号量调用sem_wait()，线程将会继续执行，将信号量的值将减到1。如果对一个值为0的信号量调用sem_wait()，这个函数就会原地等待直到有其它线程增加了这个值使它不再是0为止。如果有两个线程都在sem_wait()中等待同一个信号量变成非零值，那么当它被第三个线程增加 一个“1”时，等待线程中只有一个能够对信号量做减法并继续执行，另一个还将处于等待状态。sem_trywait(sem_t *sem)是函数sem_wait的非阻塞版，它直接将信号量sem减1，同时返回错误代码。(不得不说，百度确实蛮会复制粘贴翻译的，只不过没有那个网站格式做的好hhh) 1sem_post是给信号量的值加上一个“1”，它是一个“原子操作”－－－即同时对同一个信号量做加“1”操作的两个线程是不会冲突的；而同 时对同一个文件进行读和写操作的两个程序就有可能会引起冲突。 1sem_t C语言中，信号量的数据类型为结构sem_t，它本质上是一个长整型的数。 https://blog.51cto.com/u_13999641/4314815 没看完【argc，argv是什么】 真的忘的差不多了0.0","categories":[],"tags":[]},{"title":"java数据类型","slug":"java数据类型","date":"2023-03-16T14:06:57.039Z","updated":"2023-03-17T14:28:56.778Z","comments":true,"path":"2023/03/16/java数据类型/","link":"","permalink":"http://example.com/2023/03/16/java%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/","excerpt":"","text":"Java数据类型定义Java语言是强类型语言，对于每一种数据都定义了明确的具体的数据类型，在内存中分配了不同大小的内存空间。 分类 基本数据类型 数值型 整数类型(byte,short,int,long) 浮点类型(float,double) 字符型(char) 布尔型(boolean) 引用数据类型 类(class) 接口(interface) 数组([]) 计算机存储单元 定义：变量是内存中的小容器，用来存储数据。那么计算机内存是怎么存储数据的呢？无论是内存还是硬盘，计算机存储设备的最小信息单元叫“位（bit）”，我们又称之为“比特位”，通常用小写的字母b表示。而计算机最小的存储单元叫“字节（byte）”，通常用大写字母B表示，字节是由连续的8个位组成。 常用存储单元关系 1B&#x3D; 8b1KB &#x3D; 1024B1MB &#x3D; 1024KB1GB &#x3D; 1024MB1TB &#x3D; 1024GB Java基本数据类型图 定义 数据类型的转换是在所赋值的数值类型和被变量接收的数据类型不一致时发生的，它需要从一种数据类型转换成另一种数据类型。 分类 隐式转换 定义 在运算过程中，由于不同的数据类型会转换成同一种数据类型，所以整型、浮点型以及字符型都可以参与混合运算。自动转换的规则是从低级类型数据转换成高级类型数据。 转换规则 数值型数据的转换：byte→short→int→long→float→double。 字符型转换为整型：char→int。 转换条件 自动类型转换的实现需要同时满足两个条件：①两种数据类型彼此兼容，②目标类型的取值范围大于源数据类型（低级类型数据转换成高级类型数据）。例如 byte 类型向 short 类型转换时，由于 short 类型的取值范围较大，会自动将 byte 转换为 short 类型。 显式转换 定义 当两种数据类型不兼容，或目标类型的取值范围小于源类型时，自动转换将无法进行，这时就需要进行强制类型转换。 语法格式 目标类型 变量名 &#x3D; (目标类型) (被转换的数据);举例：int b &#x3D; (byte)(a + b); 注意 如果超出了被赋值的数据类型的取值范围得到的结果会与你期望的结果不同 不建议强制转换，因为会有精度的损失。","categories":[{"name":"202","slug":"202","permalink":"http://example.com/categories/202/"}],"tags":[{"name":"java","slug":"java","permalink":"http://example.com/tags/java/"}]},{"title":"3-15-2023","slug":"3-15-2023","date":"2023-03-15T14:51:14.942Z","updated":"2023-03-15T14:59:29.047Z","comments":true,"path":"2023/03/15/3-15-2023/","link":"","permalink":"http://example.com/2023/03/15/3-15-2023/","excerpt":"三月中自我崩溃","text":"三月中自我崩溃 1.每日单词 考试周，复习无进展，极度自我焦虑, 看的上海的学校今年分数下来了， 崩溃，高了40分，崩溃,换学校， 觉得三年青春换水硕不值 转战留学","categories":[{"name":"2023","slug":"2023","permalink":"http://example.com/categories/2023/"}],"tags":[{"name":"casual_talk","slug":"casual-talk","permalink":"http://example.com/tags/casual-talk/"}]},{"title":"设计模式homework(1)","slug":"设计模式homework(1)","date":"2023-03-15T09:56:02.491Z","updated":"2023-03-17T14:29:00.672Z","comments":true,"path":"2023/03/15/设计模式homework(1)/","link":"","permalink":"http://example.com/2023/03/15/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8Fhomework(1)/","excerpt":"","text":"2023_Week1_Exp_Upload1. (简答题)用 UMLet 工具对下面代码绘制类图 ![]img](&#x2F;images&#x2F;设计模式&#x2F;5.png) 【关联关系】：是一种拥有的关系，它使一个类知道另一个类的属性和方法 【代码体现】：成员变量 【箭头及指向】：带普通箭头的实心线，指向被拥有者 1.上图中，课程与学生是双向关联，课程有多名学生，学生也可能有多个课程。 2.但学生与成绩间的关系为单向关联，一名学生可能要有多门成绩，成绩有学生信息，但学生类不拥有成绩变量 3.【组合关系】：是整体与部分的关系，但部分不能离开整体而单独存在。如公司和部门是整体和部分的关系，没有公司就不存在部门。 组合关系是关联关系的一种，是比聚合关系还要强的关系，它要求普通的聚合关系中代表整体的对象负责代表部分的对象的生命周期。 【代码体现】：成员变量 【箭头及指向】：带实心菱形的实线，菱形指向整体 上图中课程为整体，成绩没有课程就不存在。 4.【依赖关系】：是一种使用的关系，即一个类的实现需要另一个类的协助，所以要尽量不使用双向的互相依赖. 【代码表现】：局部变量、方法的参数或者对静态方法的调用 【箭头及指向】：带箭头的虚线，指向被使用者 一个宿舍类的实现需要另一个学生类的协助，宿舍是被使用者","categories":[{"name":"2023","slug":"2023","permalink":"http://example.com/categories/2023/"}],"tags":[{"name":"设计模式","slug":"设计模式","permalink":"http://example.com/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"}]},{"title":"UML&&面向对象设计原则","slug":"UML类图&&原则概述","date":"2023-03-15T09:32:42.087Z","updated":"2023-03-15T09:33:49.550Z","comments":true,"path":"2023/03/15/UML类图&&原则概述/","link":"","permalink":"http://example.com/2023/03/15/UML%E7%B1%BB%E5%9B%BE&&%E5%8E%9F%E5%88%99%E6%A6%82%E8%BF%B0/","excerpt":"","text":"一、单一职责原则**就一个类而言，应该仅有一个引起它变化的原因。 如果一个类承担的职责过多，就等于把这些职责耦合在一起，一个职责的变化可能会削弱或者抑制这个类完成其他职责的能力。这种耦合会导致脆弱他的设计，当变化发生时，设计会遭受到意想不到的破坏；软件设计真正要做的许多内容就是发现职责并把那些职责相互分离。 二、开放-封闭原则软件实体应该可以扩展，但不可修改。该原则是面向对象设计的核心所在，遵循这个原则可以带来面向对象技术所声称的可维护、可扩展、可复用、灵活性好。 设计人员必须对于他设计的模块应该对哪种变化封闭做出选择，必须先猜测出最有可能发生的变化种类，然后构造抽象来隔离那些变化。最初编写程序时假设变化不会发生，当变化发生时，就创建抽象来隔离以后发生的同类变化，拒绝不成熟的抽象。 三、里氏代换原则子类型必须能够替换掉它们的父类型。由于子类型的可替换性才使得使用父类类型的模块在无需修改的情况下就可以扩展。 四、依赖倒转原则高层模块不应该依赖低层模块，两个都应该依赖抽象；抽象不应该依赖细节，细节应该依赖抽象。 要针对接口编程，不要针对实现编程。该原则可以说是面向对象设计的标志，编写时考虑的是如何对抽象编程而不是针对细节编程，即程序中所有的依赖关系都是终止于抽象类或者接口。 五、迪迷特原则（最少知识原则）如果两个类不必彼此直接通信，那么这两个类就不应当发生直接的相互作用；如果其中一个类需要调用另一个类的某一个方法的话，可以通过第三者转发这个调用。 该原则其根本思想，是强调了类之间的松耦合；类之间的耦合越弱，越利于复用，一个处在弱耦合的类被修改，不会对有关系的类造成波及。在类的结构设计上，每一个类都应当尽量降低成员的访问权限。 六、合成&#x2F;聚合复用原则尽量使用合成&#x2F;聚合，尽量不要使用类继承。 聚合表示一种弱的“拥有”关系，体现的是A对象可以包含B对象，但B对象不是A对象的一部分；合成则是一种强的“拥有”关系，体现了严格的部分和整体的关系，部分和整体的生命周期一样。 优先使用对象的合成&#x2F;聚合将有助于你保持每个类被封装，并被击中在单个任务上，这样类和类继承层次会保持较小规模，并且不太可能增长为不可控制的庞然大物。 七、UML例图‘+’表示public，‘-’表示private，‘#’表示protected； 接口顶端有《interface》显示，只有两行；同时另一个表示方法为棒棒糖表示法； 聚合表示一种弱的’拥有’关系，体现的是A对象可以包含B对象，但B对象不是A对象的一部分； 合成是一种强的’拥有’关系，体现了严格的部分和整体的关系，部分和整体的生命周期一样； 在UML类图中，常见的有以下几种关系: 泛化（Generalization）, 实现（Realization），关联（Association)，聚合（Aggregation），组合(Composition)，依赖(Dependency) 1. 泛化（Generalization）【泛化关系】：是一种继承关系，表示一般与特殊的关系，它指定了子类如何特化父类的所有特征和行为。例如：老虎是动物的一种，即有老虎的特性也有动物的共性。 【箭头指向】：带三角箭头的实线，箭头指向父类 2. 实现（Realization）【实现关系】：是一种类与接口的关系，表示类是接口所有特征和行为的实现. 【箭头指向】：带三角箭头的虚线，箭头指向接口 3. 关联（Association)【关联关系】：是一种拥有的关系，它使一个类知道另一个类的属性和方法；如：老师与学生，丈夫与妻子关联可以是双向的，也可以是单向的。双向的关联可以有两个箭头或者没有箭头，单向的关联有一个箭头。 【代码体现】：成员变量 【箭头及指向】：带普通箭头的实心线，指向被拥有者 上图中，老师与学生是双向关联，老师有多名学生，学生也可能有多名老师。但学生与某课程间的关系为单向关联，一名学生可能要上多门课程，课程是个抽象的东西他不拥有学生。 下图为自身关联： 4. 聚合（Aggregation）【聚合关系】：是整体与部分的关系，且部分可以离开整体而单独存在。如车和轮胎是整体和部分的关系，轮胎离开车仍然可以存在。 聚合关系是关联关系的一种，是强的关联关系；关联和聚合在语法上无法区分，必须考察具体的逻辑关系。 【代码体现】：成员变量 【箭头及指向】：带空心菱形的实心线，菱形指向整体 5. 组合(Composition)【组合关系】：是整体与部分的关系，但部分不能离开整体而单独存在。如公司和部门是整体和部分的关系，没有公司就不存在部门。 组合关系是关联关系的一种，是比聚合关系还要强的关系，它要求普通的聚合关系中代表整体的对象负责代表部分的对象的生命周期。 【代码体现】：成员变量 【箭头及指向】：带实心菱形的实线，菱形指向整体 6. 依赖(Dependency)【依赖关系】：是一种使用的关系，即一个类的实现需要另一个类的协助，所以要尽量不使用双向的互相依赖. 【代码表现】：局部变量、方法的参数或者对静态方法的调用 【箭头及指向】：带箭头的虚线，指向被使用者 各种关系的强弱顺序： 泛化 &#x3D; 实现 &gt; 组合 &gt; 聚合 &gt; 关联 &gt; 依赖 下面这张UML图，比较形象地展示了各种类图关系： 创建型1. Factory Method（工厂方法） 意图： 定义一个用于创建对象的接口，让子类决定实例化哪一个类。Factory Method 使一个类的实例化延迟到其子类。 适用性： 当一个类不知道它所必须创建的对象的类的时候。 当一个类希望由它的子类来指定它所创建的对象的时候。 当类将创建对象的职责委托给多个帮助子类中的某一个，并且你希望将哪一个帮助子类是代理者这一信息局部化的时候。 详解：设计模式是什么鬼（工厂方法） 2. Abstract Factory（抽象工厂） 意图： 提供一个创建一系列相关或相互依赖对象的接口，而无需指定它们具体的类。 适用性： 一个系统要独立于它的产品的创建、组合和表示时。 一个系统要由多个产品系列中的一个来配置时。 当你要强调一系列相关的产品对象的设计以便进行联合使用时。 当你提供一个产品类库，而只想显示它们的接口而不是实现时。 详解：设计模式是什么鬼（抽象工厂） 3. Builder（建造者） 意图： 将一个复杂对象的构建与它的表示分离，使得同样的构建过程可以创建不同的表示。 适用性： 当创建复杂对象的算法应该独立于该对象的组成部分以及它们的装配方式时。 当构造过程必须允许被构造的对象有不同的表示时。 详解：设计模式是什么鬼（建造者） 4. Prototype（原型） 意图： 用原型实例指定创建对象的种类，并且通过拷贝这些原型创建新的对象。 适用性： 当要实例化的类是在运行时刻指定时，例如，通过动态装载；或者 为了避免创建一个与产品类层次平行的工厂类层次时；或者 当一个类的实例只能有几个不同状态组合中的一种时。建立相应数目的原型并克隆它们可能比每次用合适的状态手工实例化该类更方便一些。 详解：设计模式是什么鬼（原型） 5. Singleton（单例） 意图： 保证一个类仅有一个实例，并提供一个访问它的全局访问点。 适用性： 当类只能有一个实例而且客户可以从一个众所周知的访问点访问它时。 当这个唯一实例应该是通过子类化可扩展的，并且客户应该无需更改代码就能使用一个扩展的实例时。 详解：设计模式是什么鬼（单例） 结构型6. Adapter Class&#x2F;Object（适配器） 意图： 将一个类的接口转换成客户希望的另外一个接口。Adapter 模式使得原本由于接口不兼容而不能一起工作的那些类可以一起工作。 适用性： 你想使用一个已经存在的类，而它的接口不符合你的需求。 你想创建一个可以复用的类，该类可以与其他不相关的类或不可预见的类（即那些接口可能不一定兼容的类）协同工作。 （仅适用于对象Adapter ）你想使用一些已经存在的子类，但是不可能对每一个都进行子类化以匹配它们的接口。对象适配器可以适配它的父类接口。 详解：设计模式是什么鬼（适配器） 7. Bridge（桥接） 意图： 将抽象部分与它的实现部分分离，使它们都可以独立地变化。 适用性： 你不希望在抽象和它的实现部分之间有一个固定的绑定关系。例如这种情况可能是因为，在程序运行时刻实现部分应可以被选择或者切换。 类的抽象以及它的实现都应该可以通过生成子类的方法加以扩充。这时Bridge 模式使你可以对不同的抽象接口和实现部分进行组合，并分别对它们进行扩充。 对一个抽象的实现部分的修改应对客户不产生影响，即客户的代码不必重新编译。 （C++）你想对客户完全隐藏抽象的实现部分。在C++中，类的表示在类接口中是可见的。 有许多类要生成。这样一种类层次结构说明你必须将一个对象分解成两个部分。Rumbaugh 称这种类层次结构为“嵌套的普化”（nested generalizations ）。 你想在多个对象间共享实现（可能使用引用计数），但同时要求客户并不知道这一点。一个简单的例子便是Coplien 的String 类[ Cop92 ]，在这个类中多个对象可以共享同一个字符串表示（StringRep ）。 详解：设计模式是什么鬼（桥接） 8. Composite（组合） 意图： 将对象组合成树形结构以表示“部分-整体”的层次结构。C o m p o s i t e 使得用户对单个对象和组合对象的使用具有一致性。 适用性： 你想表示对象的部分-整体层次结构。 你希望用户忽略组合对象与单个对象的不同，用户将统一地使用组合结构中的所有对象。 详解：设计模式是什么鬼（组合） 9. Decorator（装饰） 意图： 动态地给一个对象添加一些额外的职责。就增加功能来说，Decorator 模式相比生成子类更为灵活。 适用性： 在不影响其他对象的情况下，以动态、透明的方式给单个对象添加职责。 处理那些可以撤消的职责。 当不能采用生成子类的方法进行扩充时。一种情况是，可能有大量独立的扩展，为支持每一种组合将产生大量的子类，使得子类数目呈爆炸性增长。另一种情况可能是因为类定义被隐藏，或类定义不能用于生成子类。 详解：设计模式是什么鬼（装饰） 10. Facade（外观） 意图： 为子系统中的一组接口提供一个一致的界面，Facade模式定义了一个高层接口，这个接口使得这一子系统更加容易使用。 适用性： 当你要为一个复杂子系统提供一个简单接口时。子系统往往因为不断演化而变得越来越复杂。大多数模式使用时都会产生更多更小的类。这使得子系统更具可重用性，也更容易对子系统进行定制，但这也给那些不需要定制子系统的用户带来一些使用上的困难。Facade 可以提供一个简单的缺省视图，这一视图对大多数用户来说已经足够，而那些需要更多的可定制性的用户可以越过facade层。 客户程序与抽象类的实现部分之间存在着很大的依赖性。引入facade 将这个子系统与客户以及其他的子系统分离，可以提高子系统的独立性和可移植性。 当你需要构建一个层次结构的子系统时，使用facade模式定义子系统中每层的入口点。如果子系统之间是相互依赖的，你可以让它们仅通过facade进行通讯，从而简化了它们之间的依赖关系。 详解：设计模式是什么鬼（门面） 11. Flyweight（享元） 意图： 运用共享技术有效地支持大量细粒度的对象。 适用性： 一个应用程序使用了大量的对象。 完全由于使用大量的对象，造成很大的存储开销。 对象的大多数状态都可变为外部状态。 如果删除对象的外部状态，那么可以用相对较少的共享对象取代很多组对象。 应用程序不依赖于对象标识。由于Flyweight 对象可以被共享，对于概念上明显有别的对象，标识测试将返回真值。 详解：设计模式是什么鬼（享元） 12. Proxy（代理） 意图： 为其他对象提供一种代理以控制对这个对象的访问。 适用性： 在需要用比较通用和复杂的对象指针代替简单的指针的时候，使用Proxy模式。下面是一 些可以使用Proxy 模式常见情况： 远程代理（Remote Proxy ）为一个对象在不同的地址空间提供局部代表。NEXTSTEP[Add94] 使用NXProxy 类实现了这一目的。Coplien[Cop92] 称这种代理为“大使” （Ambassador ）。 虚代理（Virtual Proxy ）根据需要创建开销很大的对象。在动机一节描述的ImageProxy 就是这样一种代理的例子。 保护代理（Protection Proxy ）控制对原始对象的访问。保护代理用于对象应该有不同 的访问权限的时候。例如，在Choices 操作系统[ CIRM93]中KemelProxies为操作系统对象提供 了访问保护。 智能指引（Smart Reference ）取代了简单的指针，它在访问对象时执行一些附加操作。它的典型用途包括： 对指向实际对象的引用计数，这样当该对象没有引用时，可以自动释放它(也称为SmartPointers[Ede92 ] )。 当第一次引用一个持久对象时，将它装入内存。 在访问一个实际对象前，检查是否已经锁定了它，以确保其他对象不能改变它。 详解：设计模式是什么鬼（代理） 行为型13. Interpreter（解释器） 意图： 给定一个语言，定义它的文法的一种表示，并定义一个解释器，这个解释器使用该表示来解释语言中的句子。 适用性： 当有一个语言需要解释执行, 并且你可将该语言中的句子表示为一个抽象语法树时，可使用解释器模式。而当存在以下情况时该模式效果最好： 该文法简单对于复杂的文法, 文法的类层次变得庞大而无法管理。此时语法分析程序生成器这样的工具是更好的选择。它们无需构建抽象语法树即可解释表达式, 这样可以节省空间而且还可能节省时间。 效率不是一个关键问题最高效的解释器通常不是通过直接解释语法分析树实现的, 而是首先将它们转换成另一种形式。例如，正则表达式通常被转换成状态机。但即使在这种情况下, 转换器仍可用解释器模式实现, 该模式仍是有用的。 详解：设计模式是什么鬼（解释器） 14. Template Method（模板方法） 意图： 定义一个操作中的算法的骨架，而将一些步骤延迟到子类中。TemplateMethod 使得子类可以不改变一个算法的结构即可重定义该算法的某些特定步骤。 适用性： 一次性实现一个算法的不变的部分，并将可变的行为留给子类来实现。 各子类中公共的行为应被提取出来并集中到一个公共父类中以避免代码重复。这是Opdyke 和Johnson 所描述过的“重分解以一般化”的一个很好的例子[ OJ93 ]。首先识别现有代码中的不同之处，并且将不同之处分离为新的操作。最后，用一个调用这些新的操作的模板方法来替换这些不同的代码。 控制子类扩展。模板方法只在特定点调用“hook ”操作（参见效果一节），这样就只允许在这些点进行扩展。 详解：设计模式是什么鬼（模板方法） 15. Chain of Responsibility（责任链） 意图： 使多个对象都有机会处理请求，从而避免请求的发送者和接收者之间的耦合关系。将这些对象连成一条链，并沿着这条链传递该请求，直到有一个对象处理它为止。 适用性： 有多个的对象可以处理一个请求，哪个对象处理该请求运行时刻自动确定。 你想在不明确指定接收者的情况下，向多个对象中的一个提交一个请求。 可处理一个请求的对象集合应被动态指定。 详解：设计模式是什么鬼（责任链） 16. Command（命令） 意图： 将一个请求封装为一个对象，从而使你可用不同的请求对客户进行参数化；对请求排队或记录请求日志，以及支持可撤消的操作。 适用性： 抽象出待执行的动作以参数化某对象，你可用过程语言中的回调（call back）函数表达这种参数化机制。所谓回调函数是指函数先在某处注册，而它将在稍后某个需要的时候被调用。Command 模式是回调机制的一个面向对象的替代品。 在不同的时刻指定、排列和执行请求。一个Command对象可以有一个与初始请求无关的生存期。如果一个请求的接收者可用一种与地址空间无关的方式表达，那么就可将负责该请求的命令对象传送给另一个不同的进程并在那儿实现该请求。 支持取消操作。Command的Excute 操作可在实施操作前将状态存储起来，在取消操作时这个状态用来消除该操作的影响。Command 接口必须添加一个Unexecute操作，该操作取消上一次Execute调用的效果。执行的命令被存储在一个历史列表中。可通过向后和向前遍历这一列表并分别调用Unexecute和Execute来实现重数不限的“取消”和“重做”。 支持修改日志，这样当系统崩溃时，这些修改可以被重做一遍。在Command接口中添加装载操作和存储操作，可以用来保持变动的一个一致的修改日志。从崩溃中恢复的过程包括从磁盘中重新读入记录下来的命令并用Execute操作重新执行它们。 用构建在原语操作上的高层操作构造一个系统。这样一种结构在支持事务( transaction)的信息系统中很常见。一个事务封装了对数据的一组变动。Command模式提供了对事务进行建模的方法。Command有一个公共的接口，使得你可以用同一种方式调用所有的事务。同时使用该模式也易于添加新事务以扩展系统。 详解：设计模式是什么鬼（命令模式） 17. Iterator（迭代器） 意图： 提供一种方法顺序访问一个聚合对象中各个元素, 而又不需暴露该对象的内部表示。 适用性： 访问一个聚合对象的内容而无需暴露它的内部表示。 支持对聚合对象的多种遍历。 为遍历不同的聚合结构提供一个统一的接口(即, 支持多态迭代)。 详解：设计模式是什么鬼（迭代器） 18. Mediator（中介者） 意图： 用一个中介对象来封装一系列的对象交互。中介者使各对象不需要显式地相互引用，从而使其耦合松散，而且可以独立地改变它们之间的交互。 适用性： 一组对象以定义良好但是复杂的方式进行通信。产生的相互依赖关系结构混乱且难以理解。 一个对象引用其他很多对象并且直接与这些对象通信,导致难以复用该对象。 想定制一个分布在多个类中的行为，而又不想生成太多的子类。 详解：设计模式是什么鬼（中介） 19. Memento（备忘录） 意图： 在不破坏封装性的前提下，捕获一个对象的内部状态，并在该对象之外保存这个状态。这样以后就可将该对象恢复到原先保存的状态。 适用性： 必须保存一个对象在某一个时刻的(部分)状态, 这样以后需要时它才能恢复到先前的状态。 如果一个用接口来让其它对象直接得到这些状态，将会暴露对象的实现细节并破坏对象的封装性。 详解：设计模式是什么鬼（备忘录） 20. Observer（观察者） 意图： 定义对象间的一种一对多的依赖关系,当一个对象的状态发生改变时, 所有依赖于它的对象都得到通知并被自动更新。 适用性： 当一个抽象模型有两个方面, 其中一个方面依赖于另一方面。将这二者封装在独立的对象中以使它们可以各自独立地改变和复用。 当对一个对象的改变需要同时改变其它对象, 而不知道具体有多少对象有待改变。 当一个对象必须通知其它对象，而它又不能假定其它对象是谁。换言之, 你不希望这些对象是紧密耦合的。 详解：设计模式是什么鬼（观察者） 21. State（状态） 意图： 允许一个对象在其内部状态改变时改变它的行为。对象看起来似乎修改了它的类。 适用性： 一个对象的行为取决于它的状态, 并且它必须在运行时刻根据状态改变它的行为。 一个操作中含有庞大的多分支的条件语句，且这些分支依赖于该对象的状态。这个状态通常用一个或多个枚举常量表示。通常, 有多个操作包含这一相同的条件结构。State模式将每一个条件分支放入一个独立的类中。这使得你可以根据对象自身的情况将对象的状态作为一个对象，这一对象可以不依赖于其他对象而独立变化。 详解：设计模式是什么鬼（状态） 22. Strategy（策略） 意图： 定义一系列的算法,把它们一个个封装起来, 并且使它们可相互替换。本模式使得算法可独立于使用它的客户而变化。 适用性： 许多相关的类仅仅是行为有异。“策略”提供了一种用多个行为中的一个行为来配置一个类的方法。 需要使用一个算法的不同变体。例如，你可能会定义一些反映不同的空间&#x2F;时间权衡的算法。当这些变体实现为一个算法的类层次时[H087] ,可以使用策略模式。 算法使用客户不应该知道的数据。可使用策略模式以避免暴露复杂的、与算法相关的数据结构。 一个类定义了多种行为, 并且这些行为在这个类的操作中以多个条件语句的形式出现。将相关的条件分支移入它们各自的Strategy类中以代替这些条件语句。 详解：设计模式是什么鬼（策略） 23. Visitor（访问者） 意图： 定义一个操作中的算法的骨架，而将一些步骤延迟到子类中。TemplateMethod 使得子类可以不改变一个算法的结构即可重定义该算法的某些特定步骤。 适用性： 一次性实现一个算法的不变的部分，并将可变的行为留给子类来实现。 各子类中公共的行为应被提取出来并集中到一个公共父类中以避免代码重复。这是Opdyke和Johnson所描述过的“重分解以一般化”的一个很好的例子[OJ93]。首先识别现有代码中的不同之处，并且将不同之处分离为新的操作。最后，用一个调用这些新的操作的模板方法来替换这些不同的代码。 控制子类扩展。模板方法只在特定点调用“hook ”操作（参见效果一节），这样就只允许在这些点进行扩展。 详解：设计模式是什么鬼（访问者） 1来源：blog.csdn.net/zsjlovesm521/article/details/94382666","categories":[{"name":"2023","slug":"2023","permalink":"http://example.com/categories/2023/"}],"tags":[{"name":"设计模式","slug":"设计模式","permalink":"http://example.com/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"}]},{"title":"软件体系结构","slug":"软件体系结构","date":"2023-03-15T09:24:47.975Z","updated":"2023-03-15T10:50:24.862Z","comments":true,"path":"2023/03/15/软件体系结构/","link":"","permalink":"http://example.com/2023/03/15/%E8%BD%AF%E4%BB%B6%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84/","excerpt":"","text":"软件体系结构​ 软件体系结构是有关软件系统如何组织的描述。体系结构影响了系统的性能、安全性和可用性。软件工程师可以在给定的体系结构类型中使用不同的体系结构风格和模式，而不同的模式描述了不同的系统类别、构建、连接件及约束。 ​ 软件体系结构脱胎于软件工程．但其形成同时借鉴了计算机体系结构和网络体系结构中很多宝贵的思想和方法。最近几年软件体系结构研究完全独立于软件工程的研究，成为计算机科学的一个最新的研究方向和独立学科分支。 软件体系结构是对系统的高层设计，是从一个较高的层次来考虑组成系统的构建、构建之间的连接关系，以及系统需满足的约束等。设计模式可以用于软件体系结构的设计，以实现体系结构级的设计复用。用于软件体系结构的设计模式通常称为架构模式（Architectural Pattern）或体系机构风格（Architectural Style）。 在《Pattern - Oriented Software Architecture》第一卷中，Buschmann等人根据问题的规模或抽象层次将软件设计模式分为三个层次：架构模式（Architectural Patterns）、设计模式（Design Patterns）和习惯用法（Idioms）。 （1）架构模式 架构模式是一种高层模式，用于描述系统级的结构组成、相互关系及相关约束。对架构模式的选择是最基本的设计决策，将决定系统的基本架构，并决定后续的设计及开发活动。 例如，模型 - 视图 - 控制器（Model - View - Controller，MVC）即是一种架构模式，该模式给出了一种交互式系统的架构设计，该模式的主要思想式实现业务逻辑、用户界面的分离。 （2）设计模式 设计模式是中层模式，是针对系统局部设计问题给出的解决方案。一般情况下，人们所讲的设计模式都是指中层模式。设计模式的选择对系统的基本架构没有影响，但在实现架构模式时，则可能采用多种设计模式。 例如，在实现MVC架构模式时，采用的主要设计模式有观察者模式、组合模式和策略模式等。 （3）习惯用法 架构模式和设计模式被认为是与具体编程语言无关的，而习惯用法则通常被认为是与具体编程语言相关的一种低层模式。习惯用法给出的解决方案通常与具体编程语言的某种语法机制相关。 本课程中，软件体系结构就是指架构模式，可以认为是：软件体系结构 &#x3D; 构件 + 连接件 + 约束 。 构件 构件是具有某种功能的可复用的软件结构单元，表示系统中主要的计算元素 和 数据存储。 构件是一个抽象的概念，在程序中可以指程序函数、模块、对象、类等。 连接件 连接是构件间建立和维护行为关联与信息传递的途径。连接包含下面两种要素： 其中，机制指的实际中的消息传递方式。 而协议则决定了 消息的语义理解。 连接件表示构件之间的交互并实现构件之间的连接。 软件体系结构目标为了更好理解后面的软件体系结构涉及的原则和体系结构风格，请牢记这些目标，时不时的对照后面的内容回顾这些目标。 所有的设计原则等理论基本上都可以映射到下面一个或几个目标上。 体系结构的发展现在软件的复杂性及多变性，导致了软件粒度越来越粗，越来越开放。 下面是常见的软件体系结构 软件体系结构与软件设计模式的区别","categories":[{"name":"2023","slug":"2023","permalink":"http://example.com/categories/2023/"}],"tags":[{"name":"设计模式","slug":"设计模式","permalink":"http://example.com/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"}]},{"title":"设计模式概述","slug":"设计模式(1)","date":"2023-03-15T09:18:35.137Z","updated":"2023-03-15T10:48:13.234Z","comments":true,"path":"2023/03/15/设计模式(1)/","link":"","permalink":"http://example.com/2023/03/15/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F(1)/","excerpt":"","text":"设计模式概述（1）1.1 软件设计模式的产生背景“设计模式”最初并不是出现在软件设计中，而是被用于建筑领域的设计中。 1977年美国著名建筑大师、加利福尼亚大学伯克利分校环境结构中心主任克里斯托夫·亚历山大（Christopher Alexander）在他的著作《建筑模式语言：城镇、建筑、构造》（A Pattern Language: Towns Building Construction）中描述了一些常见的建筑设计问题，并提出了 253 种关于对城镇、邻里、住宅、花园和房间等进行设计的基本模式。 1979 年他的另一部经典著作《建筑的永恒之道》（The Timeless Way of Building）进一步强化了设计模式的思想，为后来的建筑设计指明了方向。 1987 年，肯特·贝克（Kent Beck）和沃德·坎宁安（Ward Cunningham）首先将克里斯托夫·亚历山大的模式思想应用在 Smalltalk 中的图形用户接口的生成中，但没有引起软件界的关注。 1990年软件工程界开始研讨设计模式的话题，后来召开了多次关于设计模式的研讨会。直到1995 年，艾瑞克·伽马（ErichGamma）、理査德·海尔姆（Richard Helm）、拉尔夫·约翰森（Ralph Johnson）、约翰·威利斯迪斯（John Vlissides）等 4 位作者合作出版了《设计模式：可复用面向对象软件的基础》一书，在此书中收录了 23 个设计模式，这是设计模式领域里程碑的事件，导致了软件设计模式的突破。这 4 位作者在软件开发领域里也以他们的“四人组”（Gang of Four，GoF）著称。 1.2 软件设计模式的概念软件设计模式（Software Design Pattern），又称设计模式，“解决如下的在特定的环境中反复出现的设计问题，并且为其提供了解决方案”(Buschmann, et. al. 1996)，是一套被反复使用、多数人知晓的、经过分类编目的、代码设计经验的总结。它描述了在软件设计过程中的一些不断重复发生的问题，以及该问题的解决方案。也就是说，它是解决特定问题的一系列套路，是前辈们的代码设计经验的总结，具有一定的普遍性，可以反复使用。 1.3 学习设计模式的必要性设计模式的本质是面向对象设计原则的实际运用，是对类的封装性、继承性和多态性以及类的关联关系和组合关系的充分理解。 正确使用设计模式具有以下优点。 可以提高程序员的思维能力、编程能力和设计能力。 使程序设计更加标准化、代码编制更加工程化，使软件开发效率大大提高，从而缩短软件的开发周期。 使设计的代码可重用性高、可读性强、可靠性高、灵活性好、可维护性强。 成为优秀的软件工程师。 当然，软件设计模式只是一个引导。在具体的软件幵发中，必须根据设计的应用系统的特点和要求来恰当选择。对于简单的程序开发，苛能写一个简单的算法要比引入某种设计模式更加容易。但对大项目的开发或者框架设计，用设计模式来组织代码显然更好。 1.4 软件设计模式的基本要素软件设计模式使人们可以更加简单方便地复用成功的设计和体系结构，它通常包含以下几个基本要素：模式名称、别名、动机、问题、解决方案、效果、结构、模式角色、合作关系、实现方法、适用性、已知应用、例程、模式扩展和相关模式等，其中最关键的元素包括以下 4 个主要部分。 \\1. 模式名称 每一个模式都有自己的名字，通常用一两个词来描述，可以根据模式的问题、特点、解决方案、功能和效果来命名。模式名称（PatternName）有助于我们理解和记忆该模式，也方便我们来讨论自己的设计。 \\2. 问题 问题（Problem）描述了该模式的应用环境，即何时使用该模式。它解释了设计问题和问题存在的前因后果，以及必须满足的一系列先决条件。 \\3. 解决方案 模式问题的解决方案（Solution）包括设计的组成成分、它们之间的相互关系及各自的职责和协作方式。因为模式就像一个模板，可应用于多种不同场合，所以解决方案并不描述一个特定而具体的设计或实现，而是提供设计问题的抽象描述和怎样用一个具有一般意义的元素组合（类或对象的 组合）来解决这个问题。 \\4. 效果 描述了模式的应用效果以及使用该模式应该权衡的问题，即模式的优缺点。主要是对时间和空间的衡量，以及该模式对系统的灵活性、扩充性、可移植性的影响，也考虑其实现问题。显式地列出这些效果（Consequence）对理解和评价这些模式有很大的帮助。 1.5 根据目的分类 创建型模式 用于描述“怎样创建对象”，它的主要特点是“将对象的创建与使用分离”。GoF（四人组）书中提供了单例、原型、工厂方法、抽象工厂、建造者等 5 种创建型模式。 结构型模式 用于描述如何将类或对象按某种布局组成更大的结构，GoF（四人组）书中提供了代理、适配器、桥接、装饰、外观、享元、组合等 7 种结构型模式。 行为型模式 用于描述类或对象之间怎样相互协作共同完成单个对象无法单独完成的任务，以及怎样分配职责。GoF（四人组）书中提供了模板方法、策略、命令、职责链、状态、观察者、中介者、迭代器、访问者、备忘录、解释器等 11 种行为型模式。 1.6 根据作用范围来分根据模式是主要用于类上还是主要用于对象上来分，这种方式可分为类模式和对象模式两种。 类模式：用于处理类与子类之间的关系，这些关系通过继承来建立，是静态的，在编译时刻便确定下来了。GoF中的工厂方法、（类）适配器、模板方法、解释器属于该模式。 对象模式：用于处理对象之间的关系，这些关系可以通过组合或聚合来实现，在运行时刻是可以变化的，更具动态性。GoF 中除了以上 4 种，其他的都是对象模式。 1.7. GoF的23种设计模式的功能简介前面说明了 GoF 的 23 种设计模式的分类，现在对各个模式的功能进行介绍。 单例（Singleton）模式：某个类只能生成一个实例，该类提供了一个全局访问点供外部获取该实例，其拓展是有限多例模式。 原型（Prototype）模式：将一个对象作为原型，通过对其进行复制而克隆出多个和原型类似的新实例。 工厂方法（Factory Method）模式：定义一个用于创建产品的接口，由子类决定生产什么产品。 抽象工厂（AbstractFactory）模式：提供一个创建产品族的接口，其每个子类可以生产一系列相关的产品。 建造者（Builder）模式：将一个复杂对象分解成多个相对简单的部分，然后根据不同需要分别创建它们，最后构建成该复杂对象。 代理（Proxy）模式：为某对象提供一种代理以控制对该对象的访问。即客户端通过代理间接地访问该对象，从而限制、增强或修改该对象的一些特性。 适配器（Adapter）模式：将一个类的接口转换成客户希望的另外一个接口，使得原本由于接口不兼容而不能一起工作的那些类能一起工作。 桥接（Bridge）模式：将抽象与实现分离，使它们可以独立变化。它是用组合关系代替继承关系来实现，从而降低了抽象和实现这两个可变维度的耦合度。 装饰（Decorator）模式：动态的给对象增加一些职责，即增加其额外的功能。 外观（Facade）模式：为多个复杂的子系统提供一个一致的接口，使这些子系统更加容易被访问。 享元（Flyweight）模式：运用共享技术来有效地支持大量细粒度对象的复用。 组合（Composite）模式：将对象组合成树状层次结构，使用户对单个对象和组合对象具有一致的访问性。 模板方法（TemplateMethod）模式：定义一个操作中的算法骨架，而将算法的一些步骤延迟到子类中，使得子类可以不改变该算法结构的情况下重定义该算法的某些特定步骤。 策略（Strategy）模式：定义了一系列算法，并将每个算法封装起来，使它们可以相互替换，且算法的改变不会影响使用算法的客户。 命令（Command）模式：将一个请求封装为一个对象，使发出请求的责任和执行请求的责任分割开。 职责链（Chain of Responsibility）模式：把请求从链中的一个对象传到下一个对象，直到请求被响应为止。通过这种方式去除对象之间的耦合。 状态（State）模式：允许一个对象在其内部状态发生改变时改变其行为能力。 观察者（Observer）模式：多个对象间存在一对多关系，当一个对象发生改变时，把这种改变通知给其他多个对象，从而影响其他对象的行为。 中介者（Mediator）模式：定义一个中介对象来简化原有对象之间的交互关系，降低系统中对象间的耦合度，使原有对象之间不必相互了解。 迭代器（Iterator）模式：提供一种方法来顺序访问聚合对象中的一系列数据，而不暴露聚合对象的内部表示。 访问者（Visitor）模式：在不改变集合元素的前提下，为一个集合中的每个元素提供多种访问方式，即每个元素有多个访问者对象访问。 备忘录（Memento）模式：在不破坏封装性的前提下，获取并保存一个对象的内部状态，以便以后恢复它。 解释器（Interpreter）模式：提供如何定义语言的文法，以及对语言句子的解释方法，即解释器。 必须指出，这 23 种设计模式不是孤立存在的，很多模式之间存在一定的关联关系，在大的系统开发中常常同时使用多种设计模式。","categories":[{"name":"2023","slug":"2023","permalink":"http://example.com/categories/2023/"}],"tags":[{"name":"设计模式","slug":"设计模式","permalink":"http://example.com/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"}]},{"title":"虚拟机和主机双向复制","slug":"虚拟机和主机双向复制","date":"2023-03-13T16:19:02.512Z","updated":"2023-03-13T17:01:33.362Z","comments":true,"path":"2023/03/14/虚拟机和主机双向复制/","link":"","permalink":"http://example.com/2023/03/14/%E8%99%9A%E6%8B%9F%E6%9C%BA%E5%92%8C%E4%B8%BB%E6%9C%BA%E5%8F%8C%E5%90%91%E5%A4%8D%E5%88%B6/","excerpt":"虚拟机和主机双向复制","text":"虚拟机和主机双向复制 vmware tools黑了 http://www.360doc.com/content/22/1205/19/81029453_1059073619.shtml 试试这个吧 手工安装Vmware tools方法 这种方法是通过Ubuntu的安装命令直接从网上进行安装，打开终端窗口直接执行下列命令即可，安装之前要保证虚拟机可以连接外网，要能连上软件更新服务器，该服务器有可能在国外（根据你自己的设置）。命令如下： 1234sudo apt-get autoremove open-vm-toolssudo apt-get install open-vm-toolssudo apt-get install open-vm-tools-desktop 安装完之后最好重启一下虚拟机。安装完Vmware tools并正确配置后就可以实现主机和虚拟机双向内容复制、粘贴，包括文件的拷贝。","categories":[{"name":"2023","slug":"2023","permalink":"http://example.com/categories/2023/"}],"tags":[{"name":"vmware","slug":"vmware","permalink":"http://example.com/tags/vmware/"}]},{"title":"Spark入门：RDD编程","slug":"spark","date":"2023-03-13T13:47:53.892Z","updated":"2023-03-13T17:00:55.622Z","comments":true,"path":"2023/03/13/spark/","link":"","permalink":"http://example.com/2023/03/13/spark/","excerpt":"Spark入门：RDD编程","text":"Spark入门：RDD编程 RDD创建RDD可以通过两种方式创建： 第一种：读取一个外部数据集。比如，从本地文件加载数据集，或者从HDFS文件系统、HBase、Cassandra、Amazon S3等外部数据源中加载数据集。Spark可以支持文本文件、SequenceFile文件（Hadoop提供的 SequenceFile是一个由二进制序列化过的key&#x2F;value的字节流组成的文本存储文件）和其他符合Hadoop InputFormat格式的文件。 第二种：调用SparkContext的parallelize方法，在Driver中一个已经存在的集合（数组）上创建 在即将进行相关的实践操作之前，我们首先要登录Linux系统（本教程统一采用hadoop用户登录），然后，打开命令行“终端”，请按照下面的命令启动Hadoop中的HDFS组件： 创建RDD之前的准备工作在即将进行相关的实践操作之前，我们首先要登录Linux系统（本教程统一采用hadoop用户登录），然后，打开命令行“终端”，请按照下面的命令启动Hadoop中的HDFS组件： 12cd /usr/local/hadoop./sbin/start-dfs.sh 然后，我们按照下面命令启动spark-shell： 12cd /usr/local/spark./bin/pyspark 然后，新建第二个“终端”，方法是，在前面已经建设的第一个终端窗口的左上方，点击“终端”菜单，在弹出的子菜单中选择“新建终端”，就可以打开第二个终端窗口，现在，我们切换到第二个终端窗口，在第二个终端窗口中，执行以下命令，进入之前已经创建好的“&#x2F;usr&#x2F;local&#x2F;spark&#x2F;mycode&#x2F;”目录，在这个目录下新建rdd子目录，用来存放本章的代码和相关文件： 12cd usr/local/spark/mycode/mkdir rdd 然后，使用vim编辑器，在rdd目录下新建一个word.txt文件，你可以在文件里面随便输入几行英文语句用来测试。 经过上面的准备工作以后，我们就可以开始创建RDD了。 从文件系统中加载数据创建RDDSpark采用textFile()方法来从文件系统中加载数据创建RDD，该方法把文件的URI作为参数，这个URI可以是本地文件系统的地址，或者是分布式文件系统HDFS的地址，或者是Amazon S3的地址等等。下面请切换回spark-shell窗口，看一下如何从本地文件系统中加载数据： 12&gt;&gt;&gt;lines = sc.textFile(&quot;file:///usr/local/spark/mycode/rdd/word.txt&quot;) 1&gt;&gt;&gt;lines.foreach(print) 加载HDFS中的文件为了能够读取HDFS中的文件，请首先启动Hadoop中的HDFS组件。注意，之前我们在“Spark安装”这章内容已经介绍了如何安装Hadoop和Spark，所以，这里我们可以使用以下命令直接启动Hadoop中的HDFS组件（由于用不到MapReduce组件，所以，不需要启动MapReduce或者YARN）。请到第二个终端窗口，使用Linux Shell命令提示符状态，然后输入下面命令： 12cd /usr/local/hadoop./sbin/start-dfs.sh 启动结束后，HDFS开始进入可用状态。如果你在HDFS文件系统中，还没有为当前Linux登录用户创建目录(本教程统一使用用户名hadoop登录Linux系统)，请使用下面命令创建： 1./bin/hdfs dfs -mkdir -p /user/hadoop 也就是说，HDFS文件系统为Linux登录用户开辟的默认目录是“&#x2F;user&#x2F;用户名”（注意：是user，不是usr），本教程统一使用用户名hadoop登录Linux系统，所以，上面创建了“&#x2F;user&#x2F;hadoop”目录，再次强调，这个目录是在HDFS文件系统中，不在本地文件系统中。创建好以后，下面我们使用命令查看一下HDFS文件系统中的目录和文件： 1./bin/hdfs dfs -ls . ** 但这个命令我搞不出来，显示的是这个 – 上面命令中，最后一个点号“.”，表示要查看Linux当前登录用户hadoop在HDFS文件系统中与hadoop对应的目录下的文件，也就是查看HDFS文件系统中“&#x2F;user&#x2F;hadoop&#x2F;”目录下的文件，所以，下面两条命令是等价的： – 12./bin/hdfs dfs -ls ../bin/hdfs dfs -ls /user/hadoop 你自己可以试一试，只有第二个可以用 如果要查看HDFS文件系统根目录下的内容，需要使用下面命令： 1./bin/hdfs dfs -ls / 然后输出的东西见上面那个图，有一个items 下面，我们把本地文件系统中的“&#x2F;usr&#x2F;local&#x2F;spark&#x2F;mycode&#x2F;rdd&#x2F;word.txt”上传到分布式文件系统HDFS中（放到hadoop用户目录下）： 1./bin/hdfs dfs -put /usr/local/spark/mycode/rdd/word.txt /user/hadoop 然后，用命令查看一下HDFS的hadoop用户目录下是否多了word.txt文件，可以使用下面命令列出hadoop目录下的内容： 1./bin/hdfs dfs -ls / 可以看到，确实多了一个word.txt文件，我们使用cat命令查看一个HDFS中的word.txt文件的内容，命令如下： 1./bin/hdfs dfs -cat ./word.txt 上面命令执行后，就会看到HDFS中word.txt的内容了。 现在，让我们切换回到spark-shell窗口，编写语句从HDFS中加载word.txt文件，并显示第一行文本内容： 12&gt;&gt;&gt;lines= sc.textFile(&quot;hdfs://localhost:9000/user/hadoop/word.txt&quot;)&gt;&gt;&gt;lines=sc.foreach(print) 注意，上面三条命令是完全等价的命令，只不过使用了不同的目录形式，你可以使用其中任意一条命令完成数据加载操作。 在使用Spark读取文件时，需要说明以下几点：（1）如果使用了本地文件系统的路径，那么，必须要保证在所有的worker节点上，也都能够采用相同的路径访问到该文件，比如，可以把该文件拷贝到每个worker节点上，或者也可以使用网络挂载共享文件系统。（2）textFile()方法的输入参数，可以是文件名，也可以是目录，也可以是压缩文件等。比如，textFile(“&#x2F;my&#x2F;directory”), textFile(“&#x2F;my&#x2F;directory&#x2F;.txt”), and textFile(“&#x2F;my&#x2F;directory&#x2F;.gz”).（3）textFile()方法也可以接受第2个输入参数（可选），用来指定分区的数目。默认情况下，Spark会为HDFS的每个block创建一个分区（HDFS中每个block默认是128MB）。你也可以提供一个比block数量更大的值作为分区数目，但是，你不能提供一个小于block数量的值作为分区数目。 通过并行集合（数组）创建RDD可以调用SparkContext的parallelize方法，在Driver中一个已经存在的集合（数组）上创建。下面请在spark-shell中操作： 123&gt;&gt;&gt;array = [1,2,3,4,5]&gt;&gt;&gt;rdd = sc.parallelize(array)&gt;&gt;&gt;rdd.foreach(print) RDD操作RDD被创建好以后，在后续使用过程中一般会发生两种操作：*  转换（Transformation）： 基于现有的数据集创建一个新的数据集。*  行动（Action）：在数据集上进行运算，返回计算值。 转换操作对于RDD而言，每一次转换操作都会产生不同的RDD，供给下一个“转换”使用。转换得到的RDD是惰性求值的，也就是说，整个转换过程只是记录了转换的轨迹，并不会发生真正的计算，只有遇到行动操作时，才会发生真正的计算，开始从血缘关系源头开始，进行物理的转换操作。下面列出一些常见的转换操作（Transformation API）：* filter(func)：筛选出满足函数func的元素，并返回一个新的数据集* map(func)：将每个元素传递到函数func中，并将结果返回为一个新的数据集* flatMap(func)：与map()相似，但每个输入元素都可以映射到0或多个输出结果* groupByKey()：应用于(K,V)键值对的数据集时，返回一个新的(K, Iterable)形式的数据集* reduceByKey(func)：应用于(K,V)键值对的数据集时，返回一个新的(K, V)形式的数据集，其中的每个值是将每个key传递到函数func中进行聚合 1.filter(func) 好吧，这个书上说要把word.txt写成 12345Hadoop is goodSpark is fastSpark is better 那我们就 1cd /usr/local/spark/mycode/rdd 1gedit word.txt 然后再 123&gt;&gt;&gt;lines=sc.textFile(&quot;file:///usr/local/spark/mycode/rdd/word.txt&quot;)&gt;&gt;&gt;linesWithSpark = lines.filter(lambda line: &quot;Spark&quot; in line)&gt;&gt;&gt;linesWithSpark.foreach(print) 上面的代码中，lines就是一个RDD。lines.filter()会遍历lines中的每行文本，并对每行文本执行括号中的匿名函数，也就是执行Lamda表达式：line &#x3D;&gt; line.contains(“Spark”)，在执行Lamda表达式时，会把当前遍历到的这行文本内容赋值给参数line，然后，执行处理逻辑line.contains(“Spark”)，也就是只有当改行文本包含“Spark”才满足条件，才会被放入到结果集中。最后，等到lines集合遍历结束后，就会得到一个结果集，这个结果集中包含了所有包含“Spark”的行。最后，对这个结果集调用count()，这是一个行动操作，会计算出结果集中的元素个数。 2.map(func) map(func)：将每个元素传递到函数func中，并将结果返回为一个新的数据集 1234&gt;&gt;&gt; data =[1,2,3,4,5]&gt;&gt;&gt; rdd1 = sc.parallelize(data)&gt;&gt;&gt; rdd2 = rdd1.map(lambda x:x+10)&gt;&gt;&gt; rdd2.foreach(print) 上述语句执行过程如图 所示。第 1行语句创建了一个包含 5 个整型元素的列表 data。第2行语句执行 sc.parallelize(data)，从列表 data 中生成一个 RDD，即 rdd1,rdd1 中包含了5 个整型的元素即1、2、3、4、5。第 3 行语句执行 rdd1.map0操作,map0的输入参数“lambda x:x+10”是一个Lambda表达式。rdd1.map(lambda x:x+10)的含义是，依次取出 rdd1 这个RDD 中的每个元素，对于当前取到的元素，把它赋值给 Lambda 表达式中的变量x，然后，执行 Lambda 表达式的函数体部分“x+10”也就是把变量x的值和 10 相加后，作为函数的返回值，并作为一个元素放入到新的 RDD(即rdd2中。最终，新牛成的RDD (即 rdd2) 中包含了 5 个整型元素，即 11、12、13、14、15。 另外一个实例： 123&gt;&gt;&gt;lines=sc.textFile(&quot;file:///usr/local/spark/mycode/rdd/word.txt&quot;)&gt;&gt;&gt; words = lines.map(lambda line:line.split(&quot; &quot;))&gt;&gt;&gt; words.foreach(print) 上述语句执行过程如图所示。在第 1 行语句中，执行 sc.textFile0方法把 word.txt 文件中的数据加载到内存生成一个 RDD，即 lines，这个RDD 中的每个元素都是字符串类型，即每个 RDD 元素都是一行文本，比如，lines 中的第 1 个元素是”Hadoop is good”，第2 个元素是”Spark is fast”，第3个元素是”Spark is better”。在第 2 行语句中，执行 lies.map0操作，map0的输入参数 lambdaline:line.split(“)是一个 Lambda 表达式。linesmap(lambda line:line.split(“”)的含义是，依次取出 lines这个 RDD 中的每个元素，对于当前取到的元素，把它赋值给 Lambda 表达式中的变量 line，然后，执行 Lambda 表达式的函数体部分 line.split(“”)。因为 line 是一行文本，如”Hadoop is good”，一行文本中包含了很多个单词，单词之间以空格进行分隔，所以，line.split(“”的功能是，以空格作为分隔符把 line 拆分成一个个单词,拆分后得到的单词都封装在一个列表对象中,成为新的 RDD( 即 words)的一个元素，比如，”Hadoop is good”被拆分后，得到”Hadoop”、”is”和”good”3 个单词，会被封装到一个列表对象中，即[“Hadoop”.”is”,”good”]，成为 words 这个 RDD 中的一个元素。 3.flatMap(func)flatMap(func)与 map0相似，但每个输入元素都可以映射到 0 或多个输出结果。例如: 123&gt;&gt;&gt;lines=sc.textFile(&quot;file:///usr/local/spark/mycode/rdd/word.txt&quot;)&gt;&gt;&gt;words =lines.flatMap(lambda line:line.split(&quot; &quot;))&gt;&gt;&gt; words.foreach(print) 上述语句执行过程如图所示。在第 1行语句中，执行 sc.textFile0方法把 wordtxt 文件中的数据加载到内存生成一个RDD，即 lines，这个 RDD 中的每个元素都是字符串类型，即每个RDD 元素都是一行文本。在第2行语句中，执行 linesflatMap0操作，flatMap0的输入参数 line:linesplit(“”)是个Lambda 表达式。lines.flatMap(lambda line:line.split(“”))的结果，等价于如下两步操作的结果。 第1步: map0。执行 lines.map(lambda line: linesplit(“”))操作，从 lines 转换得到一个新的 RDD(即wordArray),wordArray 中的每个元素都是一个列表,比如,第1个元素是[“Hadoop”,”is”，”good”]7.第2个元素是”Spark”，”is”,”fast”]，第3 个元素是[“Spark”,”is””better”]。 第 2步:拍扁 ( flat)。flatMap0操作中的“flat”是一个很形象的动作-“拍扁”，也就是把vordArray 中的每个 RDD 元素都“拍扁”成多个元素。所有这些被拍扁以后得到的元素，构成一个新的 RDD，即 words。比如，wordArray 中的第1个元素是[“Hadoop”,”is”,”good]，被拍扁以后得到3个新的字符串类型的元素,即”Hadoop”、”is”和”good”; wordArray 中的第 2 个元素是[“Spark”,”is”fast”],被拍扁以后得到 3 个新的元素,即”Spark”、”is”和”fast”; wordArray 中的第 3 个元素是[“Spark””is””beter”，被拍扁以后得到 3 个新的元素，即”Spark”、”is”和”beter”。最终，这些被拍扁以后得到的 9 个字符串类型的元素构成一个新的 RDD (即 words )。也就是说，words 里面包含了 9 个字串类型的元素，分别是”Hadoop”、”is”、”good”、”Spark”、”is”、”fast”、”Spark”、”is”和”。","categories":[{"name":"2023","slug":"2023","permalink":"http://example.com/categories/2023/"}],"tags":[{"name":"Spark","slug":"Spark","permalink":"http://example.com/tags/Spark/"}]},{"title":"3-8-2023","slug":"3-8-2023","date":"2023-03-08T05:19:53.978Z","updated":"2023-03-08T05:45:39.860Z","comments":true,"path":"2023/03/08/3-8-2023/","link":"","permalink":"http://example.com/2023/03/08/3-8-2023/","excerpt":"三月初自我反省","text":"三月初自我反省 1.退实验室✔ 2.数学第一章✔ 3.单词200 per day✔ 4.后端增删查改✔ 1234567891011121314151617181920212223def department_list(request): member_list=Department.objects.all() return render(request,&#x27;dep.html&#x27;,&#123;&#x27;member&#x27;:member_list&#125;)def add_dep(request): if request.method==&#x27;GET&#x27;: return render(request,&#x27;adddep.html&#x27;) elif request.method==&#x27;POST&#x27;: title=request.POST.get(&#x27;aatitle&#x27;) Department.objects.create(tittle=title) return redirect(&quot;/dep/list&quot;)def delete_dep(request): memid=request.GET.get(&#x27;memid&#x27;) Department.objects.filter(id=memid).delete() return redirect(&quot;/dep/list&quot;)def edit_dep(request,memid): if request.method==&#x27;GET&#x27;: nnmame=Department.objects.filter(id=memid).first() return render(request,&#x27;editdpt.html&#x27;,&#123;&#x27;nnmame&#x27;:nnmame.tittle&#125;) aatitle=request.POST.get(&#x27;aatitle&#x27;) Department.objects.filter(id=memid).update(tittle=aatitle) return redirect(&quot;/dep/list&quot;) 5.数据结构 图(floyd，dijkstra)✔ 1234567891011121314151617181920212223242526272829303132#include&lt;cstdio&gt;#include&lt;iostream&gt;#include&lt;cmath&gt;#include&lt;cstring&gt;using namespace std;int a[101][3];double f[101][101];int n,i,j,k,x,y,m,s,e;int main()&#123;// freopen(&quot;short.in&quot;,&quot;r&quot;,stdin);// freopen(&quot;short.out&quot;,&quot;w&quot;,stdout); cin&gt;&gt;n; for(i=1;i&lt;=n;i++) cin&gt;&gt;a[i][1]&gt;&gt;a[i][2]; cin&gt;&gt;m; memset(f,0x7f,sizeof(f)); //初始化为最大值 for(i=1;i&lt;=m;i++)&#123; cin&gt;&gt;x&gt;&gt;y;// int temp1=;// int temp2=; f[y][x]=f[x][y]=sqrt(pow(double(a[x][1]-a[y][1]),2)+pow(double(a[x][2]-a[y][2]),2)); &#125; cin&gt;&gt;s&gt;&gt;e; for(k=1;k&lt;=n;k++) for(j=1;j&lt;=n;j++) for(i=1;i&lt;=n;i++) if(f[i][k]+f[k][j]&lt;f[i][j]) f[i][j]=f[i][k]+f[k][j]; printf(&quot;%.2lf\\n&quot;,f[s][e]); return 0; &#125; 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849#include&lt;cstdio&gt;#include&lt;cstring&gt;#define INF 1e4+10using namespace std;const int M=1e4+10;const int N=1000+10;int n,m,s;int mp[N][M];int dis[N],vis[N];void initmp()&#123;memset(mp,INF,sizeof(mp)); &#125;void dijkstra(int s)&#123; //求s点到其它点的最短路径 memset(vis,0,sizeof(vis));//0表示蓝点(未确定最短路径的点)，1表示白点（确定路径的点） memset(dis,0x3f,sizeof(dis));//默认情况下设置为无穷大 dis[s]=0; while(1)&#123; int mini=0,min_=INF; for(int j=1;j&lt;=n;j++)&#123; if(!vis[j]&amp;&amp;min_&gt;dis[j])&#123;//从蓝点中找出最小的点 .vis[j](蓝点)为0,那么!vis[j]就为1了.dis[j]是权值 mini=j;//记录第几个点 min_=dis[j]; //记录最短的路的距离 &#125; &#125; //如果没有蓝点就提前结束 if(mini==0) break; vis[mini]=1;//变成白点 for(int i=1;i&lt;=n;i++)&#123; if(dis[i]&gt;dis[mini]+mp[mini][i]) dis[i]=dis[mini]+mp[mini][i]; &#125; &#125; &#125;int main()&#123; memset(mp,INF,sizeof(mp)); while(scanf(&quot;%d %d&quot;,&amp;n,&amp;m)!=EOF&amp;&amp;n)&#123; initmp();//每次清空mp for(int i=0;i&lt;m;i++)&#123; int u,v,w; scanf(&quot;%d %d %d&quot;,&amp;u,&amp;v,&amp;w); if(mp[u][v]&gt;w) mp[u][v]=mp[v][u]=w; &#125; dijkstra(1); printf(&quot;%d\\n&quot;,dis[n]); &#125; return 0;&#125;","categories":[{"name":"2023","slug":"2023","permalink":"http://example.com/categories/2023/"}],"tags":[{"name":"casual_talk","slug":"casual-talk","permalink":"http://example.com/tags/casual-talk/"}]},{"title":"DataError at /index/add_member 1366, \"Incorrect string value :\\\\xE4\\\\xBC\\\\x98\\\\xE","slug":"ERROR 1366 (HY000)Incorrect string value解决方案","date":"2023-03-05T03:11:11.586Z","updated":"2023-03-08T05:16:49.900Z","comments":true,"path":"2023/03/05/ERROR 1366 (HY000)Incorrect string value解决方案/","link":"","permalink":"http://example.com/2023/03/05/ERROR%201366%20(HY000)Incorrect%20string%20value%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/","excerpt":"&#56;&#x32;&#53;&#53;&#x37;&#x37;&#x39;&#x34;&#48;&#x40;&#113;&#113;&#x2e;&#x63;&#111;&#109; DataError at &#x2F;index&#x2F;add_member 1366, “Incorrect string value: ‘\\xE4\\xBC\\x98\\xE ERROR 1366 (HY000):Incorrect string value解决方案","text":"&#56;&#x32;&#53;&#53;&#x37;&#x37;&#x39;&#x34;&#48;&#x40;&#113;&#113;&#x2e;&#x63;&#111;&#109; DataError at &#x2F;index&#x2F;add_member 1366, “Incorrect string value: ‘\\xE4\\xBC\\x98\\xE ERROR 1366 (HY000):Incorrect string value解决方案 https://zhuanlan.zhihu.com/p/53941345 after before 然后把数据库删除，重新创建数据库，再导入数据库文件，就又是一条好汉","categories":[{"name":"2023","slug":"2023","permalink":"http://example.com/categories/2023/"}],"tags":[{"name":"mysql","slug":"mysql","permalink":"http://example.com/tags/mysql/"}]},{"title":"远离不规范书籍，不然会变得不幸","slug":"远离不规范书籍，不然会变得不幸","date":"2023-03-04T09:14:48.511Z","updated":"2023-03-08T05:16:54.675Z","comments":true,"path":"2023/03/04/远离不规范书籍，不然会变得不幸/","link":"","permalink":"http://example.com/2023/03/04/%E8%BF%9C%E7%A6%BB%E4%B8%8D%E8%A7%84%E8%8C%83%E4%B9%A6%E7%B1%8D%EF%BC%8C%E4%B8%8D%E7%84%B6%E4%BC%9A%E5%8F%98%E5%BE%97%E4%B8%8D%E5%B9%B8/","excerpt":"远离不规范书籍,不然会变得不幸","text":"远离不规范书籍,不然会变得不幸","categories":[{"name":"2023","slug":"2023","permalink":"http://example.com/categories/2023/"}],"tags":[{"name":"casual_talk","slug":"casual-talk","permalink":"http://example.com/tags/casual-talk/"}]},{"title":"2月开学总结","slug":"2月开学总结","date":"2023-03-01T06:57:51.608Z","updated":"2023-03-08T05:15:23.317Z","comments":true,"path":"2023/03/01/2月开学总结/","link":"","permalink":"http://example.com/2023/03/01/2%E6%9C%88%E5%BC%80%E5%AD%A6%E6%80%BB%E7%BB%93/","excerpt":"2月开学总结","text":"2月开学总结 每日200单词，真的坚持不下来（我妈说过一句老话：新的马桶只有三天是香的） 周五-周日每日50页django目前停滞（p117），在后渲前的简单&#123;&#123;&#125;&#125;不清楚具体语法，有时间看b具体简单讲解，我实在无法理解，这种书怎么出版的，前20页每页都有错误，这个人抄官方文档都能抄错？？？？！！！ 问了师姐她复习进度，四月之前（include四月）刷完1800,以及师姐说英二难度比江苏高考英语难度小 临时接了挑战杯的复赛答辩，要准备讲演稿子 目前数学进度第一章（第一遍做不到不看视频（看视频时真的费时间），但已经都忘了（为什么上学期我要拒绝高数老师让我做她的助教（扇自己耳光））） 英语6级太难了 准备算法考试 所有的东西并行真的做不到，一天只能选一个（上周多线程进行复习&amp;&amp;学习，效率极低） 佛山顺德愿望get 实验室老师开始整幺蛾子了：周四下午7、8节加了一节选修课。明天去一节看看情况，不行就退实验室;以及未来一个月内实验室搬迁，不行就退。 昨天去交材料，党建的辅导老师说：好久没看见你了，你最近在干嘛。 我：准备考研，和实验室的东西。 老师:你准备考研的话要平衡比赛和考研准备的东西 老师:考研的书差不多要买了 我：嗯嗯12.仰天长叹，下个月三场考试，4月份一轮，师姐说828要在这学期内过完，操作系统跟着这学期的老师好好学一遍，就没什么问题，我真的能平衡吗……实验室感觉差不多可以退了，但又想拼一把计算机设计大赛，自己再做个东西出来…… emoji format 本来想花15min解决的note，花了1个小时的原因窒息","categories":[{"name":"2023","slug":"2023","permalink":"http://example.com/categories/2023/"}],"tags":[{"name":"casual_talk","slug":"casual-talk","permalink":"http://example.com/tags/casual-talk/"}]},{"title":"Import pymysql could not be resolved from","slug":"Import pymysql could not be resolved from","date":"2023-02-26T13:23:28.035Z","updated":"2023-03-13T16:56:38.944Z","comments":true,"path":"2023/02/26/Import pymysql could not be resolved from/","link":"","permalink":"http://example.com/2023/02/26/Import%20pymysql%20could%20not%20be%20resolved%20from/","excerpt":"Import “pymysql” could not be resolved from","text":"Import “pymysql” could not be resolved from 在anaconda里面装一个 首先先切进django的虚拟环境里面 在Anaconda中，可以通过使用conda命令来创建和管理虚拟环境。要切换已创建的虚拟环境，可以使用以下命令： 列出已有环境： 1conda info --envs 激活目标环境： 1conda activate &lt;env_name&gt; 这里&lt;env_name&gt;是你想要激活的虚拟环境的名称。激活环境后，你可以在该环境中使用安装的软件包和工具。 取消激活当前环境： 1conda deactivate 这将使当前环境不再处于活动状态，回到默认的基础环境。 注意：如果你在使用Anaconda Navigator，也可以通过选择“Environments”选项卡，然后单击目标环境的名称来激活虚拟环境。 conda install pymysql 看你anaconda用的是什么源，国内的记得关闭魔法上网工具","categories":[{"name":"2023","slug":"2023","permalink":"http://example.com/categories/2023/"}],"tags":[{"name":"django","slug":"django","permalink":"http://example.com/tags/django/"}]},{"title":"官方文档","slug":"null¶","date":"2023-02-24T12:24:35.657Z","updated":"2023-03-01T07:09:14.756Z","comments":true,"path":"2023/02/24/null¶/","link":"","permalink":"http://example.com/2023/02/24/null%C2%B6/","excerpt":"https://stackoverflow.com/questions/19428572/django-templatesyntaxerror-could-not-parse-the-remainder","text":"https://stackoverflow.com/questions/19428572/django-templatesyntaxerror-could-not-parse-the-remainder 模型字段参考 字段选项 https://docs.djangoproject.com/zh-hans/4.1/ref/models/fields/#validators 以下参数对所以字段类型均有效，且是可选的。 null¶ Field.``null¶ 如果是 True， Django 将在数据库中存储空值为 NULL。默认为 False。 避免在基于字符串的字段上使用 null，如 CharField 和 TextField。如果一个基于字符串的字段有 null=True，这意味着它有两种可能的“无数据”值。NULL，和空字符串。在大多数情况下，“无数据”有两种可能的值是多余的，Django 的惯例是使用空字符串，而不是 NULL。一个例外是当一个 CharField 同时设置了 unique=True 和 blank=True。在这种情况下，null=True 是需要的，以避免在保存具有空白值的多个对象时违反唯一约束。 无论是基于字符串的字段还是非字符串的字段，如果希望在表单中允许空值，还需要设置 blank=True，因为 null 参数只影响数据库的存储（参见 blank ）。","categories":[{"name":"2023","slug":"2023","permalink":"http://example.com/categories/2023/"}],"tags":[{"name":"django","slug":"django","permalink":"http://example.com/tags/django/"}]},{"title":"Module \"django.contrib.sessions.serializers\" does not define a \"PicleSerializer\" attribute/class","slug":"Module django.contrib.sessions.serializers does not define a PicleSerializer attributeclass","date":"2023-02-24T07:05:59.648Z","updated":"2023-03-01T07:09:09.742Z","comments":true,"path":"2023/02/24/Module django.contrib.sessions.serializers does not define a PicleSerializer attributeclass/","link":"","permalink":"http://example.com/2023/02/24/Module%20django.contrib.sessions.serializers%20does%20not%20define%20a%20PicleSerializer%20attributeclass/","excerpt":"Module “django.contrib.sessions.serializers” does not define a “PicleSerializer” attribute&#x2F;class","text":"Module “django.contrib.sessions.serializers” does not define a “PicleSerializer” attribute&#x2F;class 是这本书打错了hhhh https://docs.djangoproject.com/zh-hans/4.1/topics/http/sessions/ 在这里ctrl+F找 serializers 最后一个 serializers.``PickleSerializer tmd是这个玩意儿！ 不是picle睡觉哦pick 服了这个写书的老六！","categories":[{"name":"2023","slug":"2023","permalink":"http://example.com/categories/2023/"}],"tags":[{"name":"django","slug":"django","permalink":"http://example.com/tags/django/"}]},{"title":"无法加载文件C:\\Users\\xxx\\Documents\\WindowsPowerShell\\profile.ps1","slug":"无法加载文件CUsersxxxDocumentsWindowsPowerShellprofile.ps1，因为在此系统上禁止运行脚本","date":"2023-02-24T04:38:04.277Z","updated":"2023-03-01T07:08:52.941Z","comments":true,"path":"2023/02/24/无法加载文件CUsersxxxDocumentsWindowsPowerShellprofile.ps1，因为在此系统上禁止运行脚本/","link":"","permalink":"http://example.com/2023/02/24/%E6%97%A0%E6%B3%95%E5%8A%A0%E8%BD%BD%E6%96%87%E4%BB%B6CUsersxxxDocumentsWindowsPowerShellprofile.ps1%EF%BC%8C%E5%9B%A0%E4%B8%BA%E5%9C%A8%E6%AD%A4%E7%B3%BB%E7%BB%9F%E4%B8%8A%E7%A6%81%E6%AD%A2%E8%BF%90%E8%A1%8C%E8%84%9A%E6%9C%AC/","excerpt":"无法加载文件C:\\Users\\xxx\\Documents\\WindowsPowerShell\\profile.ps1，因为在此系统上禁止运行脚本","text":"无法加载文件C:\\Users\\xxx\\Documents\\WindowsPowerShell\\profile.ps1，因为在此系统上禁止运行脚本 问题描述打开 PowerShell 提示如下报错信息。 123456789101112Windows PowerShell版权所有（C） Microsoft Corporation。保留所有权利。安装最新的 PowerShell，了解新功能和改进！https://aka.ms/PSWindows. : 无法加载文件 C:\\Users\\87897\\Documents\\WindowsPowerShell\\profile.ps1，因为在此系统上禁止运行脚本。有关详细信息，请参阅 https:/go.microsoft.com/fwlink/?LinkID=135170 中的 about_Execution_Policies。所在位置 行:1 字符: 3+ . &#x27;C:\\Users\\87897\\Documents\\WindowsPowerShell\\profile.ps1&#x27;+ ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ + CategoryInfo : SecurityError: (:) []，PSSecurityException1234567891011 原因分析输入 get-ExecutionPolicy 输出 Restricted，即脚本执行策略受限。 123PS C:\\Windows\\system32&gt; get-ExecutionPolicyRestricted12 解决方案更换脚本执行策略：set-ExecutionPolicy RemoteSigned，然后输入 Y。 1234567PS C:\\Windows\\system32&gt; set-ExecutionPolicy RemoteSigned执行策略更改执行策略可帮助你防止执行不信任的脚本。更改执行策略可能会产生安全风险，如 https:/go.microsoft.com/fwlink/?LinkID=135170中的 about_Execution_Policies 帮助主题所述。是否要更改执行策略?[Y] 是(Y) [A] 全是(A) [N] 否(N) [L] 全否(L) [S] 暂停(S) [?] 帮助 (默认值为“N”): Y123456 更换完成后，再次使用命令 get-ExecutionPolicy 查看脚本执行策略。 123PS C:\\Windows\\system32&gt; get-ExecutionPolicyRemoteSigned12 可以发现已经更改了。问题完美解决，over~~😊","categories":[{"name":"2023","slug":"2023","permalink":"http://example.com/categories/2023/"}],"tags":[{"name":"powershell","slug":"powershell","permalink":"http://example.com/tags/powershell/"}]},{"title":"anaconda安装其他东西","slug":"Win10下Anaconda使用conda activate报错Your shell has not been properly configured to use 'conda activate'","date":"2023-02-24T04:23:35.093Z","updated":"2023-03-08T05:18:49.483Z","comments":true,"path":"2023/02/24/Win10下Anaconda使用conda activate报错Your shell has not been properly configured to use 'conda activate'/","link":"","permalink":"http://example.com/2023/02/24/Win10%E4%B8%8BAnaconda%E4%BD%BF%E7%94%A8conda%20activate%E6%8A%A5%E9%94%99Your%20shell%20has%20not%20been%20properly%20configured%20to%20use%20'conda%20activate'/","excerpt":"Win10下Anaconda使用conda activate报错Your shell has not been properly configured to use ‘conda activate’","text":"Win10下Anaconda使用conda activate报错Your shell has not been properly configured to use ‘conda activate’ 1234567891011121314151617181920212223PS E:\\dijango&gt; conda activate baseCommandNotFoundError: Your shell has not been properly configured to use &#x27;conda activate&#x27;.If using &#x27;conda activate&#x27; from a batch script, change yourinvocation to &#x27;CALL conda.bat activate&#x27;.To initialize your shell, run $ conda init &lt;SHELL_NAME&gt;Currently supported shells are:- bash- cmd.exe- fish- tcsh- xonsh- zsh- powershellSee &#x27;conda init --help&#x27; for more information and options.IMPORTANT: You may need to close and restart your shell after running &#x27;conda init&#x27;. 先以管理员身份打开cmd。试一下conda activate 环境名称。如果命令行提示 1Your shell has not been properly configured to use ‘conda activate’. 然后下面还提示 conda init &lt;SHELL NAME&gt; 就按照他的要求，输入一下 conda init cmd.exe 或者 conda init powershell 这两条都试试，回车，重启cmd说不定就好了。反正我好了。","categories":[{"name":"2023","slug":"2023","permalink":"http://example.com/categories/2023/"}],"tags":[{"name":"anaconda","slug":"anaconda","permalink":"http://example.com/tags/anaconda/"}]},{"title":"闭包","slug":"闭包","date":"2023-02-23T14:17:31.662Z","updated":"2023-02-23T13:50:32.190Z","comments":true,"path":"2023/02/23/闭包/","link":"","permalink":"http://example.com/2023/02/23/%E9%97%AD%E5%8C%85/","excerpt":"闭包","text":"闭包 12345678910111213141516171819202122232425262728// 1.污染环境的全局变量实现函数执行一次次数减一 var a=10; function fa()&#123; a--; console.log(a); &#125; // 2.那就换成局部变量试试 function fb()&#123; var a=10; a--; console.log(a); &#125;/*它居然不动了*/ // 3.闭包 function fc()&#123; let a=10; function fd()&#123; a--; console.log(a); &#125; return fd; &#125; var fm=fc();//完成这句才算闭包 // 总结 // 1.有嵌套函数 // 2.内部函数引用外部作用域 // 3.返回值是函数 // 4.船舰一个对象函数，让其长期驻留","categories":[{"name":"2022","slug":"2022","permalink":"http://example.com/categories/2022/"}],"tags":[{"name":"js","slug":"js","permalink":"http://example.com/tags/js/"}]},{"title":"reat-router","slug":"router","date":"2023-02-23T14:17:31.647Z","updated":"2023-02-23T13:50:45.673Z","comments":true,"path":"2023/02/23/router/","link":"","permalink":"http://example.com/2023/02/23/router/","excerpt":"随意使用您选择的打包器，例如 Create React App 1npx create-react-app router-tutorial","text":"随意使用您选择的打包器，例如 Create React App 1npx create-react-app router-tutorial 然后安装 React Router 依赖项： 12cd router-tutorialnpm install react-router-dom@6 history@5 然后编辑你的App.js，让它变得很无聊: 1234567export default function App() &#123; return ( &lt;div&gt; &lt;h1&gt;Bookkeeper!&lt;/h1&gt; &lt;/div&gt; );&#125; 最后，确认index.js or main.jsx（取决于你的打包工具）是可用的： root渲染App 123456import &#123; render &#125; from &quot;react-dom&quot;;import App from &quot;./App&quot;;const rootElement = document.getElementById(&quot;root&quot;);render(&lt;App /&gt;, rootElement); 然后是删了一点东西 启动您的React应用： 1npm start 连接路由首先，我们想把你的应用连接到路由: import ‘ BrowserRouter ‘，并用它包裹你的整个应用。(修改index.js) 1234567891011import &#123; render &#125; from &quot;react-dom&quot;;import &#123; BrowserRouter &#125; from &quot;react-router-dom&quot;;import App from &quot;./App&quot;;const rootElement = document.getElementById(&quot;root&quot;);render( &lt;BrowserRouter&gt; &lt;App /&gt; &lt;/BrowserRouter&gt;, rootElement); 应用程序中没有任何变化，但现在我们已准备好开始处理路由。 添加一些链接打开 src&#x2F;App.js、导入 Link 并添加一些全局导航。注：在本教程中不要对待样式太认真，我们只是为了方便而使用内联样式，你可以根据需要设置样式。 123456789101112131415161718import &#123; Link &#125; from &quot;react-router-dom&quot;;export default function App() &#123; return ( &lt;div&gt; &lt;h1&gt;Bookkeeper&lt;/h1&gt; &lt;nav style=&#123;&#123; borderBottom: &quot;solid 1px&quot;, paddingBottom: &quot;1rem&quot; &#125;&#125; &gt; &lt;Link to=&quot;/invoices&quot;&gt;Invoices&lt;/Link&gt; |&#123;&quot; &quot;&#125; &lt;Link to=&quot;/expenses&quot;&gt;Expenses&lt;/Link&gt; &lt;/nav&gt; &lt;/div&gt; );&#125; 单击链接和后退&#x2F;前进按钮。React Router 现在正在控制 URL！ 我们还没有在 URL 更改时呈现任何路由，但 Link 可以更改 URL，而不会导致整个页面重新加载。 添加一些路由添加几个新文件： src/routes/invoices.jsx src/routes/expenses.jsx (文件的位置并不重要，但是当你想要自动生成后端API，服务器渲染，代码分割或者更多的功能时，像这样命名你的文件可以很容易地将这个应用程序移植到其他项目，Remix😉) 现在在文件中加入以下代码： expenses.jsx 1234567export default function Expenses() &#123; return ( &lt;main style=&#123;&#123; padding: &quot;1rem 0&quot; &#125;&#125;&gt; &lt;h2&gt;Expenses&lt;/h2&gt; &lt;/main&gt; );&#125; invoices.jsx 1234567export default function Invoices() &#123; return ( &lt;main style=&#123;&#123; padding: &quot;1rem 0&quot; &#125;&#125;&gt; &lt;h2&gt;Invoices&lt;/h2&gt; &lt;/main&gt; );&#125; 最后，让我们通过在main.jsx或者index.js 中创建我们的第一个“路由配置”来让 React Router 在不同的 URL 上呈现我们的界面。 123456789101112131415161718192021import &#123; render &#125; from &quot;react-dom&quot;;import &#123; BrowserRouter, Routes, Route&#125; from &quot;react-router-dom&quot;;import App from &quot;./App&quot;;import Expenses from &quot;./routes/expenses&quot;;import Invoices from &quot;./routes/invoices&quot;;const rootElement = document.getElementById(&quot;root&quot;);render( &lt;BrowserRouter&gt; &lt;Routes&gt; &lt;Route path=&quot;/&quot; element=&#123;&lt;App /&gt;&#125; /&gt; &lt;Route path=&quot;expenses&quot; element=&#123;&lt;Expenses /&gt;&#125; /&gt; &lt;Route path=&quot;invoices&quot; element=&#123;&lt;Invoices /&gt;&#125; /&gt; &lt;/Routes&gt; &lt;/BrowserRouter&gt;, rootElement); 注意：当路由为”&#x2F;“时它渲染App组件，在”&#x2F;invoices”时它渲染Invoices组件。 所以到这里我们可以看出，点击后会整页都会变换掉 嵌套路由你可能已经注意到，当点击链接时，“App”中的布局会消失。共享布局是一件令人头疼的事情。我们已经知道，大多数UI都是一系列嵌套布局，这些布局总会映射到URL上，所以这个思路被直接植入到React Router中。 12345678910111213141516171819202122import &#123; render &#125; from &quot;react-dom&quot;;import &#123; BrowserRouter, Routes, Route&#125; from &quot;react-router-dom&quot;;import App from &quot;./App&quot;;import Expenses from &quot;./routes/expenses&quot;;import Invoices from &quot;./routes/invoices&quot;;const rootElement = document.getElementById(&quot;root&quot;);render( &lt;BrowserRouter&gt; &lt;Routes&gt; &lt;Route path=&quot;/&quot; element=&#123;&lt;App /&gt;&#125;&gt; &lt;Route path=&quot;expenses&quot; element=&#123;&lt;Expenses /&gt;&#125; /&gt; &lt;Route path=&quot;invoices&quot; element=&#123;&lt;Invoices /&gt;&#125; /&gt; &lt;/Route&gt; &lt;/Routes&gt; &lt;/BrowserRouter&gt;, rootElement); 当路由有子节点时，它会做两件事： 它嵌套了 URL (&quot;/&quot; + &quot;expenses&quot; 和 &quot;/&quot; + &quot;invoices&quot;) 当子路由匹配时，它将嵌套共享布局的 UI 组件： 但是，为了使（2）生效，我们需要在App.jsx“父”路由中渲染一个 组件。 12345678910111213141516171819import &#123; Outlet, Link &#125; from &quot;react-router-dom&quot;;export default function App() &#123; return ( &lt;div&gt; &lt;h1&gt;Bookkeeper&lt;/h1&gt; &lt;nav style=&#123;&#123; borderBottom: &quot;solid 1px&quot;, paddingBottom: &quot;1rem&quot; &#125;&#125; &gt; &lt;Link to=&quot;/invoices&quot;&gt;Invoices&lt;/Link&gt; |&#123;&quot; &quot;&#125; &lt;Link to=&quot;/expenses&quot;&gt;Expenses&lt;/Link&gt; &lt;/nav&gt; &lt;Outlet /&gt; &lt;/div&gt; );&#125; 现在再次单击。父路由 ( App.js) 仍然存在，而 &lt;Outlet&gt; 在两个子路由 (&lt;Invoices&gt; 和 &lt;Expenses&gt;)之间切换！ 正如我们稍后将看到的，这适用于路由层次结构的任何级别，并且非常强大。 列出发票通常你会从某个地方的服务器获取数据，但在本教程中，让我们造一些数据，这样我们就可以专注于路由。 创建一个文件src&#x2F;data.js并将其复制&#x2F;粘贴到那里： 123456789101112131415161718192021222324252627282930313233343536let invoices = [ &#123; name: &quot;Santa Monica&quot;, number: 1995, amount: &quot;$10,800&quot;, due: &quot;12/05/1995&quot; &#125;, &#123; name: &quot;Stankonia&quot;, number: 2000, amount: &quot;$8,000&quot;, due: &quot;10/31/2000&quot; &#125;, &#123; name: &quot;Ocean Avenue&quot;, number: 2003, amount: &quot;$9,500&quot;, due: &quot;07/22/2003&quot; &#125;, &#123; name: &quot;Tubthumper&quot;, number: 1997, amount: &quot;$14,000&quot;, due: &quot;09/01/1997&quot; &#125;, &#123; name: &quot;Wide Open Spaces&quot;, number: 1998, amount: &quot;$4,600&quot;, due: &quot;01/27/2998&quot; &#125;];export function getInvoices() &#123; return invoices;&#125; 现在我们可以在发票路由中使用它。让我们也添加一些样式来获得侧边栏导航布局。随意复制&#x2F;粘贴所有这些，但要特别注意 &lt;Link&gt; 组件需要 to 属性： 1234567891011121314151617181920212223242526import &#123; Link &#125; from &quot;react-router-dom&quot;;import &#123; getInvoices &#125; from &quot;../data&quot;;export default function Invoices() &#123; let invoices = getInvoices(); return ( &lt;div style=&#123;&#123; display: &quot;flex&quot; &#125;&#125;&gt; &lt;nav style=&#123;&#123; borderRight: &quot;solid 1px&quot;, padding: &quot;1rem&quot; &#125;&#125; &gt; &#123;invoices.map(invoice =&gt; ( &lt;Link style=&#123;&#123; display: &quot;block&quot;, margin: &quot;1rem 0&quot; &#125;&#125; to=&#123;`/invoices/$&#123;invoice.number&#125;`&#125; key=&#123;invoice.number&#125; &gt; &#123;invoice.name&#125; &lt;/Link&gt; ))&#125; &lt;/nav&gt; &lt;/div&gt; );&#125;","categories":[{"name":"2022","slug":"2022","permalink":"http://example.com/categories/2022/"}],"tags":[{"name":"reat","slug":"reat","permalink":"http://example.com/tags/reat/"}]},{"title":"匿名函数","slug":"匿名函数","date":"2023-02-23T14:17:31.647Z","updated":"2023-02-23T13:50:36.485Z","comments":true,"path":"2023/02/23/匿名函数/","link":"","permalink":"http://example.com/2023/02/23/%E5%8C%BF%E5%90%8D%E5%87%BD%E6%95%B0/","excerpt":"匿名函数","text":"匿名函数 123456789101112131415161718// 1.表达式赋值给变量来使用var fa =function()&#123; console.log(20);&#125;fa();// 2.当作函数来被调用setTimeout(function()&#123;console.log(30);&#125;,1000);// 3.通过函数嵌套当成闭包里的返回函数来调用function fb()&#123; return function()&#123;console.log(40);&#125;&#125;var fm=fb();fm();// 4.函数自己调用自己，也就是自调用。!function()&#123;console.log(50);&#125;();//匿名函数智能被调用或是自调用。//带参数的匿名函数自调用!function(a,b)&#123;console.log(a+b);&#125;(40,50);","categories":[{"name":"2022","slug":"2022","permalink":"http://example.com/categories/2022/"}],"tags":[{"name":"js","slug":"js","permalink":"http://example.com/tags/js/"}]},{"title":"回调函数","slug":"回调函数","date":"2023-02-23T14:17:31.647Z","updated":"2023-02-23T13:50:29.285Z","comments":true,"path":"2023/02/23/回调函数/","link":"","permalink":"http://example.com/2023/02/23/%E5%9B%9E%E8%B0%83%E5%87%BD%E6%95%B0/","excerpt":"回调函数","text":"回调函数 12345678910111213141516171819// 先定义一个函数，用来做短时间或无法脱身的事情，同步function sdo(does)&#123; console.log(does);&#125;// 在定义以恶搞函数，用来做长时间等待的事情，异步//用回调解决这个问题function ldo(doing,callback)&#123; setTimeout(()=&gt;&#123; console.log(doing); callback(&#x27;吃鸡&#x27;) &#125;,1000);&#125;// 接下来要开始迫害只因sdo(&#x27;买鸡&#x27;)sdo(&#x27;杀鸡&#x27;)ldo(&#x27;炖鸡&#x27;,sdo)//===&gt;函数作为参数// sdo(&#x27;吃鸡&#x27;)// 会发现不对劲","categories":[{"name":"2022","slug":"2022","permalink":"http://example.com/categories/2022/"}],"tags":[{"name":"js","slug":"js","permalink":"http://example.com/tags/js/"}]},{"title":"箭头函数","slug":"箭头函数","date":"2023-02-23T14:17:31.647Z","updated":"2023-02-23T13:50:33.998Z","comments":true,"path":"2023/02/23/箭头函数/","link":"","permalink":"http://example.com/2023/02/23/%E7%AE%AD%E5%A4%B4%E5%87%BD%E6%95%B0/","excerpt":"箭头函数","text":"箭头函数 12345678910111213141516// 1.箭头函数常见写法let fun1=(a,b)=&gt;&#123;return a+b;&#125;// 2.箭头函数没有参数，那么也要写括号let fun2=()=&gt;&#123;console.log(&#x27;你好&#x27;);&#125;// 3.如果只有一个参数，那么括号可以省略let fun3=name=&gt;&#123;console.log(`你好$&#123;name&#125;`);&#125;// 4.如果函数体只有一句执行代码，那么可以省略大括号，同时代码默认会被ruturn出去let fun4=name=&gt;`你好$&#123;name&#125;`;console.log(fun4(&#x27;小明&#x27;));// 5.箭头函数没有自己的this，他的this是来自于上层作用域的this let obj=&#123; fun5()&#123;console.log(&#x27;fun5:&#x27;,this);&#125;, fun6:()=&gt;&#123;console.log(&#x27;fun6:&#x27;,this);&#125; &#125; obj.fun5(); obj.fun6();","categories":[{"name":"2022","slug":"2022","permalink":"http://example.com/categories/2022/"}],"tags":[{"name":"js","slug":"js","permalink":"http://example.com/tags/js/"}]},{"title":"解决bash hexo command not found","slug":"解决bash hexo command not found","date":"2023-02-23T14:17:31.647Z","updated":"2023-03-01T07:08:49.612Z","comments":true,"path":"2023/02/23/解决bash hexo command not found/","link":"","permalink":"http://example.com/2023/02/23/%E8%A7%A3%E5%86%B3bash%20hexo%20command%20not%20found/","excerpt":"解决bash: hexo: command not found","text":"解决bash: hexo: command not found 检查 nodejs 和 npm 是否正常，依次输入命令 node -v 和 npm -v 看看是否有相关版本信息 出现了版本信息就证明 nodejs 和 npm 是没有问题的，那么就应该是环境变量的配置问题了，在【此电脑】右键【属性】，依次选择【高级系统设置】-【环境变量】，选择系统变量 Path，将 node_modules 下的 .bin 文件路径添加到 Path 里面 注意你的博客目录下应该有两个 node_modules 文件夹 F:\\blog 和F:\\blog\\BLOG 我是加了第一个module在环境变量 别的博主有的加了第二个module 总之自己试一下按哪个 环境变量添加好了之后重新打开 git 即可运行 hexo 命令，如果此时仍然无法执行 hexo 命令，那就只能拿出终极绝招了，运行命令 npm install hexo-cli -g 重新安装 hexo 即可！","categories":[{"name":"2023","slug":"2023","permalink":"http://example.com/categories/2023/"}],"tags":[{"name":"hexo","slug":"hexo","permalink":"http://example.com/tags/hexo/"}]},{"title":"PyQt5显示图片","slug":"PyQt5显示图片","date":"2023-02-23T14:17:31.640Z","updated":"2023-02-23T14:03:39.746Z","comments":true,"path":"2023/02/23/PyQt5显示图片/","link":"","permalink":"http://example.com/2023/02/23/PyQt5%E6%98%BE%E7%A4%BA%E5%9B%BE%E7%89%87/","excerpt":"PyQt5显示图片","text":"PyQt5显示图片 123redImg=QImage()QImage.load(redImg,&#x27;path&#x27;,format=&#x27;png&#x27;)self.label_3.setPixmap(QtGui.QPixmap(redImg)) 123img_path=&#x27;path&#x27;self.showImage = QPixmap(img_path).scaled(self.label_3.width(), self.label_3.height()) # 适应窗口大小self.label_3.setPixmap(self.showImage) # 显示图片 1234567image=cv2.imread(&#x27;path&#x27;)def showImageRed(self): self.image_1 = self.image self.image_1 = QtGui.QImage(self.image_1.data, self.image_1.shape[1],self.image_1.shape[0],QtGui.QImage.Format_RGB888).rgbSwapped() self.label_3.setPixmap(QtGui.QPixmap.fromImage(self.image_1)) 第三种方法可能会有斜影子，修改成下方这样 1234def showImageRed(self): self.image_1 = self.image self.image_1 = QtGui.QImage(self.image_1.data, self.image_1.shape[1], self.image_1.shape[0],self.image_1.shape[1]*3, QtGui.QImage.Format_RGB888).rgbSwapped() self.label_3.setPixmap(QtGui.QPixmap.fromImage(self.image_1)) 感觉应该是三通道问题","categories":[{"name":"2022","slug":"2022","permalink":"http://example.com/categories/2022/"}],"tags":[{"name":"PyQt5","slug":"PyQt5","permalink":"http://example.com/tags/PyQt5/"}]},{"title":"Hello World","slug":"hello-world","date":"2023-02-23T14:17:31.624Z","updated":"2023-02-06T13:37:47.659Z","comments":true,"path":"2023/02/23/hello-world/","link":"","permalink":"http://example.com/2023/02/23/hello-world/","excerpt":"hello","text":"hello Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new &quot;My New Post&quot; More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","categories":[],"tags":[]},{"title":"maven 找不到依赖项 javax.servlet:servlet-api:${servlet-api.version}","slug":"maven","date":"2023-02-23T14:17:31.624Z","updated":"2023-02-23T14:10:17.356Z","comments":true,"path":"2023/02/23/maven/","link":"","permalink":"http://example.com/2023/02/23/maven/","excerpt":"找不到依赖项 javax.servlet:servlet-api:${servlet-api.version}1.下载maven百度","text":"找不到依赖项 javax.servlet:servlet-api:${servlet-api.version}1.下载maven百度 2.maven仓库查找 https://mvnrepository.com/ 直接搜索 比如 直接搜索 然后 点击之后往下移动 找到这一行 贴到pom.xml文件里 坐标组成 配置本地仓库 中央仓库 id唯一标识符，用来区分不同的mirror元素 mirrorOf代替哪个仓库 url镜像的URL","categories":[{"name":"2023","slug":"2023","permalink":"http://example.com/categories/2023/"}],"tags":[{"name":"maven","slug":"maven","permalink":"http://example.com/tags/maven/"}]},{"title":"npm install 包，没有报错，提示安装成功，但是项目中没有出现node_modules也没有安装的包","slug":"npm npm install hexo-cli -g","date":"2023-02-23T14:17:31.624Z","updated":"2023-03-01T07:07:25.030Z","comments":true,"path":"2023/02/23/npm npm install hexo-cli -g/","link":"","permalink":"http://example.com/2023/02/23/npm%20npm%20install%20hexo-cli%20-g/","excerpt":"npm install 包，没有报错，提示安装成功，但是项目中没有出现node_modules也没有安装的包1npm install hexo-cli -g","text":"npm install 包，没有报错，提示安装成功，但是项目中没有出现node_modules也没有安装的包1npm install hexo-cli -g 在当前文件夹目录下npm安装 hexo-cli -g 在当前文件夹不显示 因为这是全局安装 所以会跑到node.js文件夹目录底下 去这边找会发现一个hexo-cli的文件夹 点击这个博客[https://blog.csdn.net/qq_38613992/article/details/103769192] 查看npm的配置 1npm config list 一开始我是没有global&#x3D;？？？ 的 2.查看全局下，是否有自己安装的包 123npm root -g//获取到全局安装目录 一般看上面那个F盘的图，会在那里 3.修改npm配置信息，查看 图例1，global属性是否安装到全局，如果你的这里是true，那么，就算你安装一个包时，没有写-g，它也会自动将你的包安装到全局！ — 修改配置信息 方法一：命令行输入 123npm config set global=false，npm config set global=false 再次查看配置，确认是否修改 1npm config list 然后再 1npm install hexo-cli 后面不要-g就会在自己的文件夹里出现node_moudle了 你可以试试有-g的&#96;&#96;&#96;npm install hexo-cli&#96;&#96;，这样的话，就又会跑到node.js的global的moudle的文件夹里了 安装完成，如图","categories":[{"name":"2023","slug":"2023","permalink":"http://example.com/categories/2023/"}],"tags":[{"name":"hexo","slug":"hexo","permalink":"http://example.com/tags/hexo/"}]},{"title":"mysql报错ERROR 1045 (28000) Access denied for user 'root'@'localhost' (using password:NO)","slug":"mysql启动","date":"2023-02-23T14:17:31.624Z","updated":"2023-02-23T14:12:54.315Z","comments":true,"path":"2023/02/23/mysql启动/","link":"","permalink":"http://example.com/2023/02/23/mysql%E5%90%AF%E5%8A%A8/","excerpt":"ERROR 1045 (28000): Access denied for user ‘root‘@’localhost’ (using password: NO)","text":"ERROR 1045 (28000): Access denied for user ‘root‘@’localhost’ (using password: NO) E:\\jeecg\\jeecg-boot-master\\db\\jeecgboot-mysql-5.7.sql","categories":[{"name":"2023","slug":"2023","permalink":"http://example.com/categories/2023/"}],"tags":[{"name":"mysql","slug":"mysql","permalink":"http://example.com/tags/mysql/"}]},{"title":"PyQt5","slug":"pyqt5","date":"2023-02-23T14:17:31.624Z","updated":"2023-02-23T14:03:21.742Z","comments":true,"path":"2023/02/23/pyqt5/","link":"","permalink":"http://example.com/2023/02/23/pyqt5/","excerpt":"安装PyQt5打开Anaconda Promt，切换到对应环境输入：","text":"安装PyQt5打开Anaconda Promt，切换到对应环境输入： 1pip install PyQt5 -i https://pypi.douban.com/simple 安装PyQt5-tools 12pip install PyQt5-tools -i https://pypi.douban.com/simple 打开 Anaconda prompt 输入: 1PyQt5-tools designer 它有很多东西 1234designerinstalluicqmlsceneqmltestrunner 不知道其他是啥（待解决） 直接点击创建（main window） 随便拖两个button上去 另存为 然后回到anaconda那个窗口， 我们要把这个.ui文件转化为py文件 方法一： 1python -m PyQt5.uic.pyuic test.ui -o test.py 要切换到相对应的文件夹路径下再运行 已经生成了 方法二： 太烦了，不写 F:\\anaconda\\EMPYTY\\pkgs\\pyqt-5.9.2-py39hd77b12b_6\\Library\\bin 大概在这个路径里面 很鸡肋，虽然写的前面的那玩意少了点，但是要吧ui移到当前文件夹里面，辣鸡 1pyuic5 test.ui -o test.py 方法三：直接使用扩展程序打开 pycharm扩展程序（vscode没找到在哪） 不太好搞（不想写，没看懂） 综上，用方法一 1.水平布局 回到vscode里面 123456789101112131415import sysimport shuipingfrom PyQt5.QtWidgets import QApplication,QMainWindow#创建QApplication类的实例app=QApplication(sys.argv)#创建一个窗口mainWindow=QMainWindow()#向主窗口添加控件ui=shuiping.Ui_MainWindow()ui.setupUi(mainWindow)# 显示窗口mainWindow.show()# 进入程序的主循环、并通过exit函数确保主循环安全结束sys.exit(app.exec_()) 表单布局 垂直布局 栅格布局 尺寸策略 伙伴关系 tab顺序 编辑信号和槽","categories":[{"name":"2022","slug":"2022","permalink":"http://example.com/categories/2022/"}],"tags":[{"name":"PyQt5","slug":"PyQt5","permalink":"http://example.com/tags/PyQt5/"}]},{"title":"C++文件操作之freopen","slug":"C++文件操作之freopen","date":"2023-02-23T14:17:31.609Z","updated":"2023-02-23T13:51:59.659Z","comments":true,"path":"2023/02/23/C++文件操作之freopen/","link":"","permalink":"http://example.com/2023/02/23/C++%E6%96%87%E4%BB%B6%E6%93%8D%E4%BD%9C%E4%B9%8Bfreopen/","excerpt":"C++文件操作之freopen","text":"C++文件操作之freopen 12freopen(&quot;xxx.in&quot;,&quot;r&quot;,stdin); //输入文件freopen(&quot;xxx.out&quot;,&quot;w&quot;,stdout); //输出文件 1234567891011121314#include&lt;cstdio&gt;#include&lt;iostream&gt;using namespace std;int main()&#123; freopen(&quot;a+b.in&quot;,&quot;r&quot;,stdin); freopen(&quot;a+b.out&quot;,&quot;w&quot;,stdout); //以上是模板 int a,b; cin&gt;&gt;a&gt;&gt;b; cout&lt;&lt;a+b&lt;&lt;endl; return 0;&#125;","categories":[{"name":"2023","slug":"2023","permalink":"http://example.com/categories/2023/"}],"tags":[{"name":"c++","slug":"c","permalink":"http://example.com/tags/c/"}]},{"title":"Failed to scan","slug":"Failed to scan [fileFmavenrepositoryorgspringframeworkspring-aspects5","date":"2023-02-23T14:17:31.609Z","updated":"2023-02-23T13:53:39.577Z","comments":true,"path":"2023/02/23/Failed to scan [fileFmavenrepositoryorgspringframeworkspring-aspects5/","link":"","permalink":"http://example.com/2023/02/23/Failed%20to%20scan%20[fileFmavenrepositoryorgspringframeworkspring-aspects5/","excerpt":"Failed to scan [file:&#x2F;F:&#x2F;maven&#x2F;repository&#x2F;org&#x2F;springframework&#x2F;spring-aspects&#x2F;5.1.9.RELEASE&#x2F;spring-aspects-5.1.9.RELEASE.jar] from classloader hierarchyjava.util.zip.ZipException: error in opening zip file","text":"Failed to scan [file:&#x2F;F:&#x2F;maven&#x2F;repository&#x2F;org&#x2F;springframework&#x2F;spring-aspects&#x2F;5.1.9.RELEASE&#x2F;spring-aspects-5.1.9.RELEASE.jar] from classloader hierarchyjava.util.zip.ZipException: error in opening zip file 1mvn install:install-file -DgroupId=com.qiyuesuo.sdk -DartifactId=sdk-java -Dversion=3.4.1 -Dpackaging=jar -Dfile=D:\\jar\\sdk-java-3.4.1.jar 1F:\\maven\\repository\\org\\springframework\\spring-aspects\\5.1.9.RELEASE org.springframework.spring-aspects 12mvn install:install-file -DgroupId=org.springframework.spring-aspects-DartifactId=spring-aspects -Dversion=5.3.1 -Dpackaging=jar -Dfile=F:\\maven\\spring-aspects-5.3.1.jar mvn install:install-file -DgroupId&#x3D;org.springframework.spring-aspects-DartifactId&#x3D;spring-aspects -Dversion&#x3D;5.3.1 -Dpackaging&#x3D;jar -Dfile&#x3D;F:\\maven\\spring-aspects-5.3.1.jar","categories":[{"name":"2023","slug":"2023","permalink":"http://example.com/categories/2023/"}],"tags":[{"name":"maven","slug":"maven","permalink":"http://example.com/tags/maven/"}]},{"title":"之前的博客慢慢再修复，先把最近的东西放上来，sos！","slug":"breautiful","date":"2023-02-23T14:17:31.609Z","updated":"2023-02-23T13:41:12.493Z","comments":true,"path":"2023/02/23/breautiful/","link":"","permalink":"http://example.com/2023/02/23/breautiful/","excerpt":"","text":"之前的博客慢慢再修复，先把最近的东西放上来，sos！","categories":[{"name":"2023","slug":"2023","permalink":"http://example.com/categories/2023/"}],"tags":[{"name":"casual_talk","slug":"casual-talk","permalink":"http://example.com/tags/casual-talk/"}]}],"categories":[{"name":"2023","slug":"2023","permalink":"http://example.com/categories/2023/"},{"name":"202","slug":"202","permalink":"http://example.com/categories/202/"},{"name":"2022","slug":"2022","permalink":"http://example.com/categories/2022/"}],"tags":[{"name":"python","slug":"python","permalink":"http://example.com/tags/python/"},{"name":"linux_c++","slug":"linux-c","permalink":"http://example.com/tags/linux-c/"},{"name":"java","slug":"java","permalink":"http://example.com/tags/java/"},{"name":"casual_talk","slug":"casual-talk","permalink":"http://example.com/tags/casual-talk/"},{"name":"设计模式","slug":"设计模式","permalink":"http://example.com/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"},{"name":"vmware","slug":"vmware","permalink":"http://example.com/tags/vmware/"},{"name":"Spark","slug":"Spark","permalink":"http://example.com/tags/Spark/"},{"name":"mysql","slug":"mysql","permalink":"http://example.com/tags/mysql/"},{"name":"django","slug":"django","permalink":"http://example.com/tags/django/"},{"name":"powershell","slug":"powershell","permalink":"http://example.com/tags/powershell/"},{"name":"anaconda","slug":"anaconda","permalink":"http://example.com/tags/anaconda/"},{"name":"js","slug":"js","permalink":"http://example.com/tags/js/"},{"name":"reat","slug":"reat","permalink":"http://example.com/tags/reat/"},{"name":"hexo","slug":"hexo","permalink":"http://example.com/tags/hexo/"},{"name":"PyQt5","slug":"PyQt5","permalink":"http://example.com/tags/PyQt5/"},{"name":"maven","slug":"maven","permalink":"http://example.com/tags/maven/"},{"name":"c++","slug":"c","permalink":"http://example.com/tags/c/"}]}