<!DOCTYPE html><html lang="zh-CN"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=2"><meta name="theme-color" content="#222"><meta name="generator" content="Hexo 6.3.0"><link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png"><link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32.png"><link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16.png"><link rel="mask-icon" href="/images/logo.svg" color="#222"><link rel="stylesheet" href="/css/main.css"><link rel="stylesheet" href="/lib/font-awesome/css/all.min.css"><link rel="stylesheet" href="/lib/pace/pace-theme-material.min.css"><script src="/lib/pace/pace.min.js"></script><script id="hexo-configurations">var NexT=window.NexT||{},CONFIG={hostname:"example.com",root:"/",scheme:"Pisces",version:"7.8.0",exturl:!1,sidebar:{position:"left",display:"post",padding:18,offset:12,onmobile:!1},copycode:{enable:!1,show_result:!1,style:null},back2top:{enable:!0,sidebar:!1,scrollpercent:!1},bookmark:{enable:!1,color:"#222",save:"auto"},fancybox:!1,mediumzoom:!1,lazyload:!1,pangu:!1,comments:{style:"tabs",active:null,storage:!0,lazyload:!1,nav:null},algolia:{hits:{per_page:10},labels:{input_placeholder:"Search for Posts",hits_empty:"We didn't find any results for the search: ${query}",hits_stats:"${hits} results found in ${time} ms"}},localsearch:{enable:!1,trigger:"auto",top_n_per_article:1,unescape:!1,preload:!1},motion:{enable:!0,async:!1,transition:{post_block:"fadeIn",post_header:"slideDownIn",post_body:"slideDownIn",coll_header:"slideLeftIn",sidebar:"slideUpIn"}},path:"search.xml"}</script><meta name="description" content="Spark入门：RDD编程(1)"><meta property="og:type" content="article"><meta property="og:title" content="Spark入门：RDD编程（1）"><meta property="og:url" content="http://example.com/2023/03/20/spark/index.html"><meta property="og:site_name" content="睡觉万岁"><meta property="og:description" content="Spark入门：RDD编程(1)"><meta property="og:locale" content="zh_CN"><meta property="og:image" content="http://example.com/images/spark/1.png"><meta property="og:image" content="http://example.com/images/spark/2.png"><meta property="og:image" content="http://example.com/images/spark/3.png"><meta property="og:image" content="http://example.com/images/spark/14.png"><meta property="og:image" content="http://example.com/images/spark/4.png"><meta property="og:image" content="http://example.com/images/spark/5.png"><meta property="og:image" content="http://example.com/images/spark/6.png"><meta property="og:image" content="http://example.com/images/spark/7.png"><meta property="og:image" content="http://example.com/images/spark/8.png"><meta property="og:image" content="http://example.com/images/spark/9.png"><meta property="og:image" content="http://example.com/images/spark/10.png"><meta property="og:image" content="http://example.com/images/spark/11.png"><meta property="og:image" content="http://example.com/images/spark/12.png"><meta property="og:image" content="http://example.com/images/spark/13.png"><meta property="og:image" content="http://example.com/images/spark/15.png"><meta property="og:image" content="http://example.com/images/spark/16.png"><meta property="og:image" content="http://example.com/images/spark/17.png"><meta property="og:image" content="http://example.com/images/spark/18.png"><meta property="og:image" content="http://example.com/images/spark/20.png"><meta property="og:image" content="http://example.com/images/spark/21.png"><meta property="og:image" content="http://example.com/images/spark/22.png"><meta property="og:image" content="http://example.com/images/spark/24.png"><meta property="og:image" content="http://example.com/images/spark/23.png"><meta property="og:image" content="http://example.com/images/spark/26.png"><meta property="og:image" content="http://example.com/images/spark/25.png"><meta property="og:image" content="http://example.com/images/spark/27.png"><meta property="og:image" content="http://example.com/images/spark/28.png"><meta property="og:image" content="http://example.com/images/spark/29.png"><meta property="og:image" content="http://example.com/images/spark/30.png"><meta property="og:image" content="http://example.com/images/spark/31.png"><meta property="og:image" content="http://example.com/images/spark/33.png"><meta property="og:image" content="http://example.com/images/spark/32.png"><meta property="og:image" content="http://example.com/images/spark/34.png"><meta property="og:image" content="http://example.com/images/spark/35.png"><meta property="og:image" content="http://example.com/images/spark/37.png"><meta property="og:image" content="http://example.com/images/spark/38.png"><meta property="og:image" content="http://example.com/images/spark/39.png"><meta property="og:image" content="http://example.com/images/spark/40.png"><meta property="og:image" content="http://example.com/images/spark/41.png"><meta property="og:image" content="http://example.com/images/spark/42.png"><meta property="og:image" content="http://example.com/images/spark/43.png"><meta property="og:image" content="http://example.com/images/spark/44.png"><meta property="og:image" content="http://example.com/images/spark/45.png"><meta property="og:image" content="http://example.com/images/spark/46.png"><meta property="og:image" content="http://example.com/images/spark/47.png"><meta property="og:image" content="http://example.com/images/spark/48.png"><meta property="og:image" content="http://example.com/images/spark/49.png"><meta property="og:image" content="http://example.com/images/spark/50.png"><meta property="og:image" content="http://example.com/images/spark/51.png"><meta property="og:image" content="http://example.com/images/spark/52.png"><meta property="og:image" content="http://example.com/images/spark/53.png"><meta property="og:image" content="http://example.com/images/spark/54.png"><meta property="article:published_time" content="2023-03-20T14:19:48.651Z"><meta property="article:modified_time" content="2023-03-20T16:28:47.347Z"><meta property="article:author" content="毛"><meta property="article:tag" content="Spark"><meta name="twitter:card" content="summary"><meta name="twitter:image" content="http://example.com/images/spark/1.png"><link rel="canonical" href="http://example.com/2023/03/20/spark/"><script id="page-configurations">CONFIG.page={sidebar:"",isHome:!1,isPost:!0,lang:"zh-CN"}</script><title>Spark入门：RDD编程（1） | 睡觉万岁</title><noscript><style>.sidebar-inner,.use-motion .brand,.use-motion .collection-header,.use-motion .comments,.use-motion .menu-item,.use-motion .pagination,.use-motion .post-block,.use-motion .post-body,.use-motion .post-header{opacity:initial}.use-motion .site-subtitle,.use-motion .site-title{opacity:initial;top:initial}.use-motion .logo-line-before i{left:initial}.use-motion .logo-line-after i{right:initial}</style></noscript></head><script src="https://g.joyinshare.com/hc/ribbon.min.js" type="text/javascript"></script><body itemscope itemtype="http://schema.org/WebPage"><div class="container use-motion"><div class="headband"></div><a target="_blank" rel="noopener" href="https://github.com/maduit" class="github-corner" aria-label="View source on GitHub"><svg width="80" height="80" viewBox="0 0 250 250" style="fill:#64ceaa;color:#fff;position:absolute;top:0;border:0;left:0;transform:scale(-1,1)" aria-hidden="true"><path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"></path><path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2" fill="currentColor" style="transform-origin:130px 106px" class="octo-arm"></path><path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z" fill="currentColor" class="octo-body"></path></svg></a><style>.github-corner:hover .octo-arm{animation:octocat-wave 560ms ease-in-out}@keyframes octocat-wave{0%,100%{transform:rotate(0)}20%,60%{transform:rotate(-25deg)}40%,80%{transform:rotate(10deg)}}@media (max-width:500px){.github-corner:hover .octo-arm{animation:none}.github-corner .octo-arm{animation:octocat-wave 560ms ease-in-out}}</style><header class="header" itemscope itemtype="http://schema.org/WPHeader"><div class="header-inner"><div class="site-brand-container"><div class="site-nav-toggle"><div class="toggle" aria-label="切换导航栏"><span class="toggle-line toggle-line-first"></span> <span class="toggle-line toggle-line-middle"></span> <span class="toggle-line toggle-line-last"></span></div></div><div class="site-meta"><a href="/" class="brand" rel="start"><span class="logo-line-before"><i></i></span><h1 class="site-title">睡觉万岁</h1><span class="logo-line-after"><i></i></span></a></div><div class="site-nav-right"><div class="toggle popup-trigger"></div></div></div><nav class="site-nav"><ul id="menu" class="main-menu menu"><li class="menu-item menu-item-home"><a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a></li><li class="menu-item menu-item-about"><a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>关于</a></li><li class="menu-item menu-item-tags"><a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a></li><li class="menu-item menu-item-categories"><a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a></li><li class="menu-item menu-item-archives"><a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a></li><li class="menu-item menu-item-schedule"><a href="/schedule/" rel="section"><i class="fa fa-calendar fa-fw"></i>日程表</a></li></ul></nav></div></header><div class="back-to-top"><i class="fa fa-arrow-up"></i> <span>0%</span></div><main class="main"><div class="main-inner"><div class="content-wrap"><div class="content post posts-expand"><article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN"><link itemprop="mainEntityOfPage" href="http://example.com/2023/03/20/spark/"><span hidden itemprop="author" itemscope itemtype="http://schema.org/Person"><meta itemprop="image" content="/images/xiao.png"><meta itemprop="name" content="毛"><meta itemprop="description" content="在梦里啥都有"></span><span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization"><meta itemprop="name" content="睡觉万岁"></span><header class="post-header"><h1 class="post-title" itemprop="name headline">Spark入门：RDD编程（1）</h1><div class="post-meta"><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-calendar"></i> </span><span class="post-meta-item-text">发表于</span> <time title="创建时间：2023-03-20 22:19:48" itemprop="dateCreated datePublished" datetime="2023-03-20T22:19:48+08:00">2023-03-20</time> </span><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-calendar-check"></i> </span><span class="post-meta-item-text">更新于</span> <time title="修改时间：2023-03-21 00:28:47" itemprop="dateModified" datetime="2023-03-21T00:28:47+08:00">2023-03-21</time> </span><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-folder"></i> </span><span class="post-meta-item-text">分类于</span> <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/2023/" itemprop="url" rel="index"><span itemprop="name">2023</span></a> </span></span><span class="post-meta-item" title="阅读次数" id="busuanzi_container_page_pv" style="display:none"><span class="post-meta-item-icon"><i class="fa fa-eye"></i> </span><span class="post-meta-item-text">阅读次数：</span> <span id="busuanzi_value_page_pv"></span></span></div></header><div class="post-body" itemprop="articleBody"><h1 id="Spark入门：RDD编程-1"><a href="#Spark入门：RDD编程-1" class="headerlink" title="Spark入门：RDD编程(1)"></a>Spark入门：RDD编程(1)</h1><span id="more"></span><h1 id="4-1RDD编程基础"><a href="#4-1RDD编程基础" class="headerlink" title="4.1RDD编程基础"></a>4.1RDD编程基础</h1><h2 id="RDD创建"><a href="#RDD创建" class="headerlink" title="RDD创建"></a>RDD创建</h2><p>RDD可以通过两种方式创建：</p><ul><li>第一种：读取一个外部数据集。比如，从本地文件加载数据集，或者从HDFS文件系统、HBase、Cassandra、Amazon S3等外部数据源中加载数据集。Spark可以支持文本文件、SequenceFile文件（Hadoop提供的 SequenceFile是一个由二进制序列化过的key&#x2F;value的字节流组成的文本存储文件）和其他符合Hadoop InputFormat格式的文件。</li><li>第二种：调用SparkContext的parallelize方法，在Driver中一个已经存在的集合（数组）上创建</li></ul><p>在即将进行相关的实践操作之前，我们首先要登录Linux系统（本教程统一采用hadoop用户登录），然后，打开命令行“终端”，请按照下面的命令启动Hadoop中的HDFS组件：</p><h3 id="创建RDD之前的准备工作"><a href="#创建RDD之前的准备工作" class="headerlink" title="创建RDD之前的准备工作"></a>创建RDD之前的准备工作</h3><p>在即将进行相关的实践操作之前，我们首先要登录Linux系统（本教程统一采用hadoop用户登录），然后，打开命令行“终端”，请按照下面的命令启动Hadoop中的HDFS组件：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cd  /usr/local/hadoop</span><br><span class="line">./sbin/start-dfs.sh</span><br></pre></td></tr></table></figure><p>然后，我们按照下面命令启动spark-shell：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cd /usr/local/spark</span><br><span class="line">./bin/pyspark</span><br></pre></td></tr></table></figure><p><img src="/images/loading.gif" data-original="/images/spark/1.png" alt="1678715171189"></p><p>然后，新建第二个“终端”，方法是，在前面已经建设的第一个终端窗口的左上方，点击“终端”菜单，在弹出的子菜单中选择“新建终端”，就可以打开第二个终端窗口，现在，我们切换到第二个终端窗口，在第二个终端窗口中，执行以下命令，进入之前已经创建好的“&#x2F;usr&#x2F;local&#x2F;spark&#x2F;mycode&#x2F;”目录，在这个目录下新建rdd子目录，用来存放本章的代码和相关文件：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cd usr/local/spark/mycode/</span><br><span class="line">mkdir rdd</span><br></pre></td></tr></table></figure><p>然后，使用vim编辑器，在rdd目录下新建一个word.txt文件，你可以在文件里面随便输入几行英文语句用来测试。</p><p>经过上面的准备工作以后，我们就可以开始创建RDD了。</p><h3 id="从文件系统中加载数据创建RDD"><a href="#从文件系统中加载数据创建RDD" class="headerlink" title="从文件系统中加载数据创建RDD"></a>从文件系统中加载数据创建RDD</h3><p>Spark采用textFile()方法来从文件系统中加载数据创建RDD，该方法把文件的URI作为参数，这个URI可以是本地文件系统的地址，或者是分布式文件系统HDFS的地址，或者是Amazon S3的地址等等。<br>下面请切换回spark-shell窗口，看一下如何从本地文件系统中加载数据：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt;lines = sc.textFile(&quot;file:///usr/local/spark/mycode/rdd/word.txt&quot;)</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><img src="/images/loading.gif" data-original="/images/spark/2.png" alt="1678715444810"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt;lines.foreach(print)</span><br></pre></td></tr></table></figure><p><img src="/images/loading.gif" data-original="/images/spark/3.png" alt="1678715770877"></p><p><img src="/images/loading.gif" data-original="/images/spark/14.png" alt="1678720839060"></p><h3 id="加载HDFS中的文件"><a href="#加载HDFS中的文件" class="headerlink" title="加载HDFS中的文件"></a>加载HDFS中的文件</h3><p>为了能够读取HDFS中的文件，请首先启动Hadoop中的HDFS组件。注意，之前我们在“Spark安装”这章内容已经介绍了如何安装Hadoop和Spark，所以，这里我们可以使用以下命令直接启动Hadoop中的HDFS组件（由于用不到MapReduce组件，所以，不需要启动MapReduce或者YARN）。请到第二个终端窗口，使用Linux Shell命令提示符状态，然后输入下面命令：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cd /usr/local/hadoop</span><br><span class="line">./sbin/start-dfs.sh</span><br></pre></td></tr></table></figure><p><img src="/images/loading.gif" data-original="/images/spark/4.png" alt="1678715996913"></p><p>启动结束后，HDFS开始进入可用状态。如果你在HDFS文件系统中，还没有为当前Linux登录用户创建目录(本教程统一使用用户名hadoop登录Linux系统)，请使用下面命令创建：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./bin/hdfs dfs -mkdir -p /user/hadoop</span><br></pre></td></tr></table></figure><p>也就是说，HDFS文件系统为Linux登录用户开辟的默认目录是“&#x2F;user&#x2F;用户名”（注意：是user，不是usr），本教程统一使用用户名hadoop登录Linux系统，所以，上面创建了“&#x2F;user&#x2F;hadoop”目录，再次强调，这个目录是在HDFS文件系统中，不在本地文件系统中。创建好以后，下面我们使用命令查看一下HDFS文件系统中的目录和文件：</p><p><img src="/images/loading.gif" data-original="/images/spark/5.png" alt="1678716107634"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./bin/hdfs dfs -ls .</span><br></pre></td></tr></table></figure><p>** 但这个命令我搞不出来，显示的是这个</p><p><img src="/images/loading.gif" data-original="/images/spark/6.png" alt="1678717090642"></p><p>–</p><p>上面命令中，最后一个点号“.”，表示要查看Linux当前登录用户hadoop在HDFS文件系统中与hadoop对应的目录下的文件，也就是查看HDFS文件系统中“&#x2F;user&#x2F;hadoop&#x2F;”目录下的文件，所以，下面两条命令是等价的：</p><p>–</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">./bin/hdfs dfs -ls .</span><br><span class="line">./bin/hdfs dfs -ls /user/hadoop</span><br></pre></td></tr></table></figure><p>你自己可以试一试，只有第二个可以用</p><p><img src="/images/loading.gif" data-original="/images/spark/7.png" alt="1678717187423"></p><p>如果要查看HDFS文件系统根目录下的内容，需要使用下面命令：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./bin/hdfs dfs -ls /</span><br></pre></td></tr></table></figure><p>然后输出的东西见上面那个图，有一个items</p><p>下面，我们把本地文件系统中的“&#x2F;usr&#x2F;local&#x2F;spark&#x2F;mycode&#x2F;rdd&#x2F;word.txt”上传到分布式文件系统HDFS中（放到hadoop用户目录下）：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./bin/hdfs dfs -put /usr/local/spark/mycode/rdd/word.txt /user/hadoop</span><br></pre></td></tr></table></figure><p><img src="/images/loading.gif" data-original="/images/spark/8.png" alt="1678717295097"></p><p>然后，用命令查看一下HDFS的hadoop用户目录下是否多了word.txt文件，可以使用下面命令列出hadoop目录下的内容：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./bin/hdfs dfs -ls /</span><br></pre></td></tr></table></figure><p><img src="/images/loading.gif" data-original="/images/spark/9.png" alt="1678717376742"></p><p>可以看到，确实多了一个word.txt文件，我们使用cat命令查看一个HDFS中的word.txt文件的内容，命令如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./bin/hdfs dfs -cat ./word.txt</span><br></pre></td></tr></table></figure><p><img src="/images/loading.gif" data-original="/images/spark/10.png" alt="1678717420477"></p><p>上面命令执行后，就会看到HDFS中word.txt的内容了。</p><p>现在，让我们切换回到spark-shell窗口，编写语句从HDFS中加载word.txt文件，并显示第一行文本内容：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt;lines= sc.textFile(&quot;hdfs://localhost:9000/user/hadoop/word.txt&quot;)</span><br><span class="line">&gt;&gt;&gt;lines=sc.foreach(print)</span><br></pre></td></tr></table></figure><p><img src="/images/loading.gif" data-original="/images/spark/11.png" alt="1678717605626"></p><p><img src="/images/loading.gif" data-original="/images/spark/12.png" alt="1678717639868"></p><p>注意，上面三条命令是完全等价的命令，只不过使用了不同的目录形式，你可以使用其中任意一条命令完成数据加载操作。</p><p>在使用Spark读取文件时，需要说明以下几点：<br>（1）如果使用了本地文件系统的路径，那么，必须要保证在所有的worker节点上，也都能够采用相同的路径访问到该文件，比如，可以把该文件拷贝到每个worker节点上，或者也可以使用网络挂载共享文件系统。<br>（2）textFile()方法的输入参数，可以是文件名，也可以是目录，也可以是压缩文件等。比如，textFile(“&#x2F;my&#x2F;directory”), textFile(“&#x2F;my&#x2F;directory&#x2F;<em>.txt”), and textFile(“&#x2F;my&#x2F;directory&#x2F;</em>.gz”).<br>（3）textFile()方法也可以接受第2个输入参数（可选），用来指定分区的数目。默认情况下，Spark会为HDFS的每个block创建一个分区（HDFS中每个block默认是128MB）。你也可以提供一个比block数量更大的值作为分区数目，但是，你不能提供一个小于block数量的值作为分区数目。</p><h3 id="通过并行集合（数组）创建RDD"><a href="#通过并行集合（数组）创建RDD" class="headerlink" title="通过并行集合（数组）创建RDD"></a>通过并行集合（数组）创建RDD</h3><p>可以调用SparkContext的parallelize方法，在Driver中一个已经存在的集合（数组）上创建。<br>下面请在spark-shell中操作：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt;array = [1,2,3,4,5]</span><br><span class="line">&gt;&gt;&gt;rdd = sc.parallelize(array)</span><br><span class="line">&gt;&gt;&gt;rdd.foreach(print)</span><br></pre></td></tr></table></figure><p><img src="/images/loading.gif" data-original="/images/spark/13.png" alt="1678720471787"></p><p><img src="/images/loading.gif" data-original="/images/spark/15.png" alt="1678720865514"></p><h2 id="RDD操作"><a href="#RDD操作" class="headerlink" title="RDD操作"></a>RDD操作</h2><p>RDD被创建好以后，在后续使用过程中一般会发生两种操作：<br>*  转换（Transformation）： 基于现有的数据集创建一个新的数据集。<br>*  行动（Action）：在数据集上进行运算，返回计算值。</p><h3 id="Ⅰ转换操作"><a href="#Ⅰ转换操作" class="headerlink" title="Ⅰ转换操作"></a>Ⅰ转换操作</h3><p>对于RDD而言，每一次转换操作都会产生不同的RDD，供给下一个“转换”使用。转换得到的RDD是惰性求值的，也就是说，整个转换过程只是记录了转换的轨迹，并不会发生真正的计算，只有遇到行动操作时，才会发生真正的计算，开始从血缘关系源头开始，进行物理的转换操作。<br>下面列出一些常见的转换操作（Transformation API）：<br>* filter(func)：筛选出满足函数func的元素，并返回一个新的数据集<br>* map(func)：将每个元素传递到函数func中，并将结果返回为一个新的数据集<br>* flatMap(func)：与map()相似，但每个输入元素都可以映射到0或多个输出结果<br>* groupByKey()：应用于(K,V)键值对的数据集时，返回一个新的(K, Iterable)形式的数据集<br>* reduceByKey(func)：应用于(K,V)键值对的数据集时，返回一个新的(K, V)形式的数据集，其中的每个值是将每个key传递到函数func中进行聚合</p><p><img src="/images/loading.gif" data-original="/images/spark/16.png" alt="1678720959522"></p><p><img src="/images/loading.gif" data-original="/images/spark/17.png" alt="1678720974857"></p><h4 id="1-filter-func"><a href="#1-filter-func" class="headerlink" title="1.filter(func)"></a>1.filter(func)</h4><p><img src="/images/loading.gif" data-original="/images/spark/18.png" alt="1678720994986"></p><p>好吧，这个书上说要把word.txt写成</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Hadoop is good</span><br><span class="line"></span><br><span class="line">Spark is fast</span><br><span class="line"></span><br><span class="line">Spark is better</span><br></pre></td></tr></table></figure><p>那我们就</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cd /usr/local/spark/mycode/rdd</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gedit word.txt</span><br></pre></td></tr></table></figure><p>然后再</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt;lines=sc.textFile(&quot;file:///usr/local/spark/mycode/rdd/word.txt&quot;)</span><br><span class="line">&gt;&gt;&gt;linesWithSpark = lines.filter(lambda line: &quot;Spark&quot; in line)</span><br><span class="line">&gt;&gt;&gt;linesWithSpark.foreach(print)</span><br></pre></td></tr></table></figure><p><img src="/images/loading.gif" data-original="/images/spark/20.png" alt="1678722624927"></p><p>上面的代码中，lines就是一个RDD。lines.filter()会遍历lines中的每行文本，并对每行文本执行括号中的匿名函数，也就是执行Lamda表达式：line &#x3D;&gt; line.contains(“Spark”)，在执行Lamda表达式时，会把当前遍历到的这行文本内容赋值给参数line，然后，执行处理逻辑line.contains(“Spark”)，也就是只有当改行文本包含“Spark”才满足条件，才会被放入到结果集中。最后，等到lines集合遍历结束后，就会得到一个结果集，这个结果集中包含了所有包含“Spark”的行。最后，对这个结果集调用count()，这是一个行动操作，会计算出结果集中的元素个数。</p><h4 id="2-map-func"><a href="#2-map-func" class="headerlink" title="2.map(func)"></a>2.map(func)</h4><p><img src="/images/loading.gif" data-original="/images/spark/21.png" alt="1678724709366"></p><p>map(func)：将每个元素传递到函数func中，并将结果返回为一个新的数据集</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; data =[1,2,3,4,5]</span><br><span class="line">&gt;&gt;&gt; rdd1 = sc.parallelize(data)</span><br><span class="line">&gt;&gt;&gt; rdd2 = rdd1.map(lambda x:x+10)</span><br><span class="line">&gt;&gt;&gt; rdd2.foreach(print)</span><br></pre></td></tr></table></figure><p><img src="/images/loading.gif" data-original="/images/spark/22.png" alt="1678724836563"></p><p>上述语句执行过程如图 所示。第 1行语句创建了一个包含 5 个整型元素的列表 data。第2行语句执行 sc.parallelize(data)，从列表 data 中生成一个 RDD，即 rdd1,rdd1 中包含了5 个整型的元素即1、2、3、4、5。第 3 行语句执行 rdd1.map0操作,map0的输入参数“lambda x:x+10”是一个Lambda表达式。rdd1.map(lambda x:x+10)的含义是，依次取出 rdd1 这个RDD 中的每个元素，对于当前取到的元素，把它赋值给 Lambda 表达式中的变量x，然后，执行 Lambda 表达式的函数体部分“x+10”也就是把变量x的值和 10 相加后，作为函数的返回值，并作为一个元素放入到新的 RDD(即rdd2中。最终，新牛成的RDD (即 rdd2) 中包含了 5 个整型元素，即 11、12、13、14、15。</p><p>另外一个实例：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt;lines=sc.textFile(&quot;file:///usr/local/spark/mycode/rdd/word.txt&quot;)</span><br><span class="line">&gt;&gt;&gt; words = lines.map(lambda line:line.split(&quot; &quot;))</span><br><span class="line">&gt;&gt;&gt; words.foreach(print)</span><br></pre></td></tr></table></figure><p><img src="/images/loading.gif" data-original="/images/spark/24.png" alt="1678725201907"></p><p>上述语句执行过程如图所示。在第 1 行语句中，执行 sc.textFile0方法把 word.txt 文件中的数据加载到内存生成一个 RDD，即 lines，这个RDD 中的每个元素都是字符串类型，即每个 RDD 元素都是一行文本，比如，lines 中的第 1 个元素是”Hadoop is good”，第2 个元素是”Spark is fast”，第3个元素是”Spark is better”。在第 2 行语句中，执行 lies.map0操作，map0的输入参数 lambdaline:line.split(“)是一个 Lambda 表达式。linesmap(lambda line:line.split(“”)的含义是，依次取出 lines这个 RDD 中的每个元素，对于当前取到的元素，把它赋值给 Lambda 表达式中的变量 line，然后，执行 Lambda 表达式的函数体部分 line.split(“”)。因为 line 是一行文本，如”Hadoop is good”，一行文本中包含了很多个单词，单词之间以空格进行分隔，所以，line.split(“”的功能是，以空格作为分隔符把 line 拆分成一个个单词,拆分后得到的单词都封装在一个列表对象中,成为新的 RDD( 即 words)的一个元素，比如，”Hadoop is good”被拆分后，得到”Hadoop”、”is”和”good”3 个单词，会被封装到一个列表对象中，即[“Hadoop”.”is”,”good”]，成为 words 这个 RDD 中的一个元素。</p><p><img src="/images/loading.gif" data-original="/images/spark/23.png" alt="1678725073888"></p><h4 id="3-flatMap-func"><a href="#3-flatMap-func" class="headerlink" title="3.flatMap(func)"></a>3.flatMap(func)</h4><p>flatMap(func)与 map0相似，但每个输入元素都可以映射到 0 或多个输出结果。例如:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt;lines=sc.textFile(&quot;file:///usr/local/spark/mycode/rdd/word.txt&quot;)</span><br><span class="line">&gt;&gt;&gt;words =lines.flatMap(lambda line:line.split(&quot; &quot;))</span><br><span class="line">&gt;&gt;&gt; words.foreach(print)</span><br></pre></td></tr></table></figure><p><img src="/images/loading.gif" data-original="/images/spark/26.png" alt="1678725603008"></p><p>上述语句执行过程如图所示。在第 1行语句中，执行 sc.textFile0方法把 wordtxt 文件中的数据加载到内存生成一个RDD，即 lines，这个 RDD 中的每个元素都是字符串类型，即每个RDD 元素都是一行文本。在第2行语句中，执行 linesflatMap0操作，flatMap0的输入参数 line:linesplit(“”)是个Lambda 表达式。lines.flatMap(lambda line:line.split(“”))的结果，等价于如下两步操作的结果。</p><p><img src="/images/loading.gif" data-original="/images/spark/25.png" alt="1678725419517"></p><p>第1步: map0。执行 lines.map(lambda line: linesplit(“”))操作，从 lines 转换得到一个新的 RDD(即wordArray),wordArray 中的每个元素都是一个列表,比如,第1个元素是[“Hadoop”,”is”，”good”]7.第2个元素是”Spark”，”is”,”fast”]，第3 个元素是[“Spark”,”is””better”]。</p><p>第 2步:拍扁 ( flat)。flatMap0操作中的“flat”是一个很形象的动作-“拍扁”，也就是把vordArray 中的每个 RDD 元素都“拍扁”成多个元素。所有这些被拍扁以后得到的元素，构成一个新的 RDD，即 words。比如，wordArray 中的第1个元素是[“Hadoop”,”is”,”good]，被拍扁以后得到3个新的字符串类型的元素,即”Hadoop”、”is”和”good”; wordArray 中的第 2 个元素是[“Spark”,”is”fast”],被拍扁以后得到 3 个新的元素,即”Spark”、”is”和”fast”; wordArray 中的第 3 个元素是[“Spark””is””beter”，被拍扁以后得到 3 个新的元素，即”Spark”、”is”和”beter”。最终，这些被拍扁以后得到的 9 个字符串类型的元素构成一个新的 RDD (即 words )。也就是说，words 里面包含了 9 个字串类型的元素，分别是”Hadoop”、”is”、”good”、”Spark”、”is”、”fast”、”Spark”、”is”和”‘better’。</p><h4 id="4-gropByKey"><a href="#4-gropByKey" class="headerlink" title="4.gropByKey"></a>4.gropByKey</h4><p>groupByKey()应用于(K,V)键值对的数据集时，返回一个新的(K,Iterable)形式的数据集。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">words=sc.parallelize([(&quot;Hadoop&quot;,1),(&quot;is&quot;,1),(&quot;good&quot;,1),(&quot;Spark&quot;,1),(&quot;is&quot;,1),(&quot;better&quot;,1)])</span><br><span class="line">words1=words.groupByKey()</span><br><span class="line">words1.foreach(print)</span><br></pre></td></tr></table></figure><p><img src="/images/loading.gif" data-original="/images/spark/27.png" alt="1679317892865"></p><p><img src="/images/loading.gif" data-original="/images/spark/28.png" alt="1679318485755"></p><p><img src="/images/loading.gif" data-original="/images/spark/29.png" alt="1679318770911"></p><p>如图所示，在这个实例中，名称为 words 的 RDD 中包含了 9 个元素，每个元素都是(KV)键值对类型。wordsl&#x3D;words.groupByKey0操作执行以后，所有 key 相同的键值对，它们的 value都被归并到一起。比如，(“is”,1)、(“is”,1)、(is”,1)这3 个键值对的 key 相同，就会被归并成一个新的键值对(“is”,(1,1,1))，其中，key 是”is”，value 是(1,1,1)，而且，value 会被封装成 Iterable 对象 (一种可选代集合 )。</p><h4 id="5-reduceByKey-func"><a href="#5-reduceByKey-func" class="headerlink" title="5.reduceByKey(func)"></a>5.reduceByKey(func)</h4><p>reduceByKey(func)应用于(KV)键值对的数据集时，返回一个新的(K,V)形式的数据集，其中的每个值是将每个key传递到函数func中进行聚合后得到的结果</p><p><img src="/images/loading.gif" data-original="/images/spark/30.png" alt="1679318833321"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">words=sc.parallelize([(&quot;Hadoop&quot;,1),(&quot;is&quot;,1),(&quot;good&quot;,1),(&quot;Spark&quot;,1),(&quot;is&quot;,1),(&quot;better&quot;,1)])</span><br><span class="line">words1=words.reduceByKey(lambda a,b:a+b)</span><br><span class="line">words1.foreach(print)</span><br></pre></td></tr></table></figure><p><img src="/images/loading.gif" data-original="/images/spark/31.png" alt="1679319056594"></p><p><img src="/images/loading.gif" data-original="/images/spark/33.png" alt="1679319272140"></p><p><img src="/images/loading.gif" data-original="/images/spark/32.png" alt="1679319106659"></p><p>如图所示，在这个实例中，名称为 words 的 RDD 中包含了 9个元素，每个元素都是(K,V)键值对类型。words.reduceByKey(lambda a,b;atb)操作执行以后,所有 key 相同的键值对，它们的 value首先被归并到一起，比如，(“is”,1)、(“is”1)、(“is”,1)这3 个键值对的 key 相同，就会被归并成一个新的键值对(“is”,(1,1,1))，其中，key 是”is”，value 是一个 value-list，即(1,1,1)。然后，使用 func 函数把(l,1,1)聚合到一起，这里的 func 函数是一个Lambda 表达式，即 lambda a,b;atb，它的功能是把(1,1,1)这个 value-list 中的每个元素进行汇总求和。首先，把 value-list 中的第1个元素(即 1) 赋值给参数a，把 value-list 中的第 2个元素(也是 1)赋值给参数 b，执行 atb 得到 2，然后，继续对 value-list中的元素执行下一次计算，把刚才求和得到的 2 赋值给 a，把 value-list 中的第 3 个元素(即 1)赋值给b，再次执行 a+b 计算得到 3。最终，就得到聚合后的结果(‘is’,3)。</p><h3 id="Ⅱ行动操作"><a href="#Ⅱ行动操作" class="headerlink" title="Ⅱ行动操作"></a>Ⅱ行动操作</h3><p>行动操作是真正触发计算的地方。Spark程序执行到行动操作时，才会执行真正的计算，从文件中加载数据，完成一次又一次转换操作，最终，完成行动操作得到结果。</p><p><img src="/images/loading.gif" data-original="/images/spark/34.png" alt="1679319390149"></p><p>用一个例子看看</p><p><img src="/images/loading.gif" data-original="/images/spark/35.png" alt="1679319465685"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">rdd =sc.parallelize([1,2,3,4,5])</span><br><span class="line">rdd.count()</span><br></pre></td></tr></table></figure><p><code>5</code></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">rdd.first()</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><code>1</code></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rdd.take(3)</span><br></pre></td></tr></table></figure><p><code>[1, 2, 3]</code></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rdd.reduce(lambda a,b:a+b)</span><br></pre></td></tr></table></figure><p><code>15</code></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rdd.collect()</span><br></pre></td></tr></table></figure><p><code>[1, 2, 3, 4, 5]</code></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rdd.foreach(lambda elem:print(elem))</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td></tr></table></figure><p>这里首先使用 sc.parallelize([1,2,3,4,5])生成了一个 RDD,变量名称为 rdd,rdd 中包含了5个元素分别是1、2、3、4和5，因此，rdd.count0语句执行以后返回的结果是 5。执行 rdd.first0语句后，会返回第1个元素，即1。当执行完 rdd.take(3)语句以后，会以列表的形式返回 rdd 中的前 3 个元素即[1,2,3]。执行完<code>rdd.reduce(lambda a,b:a+b)</code>语句后，会得到对 rdd 中的所有元素(即1、2、3、4、5进行求和以后的结果，即 15。在执行 rdd.reduce(lambda a,b;atb)时，系统会把 rdd 中的第1个元素1传入参数 a，把rdd 的第2个元素 2 传入参数 b，执行 a+b 计算得到求和结果 3;然后，把这个求和的结果 3 传入给参数 a，把 rdd 的第 3 个元素3 传入参数 b，执行 atb 计算得到求和结果 6; 然后,把6传入参数 a，把 rdd 的第 4 个元素 4 传入参数 b，执行 a+b 计算得到求和结果 10; 最后，把 10传入参数 a，把 rdd 的第 5个元素 5 传入参数 b，执行 atb 算得到求和结果 S。接下来，执行<code>rdd.collect()</code>，以列表的形式返回 rdd 中的所有元素，可以看出，执行结果是一个列表[1,2,3,4,5]。在这个实例的最后，执行了语句 <code>rdd.foreach(lambda elem:print(elem)</code>，该语句会依次遍历 rdd 中的每个元素，把当前遍历到的元素赋值给变量 elem，并使用 print(elem)打印出 elem 的值。实际上<code>rdd.foreach(lambda elem:print(elem))</code>可以被简化成<code>rdd.foreach(print)</code>，执行效果是一样的。<br>需要特别强调的是,当采用Local 模式在单机上执行时,<code>rdd.foreach(print)</code>语句会打印出一个RDD中的所有元素。但是，当采用集群模式执行时，在 Worker 节点上执行打印语句是输出到 Worker 节点的 stdout 中，而不是输出到任务控制节点 Driver 中，因此，任务控制节点 Driver 中的 stdout 是不会显示打印语句的这些输出内容的。为了能够把所有 Worker 节点上的打印输出信息也显示到 Driver中，就需要使用 collect0方法，比如，<code>print(rdd.collect())</code>。但是，由于 collect0方法会把各个 Worker节点上的所有 RDD元素都抓取到 Driver 中，因此，这可能会导致 Driver 所在节点发生内存溢出。所以，在实际编程中，需要谨慎使用&#96;&#96;&#96; collect()&#96;&#96;方法。</p><h3 id="Ⅲ惰性机制"><a href="#Ⅲ惰性机制" class="headerlink" title="Ⅲ惰性机制"></a>Ⅲ惰性机制</h3><p>惰性机制是指整个转换过程只是记录了转换的轨迹，并不会发生真正的计算，只有遇到行动操作时，才会触发“从头到尾”的真正的计算。这里给出一段简单的语句来解释 Spark 的惰性机制。</p><p><img src="/images/loading.gif" data-original="/images/spark/37.png" alt="1679320607704"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">lines=sc.textFile(&quot;file:///usr/local/spark/mycode/rdd/word.txt&quot;)</span><br><span class="line">lineLengths=lines.map(lambda s:len(s))</span><br><span class="line">totalLength=lineLengths.reduce(lambda a,b:a+b)</span><br><span class="line">print(totalLength)</span><br></pre></td></tr></table></figure><p>在上述语句中，第1 行语句中的 textFile()是一个转换操作，执行后，系统只会记录这次转换，并不会真正读取 wordtxt 文件的数据到内存中;第 2 行语句的 map也是一个转换操作，系统只是记录这次转换，不会真正执行 map()方法;第 3 行语句的 reduce()方法是一个“行动”类型的操作，这时，系统会生成一个作业，触发真正的计算。也就是说，这时才会加载 word.txt 的数据到内存，生成lines 这个RDD。lines 中的每个元素都是一行文本，然后，对 lines 执行 map()方法，计算这个RDD中每个元素的长度(即一行文本包含的单词个数 )，得到新的 RDD，即 lineLengths，这个RDD中每个元素都是整型，表示文本的长度。最后，在 lineLengths 上调用reduce()方法，执行 RDD元素求和，得到所有文本长度的总和。</p><h2 id="持久化"><a href="#持久化" class="headerlink" title="持久化"></a>持久化</h2><p>在 Spark 中，RDD 采用惰性求值的机制，每次遇到行动操作，都会从头开始执行计算。每次调用行动操作，都会触发一次从头开始的计算，这对于迭代计算而言，代价是很大的，因为选代计算经常需要多次重复使用同一组数据。下面就是多次计算同一个 RDD 的例子。</p><p><img src="/images/loading.gif" data-original="/images/spark/38.png" alt="1679321131046"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">list = [&quot;Hadoop&quot;,&quot;Spark&quot;,&quot;Hive&quot;]</span><br><span class="line">rdd = sc.parallelize(list)</span><br><span class="line">print (rdd.count ()) #行动操作，触发一次真正从头到尾的计算</span><br><span class="line">print (&#x27;,&#x27;.join(rdd.collect())) #行动操作，触发一次真正从头到尾的计算Hadoop,Spark,Hive</span><br></pre></td></tr></table></figure><p><img src="/images/loading.gif" data-original="/images/spark/39.png" alt="1679320828250"></p><p>实际上，可以通过持久化(缓存)机制来避免这种重复计算的开销。具体方法是使用 persist0方法将一个 RDD 标记为持久化，之所以要“标记为持久化”，是因为出现 persist0语句的地方，并不会马上计算生成 RDD 并把它持久化，而是要等到遇到第一个行动操作触发真正计算以后，才会把算结果进行持久化。持久化后的 RDD 将会被保留在计算节点的内存中，被后面的行动操作重复使用persist0的圆括号中包含的是持久化级别参数，可以有如下不同的级别。</p><ul><li><p>persist(MEMORY ONLY): 表示将 RDD作为反序列化的对象存储于JVM 中，如果内存足，就要按照 LRU 原则替换缓存中的内容。</p></li><li><p>persist(MEMORYAND DISK):表示将RDD作为反序列化的对象存储在JVM中，如果内存不足，超出的分区将会被存放在硬盘上。</p><p>一般而言，使用 cache()方法时，会调用 persist(MEMORY ONLY)。针对上面的实例，增加持久化语句以后的执行过程如下:</p></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">list = [&quot;Hadoop&quot;,&quot;Spark&quot;,&quot;Hive&quot;]</span><br><span class="line">rdd = sc.parallelize(list)</span><br><span class="line">rdd.cache() #会调用 persist(MEMORY ONLY)，但是，语句执行到这里，并不会缓存 rdd，因为这#时 rdd 还没有被计算生成</span><br><span class="line">print(rdd.count()) #第一次行动操作，触发一次真正从头到尾的计算，这时上面的 rdd.cache ()#才会被执行，把这个 rdd 放到缓存中</span><br><span class="line">print(&#x27;.&#x27;.join(rdd.collect())) #第二次行动操作，不需要触发从头到尾的计算，只需要重复使#用上面缓存中的 rdd</span><br></pre></td></tr></table></figure><p><img src="/images/loading.gif" data-original="/images/spark/40.png" alt="1679321297416"></p><p>持久化RDD 会占用内存空间，当不再需要一个 RDD 时，就可以使用 unpersist0方法手动地把持久化的 RDD 从缓存中移除，释放内存空间。</p><h3 id="分区"><a href="#分区" class="headerlink" title="分区"></a>分区</h3><h4 id="1-分区的作用"><a href="#1-分区的作用" class="headerlink" title="1.分区的作用"></a>1.分区的作用</h4><p>RDD 是弹性分布式数据集，通常 RDD 很大，会被分成很多个分区，分别保存在不同的节点上如图49所示，一个集群中包含 4 个工作节点( WorkerNode )，分别是 WorkerNodel、WorkerNode2WorkerNode3 和 WorkerNode4。假设有两个 RDD，即rdd1 和 rdd2，其中，rdd1 包含5 个分区(即plp2、p3、p4和p5)，rdd2 包含3 个分区(即p6、p7和p8)。<br>对RDD 进行分区，第一个作用是增加并行度。比如，在图 4-9 中，rdd2 的 3 个分区 p6、p7和p8,分布在3 个不同的工作节点 WorkerNode2、WorkerNode3 和 WorkerNode4 上，就可以在这3个T作节点上分别启动 3 个线程对这 3 个分区的数据进行并行处理，增加任务的并行度。</p><p><img src="/images/loading.gif" data-original="/images/spark/41.png" alt="1679321394814"></p><p>对 RDD 进行分区的第二个作用是减少通信开销。在分布式系统中，通信的代价是巨大的，控制数据分布以获得最少的网络传输可以极大地提升整体性能。Spark 程序可以通过控制 RDD 分区方式来减少网络通信的开销。下面通过一个实例来解释为什么通过分区可以减少网络传输开销。</p><p>连接(join)是查询分析中经常使用的一种操作。假设在某种应用中需要对两个表进行连接操作第1个表是一个很大的用户信息表 UserData(UserID,UserInfo)，其中，UserId 和 UserInfo 是 UserData表的两个字段，UserInfo 包含了某个用户所订阅的主题信息。第 2 个表是 Events(UserID,LinkInfo),这个表比较小，只记录了过去 5 分钟内发生的事件，即某个用户查看了哪个链接。为了对用户访问情况进行统计，需要周期性地对 UserData 和 Events 这两个表进行连接操作，获得(UserID,UserInfo,LinkInfo)这种形式的结果，从而知道某个用户订阅的是哪个主题，以及访问了哪个链接。</p><p>可以用 Spark 来实现上述应用场景。在执行 Spark 作业时，首先，UserData 表会被加载到内存中生成RDD(假设 RDD的名称为 userData)，RDD 中的每个元素是(UserID,UserInfo)这种形式的键值对,即 key 是 UserID,value 是 UserInfo;Events 表也会被加载到内存中生成RDD(假设名称为 events)RDD中的每个元素是(UserID，LinkInfo)这种形式的键值对，key 是 UserID，value 是 LinkInfo。由于UserData 是一个很大的表，通常会被存放到 HDFS 文件中，Spark 系统会根据每个 RDD 元素的数据来源，把每个 RDD 元素放在相应的节点上。比如，从工作节点 上的 HDFS 文件块 (block)中读取到的记录，其生成的 RDD 元素 ((UserID，UserInfo)形式的键值对 ，就会被放在节点上，从节点上的 HDFS 文件块 (block)中读取到的记录，其生成的 RDD 元素会被放在节点上，最终userData 这个 RDD 的元素就会分布在节点u1、u2…..um上。<br>然后，执行连接操作 userData,join(events)得到连接结果。如图 所示，在默认情况下，连接操作会将两个数据集中的所有的 key 的哈希值都求出来，将哈希值相同的记录传送到同一台机器上之后在该机器上对所有 key 相同的记录进行连接操作。比如，对于 userData 这个 RDD 而言，它在节点山上的所有 RDD 元素，都需要根据 key 的值进行哈，然后，根据哈希值再分发到 j1、j2…..j这些节点上;在节点u上的所有 RDD 元素，也需要根据 key 的值进行哈希，然后，根据哈希值再分发到j1……jk这些节点上;同理，u1……um等节点上的 RDD元素，都需要进行同样的操作对于events 这个RDD 而言，也需要执行同样的操作。可以看出，在这种情况下，每次进行连接操作都会有数据混洗的问题，造成了很大的网络传输开销。</p><p><img src="/images/loading.gif" data-original="/images/spark/42.png" alt="1679321456313"></p><p>实际上，由于userData 这个 RDD 要比 events 大很多，所以，可以选择对 userData 进行分区。比如.可以采用哈希分区方法，把 userData 这个 RDD 分区成 m 个分区，这些分区分布在节点 、u…“u，上。对userData 进行分区以后，在执行连接操作时，就不会产生图 4-10 中的数据混洗情况。如图所示，由于已经对 userData 根据哈希值进行了分区，因此，在执行连接操作时，不需要再把 userData中的每个元素进行哈希求值以后再分发到其他节点上，只需要对 events 这个 RDD 的每个元素求哈希值(采用与 userData 相同的哈希函数)。然后，根据哈希值把每个 events 中的 RDD 元素分发到对应的节点u、u····um上面。整个过程中，只有 events 发生了数据混洗，产生了网络通信，而 userData的数据都是在本地引用，不会产生网络传输开销。由此可以看出，Spark 通过数据分区，可以大大降低一些特定类型的操作(比如join()、leftOuterJoin()、groupByKey()、reduceByKey()等)的网络传输开销。</p><p><img src="/images/loading.gif" data-original="/images/spark/43.png" alt="1679321697993"></p><h4 id="2-分区的原则"><a href="#2-分区的原则" class="headerlink" title="2.分区的原则"></a>2.分区的原则</h4><p><img src="/images/loading.gif" data-original="/images/spark/44.png" alt="1679322183409"></p><p>RDD分区的一个原则是使得分区的个数尽量等于集群中的 CPU核心(Core)数目。对于不同的Spark 部署模式 (Local 模式、Standalone 模式、YARN 模式、Mesos 模式)而言，都可以通过设置spark.defaultparallelism 这个参数的值，来配置默认的分区数目。一般而言，各种模式下的默认分区数目如下。<br>Local模式:默认为本地机器的 CPU 数目，若设置了 local[N]，则默认为 N。Standalone 或YARN模式:在“集群中所有 CPU 核心数目总和”和“2”这二者中取较大值作为<br>默认值。<br>Mesos 模式:默认的分区数为 8。</p><h4 id="3-设置分区的个数"><a href="#3-设置分区的个数" class="headerlink" title="3.设置分区的个数"></a>3.设置分区的个数</h4><p>可以手动设置分区的数量，主要包括两种方式: 创建 RDD 时手动指定分区个数;使用repartition方法重新设置分区个数。</p><h5 id="1-创建RDD-时手动指定分区个数"><a href="#1-创建RDD-时手动指定分区个数" class="headerlink" title="(1)创建RDD 时手动指定分区个数"></a>(1)创建RDD 时手动指定分区个数</h5><p><img src="/images/loading.gif" data-original="/images/spark/45.png" alt="1679322207468"></p><p>在调用 textFile()和 parallelize()方法的时候手动指定分区个数即可，语法格式如下:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sc.textFile(path, partitionNum)</span><br></pre></td></tr></table></figure><p>其中，path 参数用于指定要加载的文件的地址，partitionNum 参数用于指定分区个数。下面是个分区的实例。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">list = [1,2,3,4,5]</span><br><span class="line">rdd = sc.parallelize(list,2) //设置两个分区</span><br></pre></td></tr></table></figure><p>对于 parallelize()而言，如果没有在方法中指定分区数，则默认为 spark.default,parallelism。对于textFile()而言，如果没有在方法中指定分区数，则默认为 min(defaultParallelism,2)，其中defaultParallelism 对应的就是 spark.default,parallelism。如果是从HDFS 中读取文件，则分区数为文件分片数(比如，128MB&#x2F;片 )。</p><h5 id="2-使用repartition-方法重新设置分区个数"><a href="#2-使用repartition-方法重新设置分区个数" class="headerlink" title="(2)使用repartition 方法重新设置分区个数"></a>(2)使用repartition 方法重新设置分区个数</h5><p><img src="/images/loading.gif" data-original="/images/spark/46.png" alt="1679322237913"></p><p>通过转换操作得到新 RDD 时，直接调用 repartition 方法即可。例如:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">data = sc.parallelize([1,2,3,4,5],2)</span><br><span class="line">len(data.glom().collect ()) #显示 data 这个 RDD 的分区数量</span><br><span class="line">2</span><br><span class="line">rdd = data.repartition(1) #对 data 这个RDD进行重新分区</span><br><span class="line">len(rdd.glom().collect())#显示 rdd 这个 RDD的分区数量</span><br><span class="line">1</span><br></pre></td></tr></table></figure><h4 id="4-自定义分区方法"><a href="#4-自定义分区方法" class="headerlink" title="4.自定义分区方法"></a>4.自定义分区方法</h4><p><img src="/images/loading.gif" data-original="/images/spark/47.png" alt="1679322265099"></p><p><img src="/images/loading.gif" data-original="/images/spark/48.png" alt="1679322297300"></p><p>Spark 提供了自带的 HashPartitioner (哈希分区)与 RangePartitioner ( 区城分区)，能够满足大数应用场景的需求。与此同时，Spark 也支持自定义分区方式，即通过提供一个自定义的分区函数来控制 RDD 的分区方式，从而利用领域知识进一步减少通信开销。需要注意的是，Spark 的分区函数针对的是(key;value)类型的 RDD，也就是说，RDD 中的每个元素都是(key,value)类型，然后，分区数根据 key对RDD 元素进行分区。因此，当需要对一些非(key,value)类型的 RDD进行自定义分区时需要首先把 RDD 元素转换为(key,value)类型，然后再使用分区函数。<br>下面是一个实例，要求根据 key 值的最后一位数字将 key 写入到不同的文件中，比如，10 写入到part-00000，11写入到 part-00001，12 写入到 part-00002。打开一个 Linux 终端，使用 vim 编辑器创建一个代码文件“&#x2F;usr&#x2F;local&#x2F;spark&#x2F;mycode&#x2F;rdd&#x2F;TestPartitioner.py”，输入以下代码:</p><p><img src="/images/loading.gif" data-original="/images/spark/49.png" alt="1679322332812"></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pyspark <span class="keyword">import</span> SparkConf, SparkContext</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">MyPartitioner</span>(<span class="params">key</span>):</span><br><span class="line">	<span class="built_in">print</span>(<span class="string">&quot;MyPartitioner is running&quot;</span>)</span><br><span class="line">	<span class="built_in">print</span>(<span class="string">&#x27;The key is %d&#x27;</span> % key)</span><br><span class="line">	<span class="keyword">return</span> key%<span class="number">10</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">main</span>():</span><br><span class="line">	<span class="built_in">print</span>(<span class="string">&quot;The main function is running&quot;</span>)	</span><br><span class="line">	conf=SparkConf().setMaster(<span class="string">&quot;local&quot;</span>).setAppName(<span class="string">&quot;MyApp&quot;</span>)</span><br><span class="line">	sc=SparkContext(conf=conf)</span><br><span class="line">	data=sc.parallelize(<span class="built_in">range</span>(<span class="number">10</span>),<span class="number">5</span>)</span><br><span class="line">	data.<span class="built_in">map</span>(<span class="keyword">lambda</span> x:(x,<span class="number">1</span>)) \</span><br><span class="line">	         .partitionBy(<span class="number">10</span>,MyPartitioner)\</span><br><span class="line">             .<span class="built_in">map</span>(<span class="keyword">lambda</span> x:x[<span class="number">0</span>]) \</span><br><span class="line">	         .saveAsTextFile(<span class="string">&quot;File:///usr/local/spark/mycode/add/partitioner&quot;</span>)</span><br><span class="line"><span class="keyword">if</span> __name__==<span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">	main()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>出现问题</p><p><code>ModuleNotFoundError: No module named &#39;pyspark&#39;</code></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">apt install python3-pip</span><br><span class="line">pip install pyspark</span><br></pre></td></tr></table></figure><p>在上述代码中，data&#x3D;sc.parallelize(range(10),5)这行代码执行后，会生成一个名称为 data 的 RDD这个RDD 中包含了 0、1、2、3…..9 共 10 个整型元素，并被分成 5个分区。data,map(lambda x:(x,1)表示把 data 中的每个整型元素取出来，转换成(key,value)类型。比如，把1 这个元素取出来以后转按成(1,1)，把2这个元素取出来以后转换成(2,1)，这是因为，自定义分区函数要求 RDD 元素的类型必须是(key, value)类型。partitionBy(10,MyPartitioner表示调用自定义分区函数，把(0,1)、(,)、(2,1)、(3,1)….(9,1)这些 RDD 元素根据尾号分成10个分区。划分分区完成以后,再使用 map(ambda x:x[0).把(0,1)、(1,1)、(2,1)、(3,1) .·….(9,1)等(key,value)类型元素的 key 提取出来，得到 0、1、2、3…9.最后调用 saveAsTextFile0方法把 RDD的 10个整型元素写入到本地文件中。</p><p>使用如下命令运行 TestPartitioner.py:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cd /usr/local/spark/mycode/rdd</span><br><span class="line">python3 TestPartitioner.py</span><br></pre></td></tr></table></figure><p>or</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ cd /usr/local/spark/mycode/rdd</span><br><span class="line">S /usr/local/spark/bin/spark-submit TestPartitioner.py</span><br></pre></td></tr></table></figure><p>程序运行后会返回如下信息:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">The main function is running</span><br><span class="line">MyPartitioner is running</span><br><span class="line">The key is 0</span><br><span class="line">MyPartitioner is running</span><br><span class="line">The key is 1</span><br><span class="line">MyPartitioner is running</span><br><span class="line">The key is 9</span><br></pre></td></tr></table></figure><p><img src="/images/loading.gif" data-original="/images/spark/50.png" alt="1679322360532"></p><p>运行结束后可以看到，在本地文件系统的“file:&#x2F;&#x2F;&#x2F;usr&#x2F;local&#x2F;spark&#x2F;mycode&#x2F;rdd&#x2F;partitioner”目录下面，会生成 part-00000、part-00001、part-00002…..part-00009 和_SUCCESS 等文件。其中,part-00000文件中包含了数字 0，part-00001 文件中包含了数字 1，part-00002 文件中包含了数字 2</p><h3 id="综合实例"><a href="#综合实例" class="headerlink" title="综合实例"></a>综合实例</h3><p>假设有一个本地文件“&#x2F;usr&#x2F;local&#x2F;spark&#x2F;mycode&#x2F;rdd&#x2F;word.txt”，里面包含了很多行文本，每行文本由多个单词构成，单词之间用空格分隔。可以使用如下语句对 word.txt 中的单词进行词频统计(即统计每个单词出现的次数 ):</p><p><img src="/images/loading.gif" data-original="/images/spark/51.png" alt="1679329145076"></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">lines=sc.textFile(<span class="string">&quot;file:///usr/local/spark/mycode/rdd/word.txt&quot;</span>)</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wordCount=lines.flatMap(<span class="keyword">lambda</span> line:line.split(<span class="string">&quot; &quot;</span>)).<span class="built_in">map</span>(<span class="keyword">lambda</span> word:(word,<span class="number">1</span>)).reduceByKey(<span class="keyword">lambda</span> a,b:a+b)</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">print</span>(wordCount.collect())</span><br></pre></td></tr></table></figure><p><img src="/images/loading.gif" data-original="/images/spark/52.png" alt="1679329176974"></p><p><img src="/images/loading.gif" data-original="/images/spark/53.png" alt="1679329211688"></p><p><img src="/images/loading.gif" data-original="/images/spark/54.png" alt="1679329237135"></p><p>在实际应用中，单词文件可能非常大，会被保存到分布式文件系统 HDFS 中，Spark 和 Hadoop会统一部署在一个集群上。如图所示，HDFS 的名称节点(HDFS NN)和 Spark 的主节点( SparkMaster)可以分开部署，而HDFS 的数据节点(HDFS DN)和 Spark 的从节点 ( Spark Worker)会部署在一起。这时采用 Spark 进行分布式处理,可以大大提高词频统计程序的执行效率,这是因为,SparkWorker 可以就近处理与自己部署在一起的 HDFS 数据节点中的数据。</p><p>对于词频统计程序 WordCount 而言，该程序分布式运行在每个 Slave 节点的每个分区上，统计本分区内的单词计数，然后将它传回给 Driver，再由 Driver 合并来自各个分区的所有单词计数，形成最终的单词计数。</p></div><div><div><div style="text-align:center;color:#ccc;font-size:24px">-------------本文结束<i class="fa fa-paw"></i>感谢您的阅读-------------</div></div></div><div class="reward-container"><div>老板你好，讨口饭吃</div><button onclick='var qr=document.getElementById("qr");qr.style.display="none"===qr.style.display?"block":"none"'>打赏</button><div id="qr" style="display:none"><div style="display:inline-block"><img src="/images/loading.gif" data-original="/images/wechat.jpg" alt="毛 微信支付"><p>微信支付</p></div><div style="display:inline-block"><img src="/images/loading.gif" data-original="/images/alipay.jpg" alt="毛 支付宝"><p>支付宝</p></div></div></div><div><ul class="post-copyright"><li class="post-copyright-author"><strong>本文作者： </strong>毛</li><li class="post-copyright-link"><strong>本文链接：</strong> <a href="http://example.com/2023/03/20/spark/" title="Spark入门：RDD编程（1）">http://example.com/2023/03/20/spark/</a></li><li class="post-copyright-license"><strong>版权声明： </strong>本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" rel="noopener" target="_blank"><i class="fab fa-fw fa-creative-commons"></i>BY-NC-SA</a> 许可协议。转载请注明出处！</li></ul></div><footer class="post-footer"><div class="post-tags"><a href="/tags/Spark/" rel="tag"># Spark</a></div><div class="post-nav"><div class="post-nav-item"><a href="/2023/03/20/UML%E7%B1%BB%E5%9B%BE-&-UML%E6%97%B6%E5%BA%8F%E5%9B%BE/" rel="prev" title="UML类图 & UML时序图"><i class="fa fa-chevron-left"></i> UML类图 & UML时序图</a></div><div class="post-nav-item"><a href="/2023/03/21/Spark%E5%85%A5%E9%97%A8%EF%BC%9ARDD%E7%BC%96%E7%A8%8B%EF%BC%882%EF%BC%89/" rel="next" title="Spark入门：RDD编程（2）">Spark入门：RDD编程（2） <i class="fa fa-chevron-right"></i></a></div></div></footer></article></div><div class="comments"><div id="lv-container" data-id="city" data-uid="MTAyMC81NzMzNC8zMzc5OA=="></div></div><script>window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }</script></div><div class="toggle sidebar-toggle"><span class="toggle-line toggle-line-first"></span> <span class="toggle-line toggle-line-middle"></span> <span class="toggle-line toggle-line-last"></span></div><aside class="sidebar"><div class="sidebar-inner"><ul class="sidebar-nav motion-element"><li class="sidebar-nav-toc">文章目录</li><li class="sidebar-nav-overview">站点概览</li></ul><div class="post-toc-wrap sidebar-panel"><div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#Spark%E5%85%A5%E9%97%A8%EF%BC%9ARDD%E7%BC%96%E7%A8%8B-1"><span class="nav-number">1.</span> <span class="nav-text">Spark入门：RDD编程(1)</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#4-1RDD%E7%BC%96%E7%A8%8B%E5%9F%BA%E7%A1%80"><span class="nav-number">2.</span> <span class="nav-text">4.1RDD编程基础</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#RDD%E5%88%9B%E5%BB%BA"><span class="nav-number">2.1.</span> <span class="nav-text">RDD创建</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%88%9B%E5%BB%BARDD%E4%B9%8B%E5%89%8D%E7%9A%84%E5%87%86%E5%A4%87%E5%B7%A5%E4%BD%9C"><span class="nav-number">2.1.1.</span> <span class="nav-text">创建RDD之前的准备工作</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BB%8E%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E4%B8%AD%E5%8A%A0%E8%BD%BD%E6%95%B0%E6%8D%AE%E5%88%9B%E5%BB%BARDD"><span class="nav-number">2.1.2.</span> <span class="nav-text">从文件系统中加载数据创建RDD</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%8A%A0%E8%BD%BDHDFS%E4%B8%AD%E7%9A%84%E6%96%87%E4%BB%B6"><span class="nav-number">2.1.3.</span> <span class="nav-text">加载HDFS中的文件</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%80%9A%E8%BF%87%E5%B9%B6%E8%A1%8C%E9%9B%86%E5%90%88%EF%BC%88%E6%95%B0%E7%BB%84%EF%BC%89%E5%88%9B%E5%BB%BARDD"><span class="nav-number">2.1.4.</span> <span class="nav-text">通过并行集合（数组）创建RDD</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#RDD%E6%93%8D%E4%BD%9C"><span class="nav-number">2.2.</span> <span class="nav-text">RDD操作</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E2%85%A0%E8%BD%AC%E6%8D%A2%E6%93%8D%E4%BD%9C"><span class="nav-number">2.2.1.</span> <span class="nav-text">Ⅰ转换操作</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#1-filter-func"><span class="nav-number">2.2.1.1.</span> <span class="nav-text">1.filter(func)</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-map-func"><span class="nav-number">2.2.1.2.</span> <span class="nav-text">2.map(func)</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-flatMap-func"><span class="nav-number">2.2.1.3.</span> <span class="nav-text">3.flatMap(func)</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#4-gropByKey"><span class="nav-number">2.2.1.4.</span> <span class="nav-text">4.gropByKey</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#5-reduceByKey-func"><span class="nav-number">2.2.1.5.</span> <span class="nav-text">5.reduceByKey(func)</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E2%85%A1%E8%A1%8C%E5%8A%A8%E6%93%8D%E4%BD%9C"><span class="nav-number">2.2.2.</span> <span class="nav-text">Ⅱ行动操作</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E2%85%A2%E6%83%B0%E6%80%A7%E6%9C%BA%E5%88%B6"><span class="nav-number">2.2.3.</span> <span class="nav-text">Ⅲ惰性机制</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%8C%81%E4%B9%85%E5%8C%96"><span class="nav-number">2.3.</span> <span class="nav-text">持久化</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%88%86%E5%8C%BA"><span class="nav-number">2.3.1.</span> <span class="nav-text">分区</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#1-%E5%88%86%E5%8C%BA%E7%9A%84%E4%BD%9C%E7%94%A8"><span class="nav-number">2.3.1.1.</span> <span class="nav-text">1.分区的作用</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-%E5%88%86%E5%8C%BA%E7%9A%84%E5%8E%9F%E5%88%99"><span class="nav-number">2.3.1.2.</span> <span class="nav-text">2.分区的原则</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-%E8%AE%BE%E7%BD%AE%E5%88%86%E5%8C%BA%E7%9A%84%E4%B8%AA%E6%95%B0"><span class="nav-number">2.3.1.3.</span> <span class="nav-text">3.设置分区的个数</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#1-%E5%88%9B%E5%BB%BARDD-%E6%97%B6%E6%89%8B%E5%8A%A8%E6%8C%87%E5%AE%9A%E5%88%86%E5%8C%BA%E4%B8%AA%E6%95%B0"><span class="nav-number">2.3.1.3.1.</span> <span class="nav-text">(1)创建RDD 时手动指定分区个数</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#2-%E4%BD%BF%E7%94%A8repartition-%E6%96%B9%E6%B3%95%E9%87%8D%E6%96%B0%E8%AE%BE%E7%BD%AE%E5%88%86%E5%8C%BA%E4%B8%AA%E6%95%B0"><span class="nav-number">2.3.1.3.2.</span> <span class="nav-text">(2)使用repartition 方法重新设置分区个数</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#4-%E8%87%AA%E5%AE%9A%E4%B9%89%E5%88%86%E5%8C%BA%E6%96%B9%E6%B3%95"><span class="nav-number">2.3.1.4.</span> <span class="nav-text">4.自定义分区方法</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%BB%BC%E5%90%88%E5%AE%9E%E4%BE%8B"><span class="nav-number">2.3.2.</span> <span class="nav-text">综合实例</span></a></li></ol></li></ol></li></ol></div></div><div class="site-overview-wrap sidebar-panel"><div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person"><img class="site-author-image" itemprop="image" alt="毛" src="/images/xiao.png"><p class="site-author-name" itemprop="name">毛</p><div class="site-description" itemprop="description">在梦里啥都有</div></div><div class="site-state-wrap motion-element"><nav class="site-state"><div class="site-state-item site-state-posts"><a href="/archives/"><span class="site-state-item-count">41</span> <span class="site-state-item-name">日志</span></a></div><div class="site-state-item site-state-categories"><a href="/categories/"><span class="site-state-item-count">2</span> <span class="site-state-item-name">分类</span></a></div><div class="site-state-item site-state-tags"><a href="/tags/"><span class="site-state-item-count">17</span> <span class="site-state-item-name">标签</span></a></div></nav></div><div class="links-of-author motion-element"><span class="links-of-author-item"><a href="https://github.com/maduit" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;maduit" rel="noopener" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a> </span><span class="links-of-author-item"><a href="mailto:825577940@qq.com" title="E-Mail → mailto:825577940@qq.com" rel="noopener" target="_blank"><i class="fa fa-envelope fa-fw"></i>E-Mail</a> </span><span class="links-of-author-item"><a href="https://blog.csdn.net/maduit?spm=1000.2115.3001.5343" title="CSDN → https:&#x2F;&#x2F;blog.csdn.net&#x2F;maduit?spm&#x3D;1000.2115.3001.5343" rel="noopener" target="_blank"><i class="codiepie fa-fw"></i>CSDN</a></span></div><div class="links-of-blogroll motion-element"><div class="links-of-blogroll-title"><i class="fa fa-envelope fa-fw"></i> links_settings</div><ul class="links-of-blogroll-list"><li class="links-of-blogroll-item"><a href="https://github.com/" title="https:&#x2F;&#x2F;github.com&#x2F;" rel="noopener" target="_blank">推荐阅读</a></li></ul></div></div></div></aside><div id="sidebar-dimmer"></div></div></main><footer class="footer"><div class="footer-inner"><div class="copyright">&copy; 2022-09 – <span itemprop="copyrightYear">2023</span> <span class="with-love"><i class="fa fa-heart"></i> </span><span class="author" itemprop="copyrightHolder">毛</span></div><div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://pisces.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Pisces</a> 强力驱动</div><div class="theme-info"><div class="powered-by"></div><span class="post-count">博客全站共45.4k字</span></div><script async src="//dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js"></script><span id="busuanzi_container_site_pv">总访问量<span id="busuanzi_value_site_pv"></span>次</span> <span class="post-meta-divider">|</span> <span id="busuanzi_container_site_uv">总访客数<span id="busuanzi_value_site_uv"></span>人</span> <span class="post-meta-divider">|</span><script>$(document).ready(function(){var e=setInterval(function(){"none"!=document.getElementById("busuanzi_container_site_pv").style.display&&($("#busuanzi_value_site_pv").html(parseInt($("#busuanzi_value_site_pv").html())+n),clearInterval(e));"none"!=$("#busuanzi_container_site_pv").css("display")&&($("#busuanzi_value_site_uv").html(parseInt($("#busuanzi_value_site_uv").html())+n),clearInterval(e))},50),n=2e4})</script><div class="busuanzi-count"><script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><span class="post-meta-item" id="busuanzi_container_site_uv" style="display:none"><span class="post-meta-item-icon"><i class="fa fa-user"></i> </span><span class="site-uv" title="总访客量"><span id="busuanzi_value_site_uv"></span> </span></span><span class="post-meta-divider">|</span> <span class="post-meta-item" id="busuanzi_container_site_pv" style="display:none"><span class="post-meta-item-icon"><i class="fa fa-eye"></i> </span><span class="site-pv" title="总访问量"><span id="busuanzi_value_site_pv"></span></span></span></div></div></footer></div><script color="0,0,255" opacity="0.5" zindex="-1" count="99" src="/lib/canvas-nest/canvas-nest.min.js"></script><script size="300" alpha="0.6" zindex="-1" src="/lib/canvas-ribbon/canvas-ribbon.js"></script><script src="/lib/anime.min.js"></script><script src="/lib/velocity/velocity.min.js"></script><script src="/lib/velocity/velocity.ui.min.js"></script><script src="/js/utils.js"></script><script src="/js/motion.js"></script><script src="/js/schemes/pisces.js"></script><script src="/js/next-boot.js"></script><script defer src="/lib/three/three.min.js"></script><script defer src="/lib/three/three-waves.min.js"></script><script>NexT.utils.loadComments(document.querySelector('#lv-container'), () => {
  window.livereOptions = {
    refer: location.pathname.replace(CONFIG.root, '').replace('index.html', '')
  };
  (function(d, s) {
    var j, e = d.getElementsByTagName(s)[0];
    if (typeof LivereTower === 'function') { return; }
    j = d.createElement(s);
    j.src = 'https://cdn-city.livere.com/js/embed.dist.js';
    j.async = true;
    e.parentNode.insertBefore(j, e);
  })(document, 'script');
});</script><script src="/live2dw/lib/L2Dwidget.min.js?094cbace49a39548bed64abff5988b05"></script><script>L2Dwidget.init({model:{jsonPath:"/live2dw/assets/koharu.model.json"},display:{position:"right",width:150,height:300},mobile:{show:!1},log:!1,pluginJsPath:"lib/",pluginModelPath:"assets/",pluginRootPath:"live2dw/",tagMode:!1})</script><style>[bg-lazy]{background-image:none!important;background-color:#eee!important}</style><script>window.imageLazyLoadSetting={isSPA:!1,preloadRatio:1,processImages:null}</script><script>window.addEventListener("load",function(){var t=/\.(gif|jpg|jpeg|tiff|png)$/i,r=/^data:image\/[a-z]+;base64,/;Array.prototype.slice.call(document.querySelectorAll("img[data-original]")).forEach(function(a){var e=a.parentNode;"A"===e.tagName&&(e.href.match(t)||e.href.match(r))&&(e.href=a.dataset.original)})})</script><script>!function(a){a.imageLazyLoadSetting.processImages=t;var e=a.imageLazyLoadSetting.isSPA,i=a.imageLazyLoadSetting.preloadRatio||1,o=r();function r(){var t=Array.prototype.slice.call(document.querySelectorAll("img[data-original]")),e=Array.prototype.slice.call(document.querySelectorAll("[bg-lazy]"));return t.concat(e)}function t(){e&&(o=r());for(var t,n=0;n<o.length;n++)0<=(t=o[n].getBoundingClientRect()).bottom&&0<=t.left&&t.top<=(a.innerHeight*i||document.documentElement.clientHeight*i)&&function(){var e=o[n];!function(t,e){if(t.hasAttribute("bg-lazy"))return t.removeAttribute("bg-lazy"),e();var n=new Image,a=t.getAttribute("data-original");n.onload=function(){t.src=a,t.removeAttribute("data-original"),e()},t.src!==a&&(n.src=a)}(e,function(){o=o.filter(function(t){return e!==t}),a.imageLazyLoadSetting.onImageLoaded&&a.imageLazyLoadSetting.onImageLoaded(e)})}()}function n(){clearTimeout(t.tId),t.tId=setTimeout(t,500)}t(),document.addEventListener("scroll",n),a.addEventListener("resize",n),a.addEventListener("orientationchange",n)}(this)</script></body></html><script type="text/javascript" src="/js/love.js"></script><canvas class="fireworks" style="position:fixed;left:0;top:0;z-index:1;pointer-events:none"></canvas><script type="text/javascript" src="//cdn.bootcss.com/animejs/2.2.0/anime.min.js"></script><script type="text/javascript" src="/js/fireworks.js"></script><script type="text/javascript" src="\js\snow.js"></script><script type="text/javascript" src="http://libs.baidu.com/jquery/1.8.3/jquery.js"></script><script type="text/javascript" src="http://libs.baidu.com/jquery/1.8.3/jquery.min.js"></script>